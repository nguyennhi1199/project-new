type QueryValue = string | number | undefined | null | boolean | Array<QueryValue> | Record<string, any>;
type QueryObject = Record<string, QueryValue | QueryValue[]>;
type ParsedQuery = Record<string, string | string[]>;
/**
 * Parses and decodes a query string into an object.
 *
 * input can be a query string with or without the leading `?`
 *
 * @note
 * The `__proto__` and `constructor` keys are ignored to prevent prototype pollution.
 *
 * @group Query_utils
 */
declare function parseQuery<T extends ParsedQuery = ParsedQuery>(parametersString?: string): T;
/**
 * Encodes a pair of key and value into a url query string value.
 *
 * If the value is an array, it will be encoded as multiple key-value pairs with the same key.
 *
 * @group Query_utils
 */
declare function encodeQueryItem(key: string, value: QueryValue | QueryValue[]): string;
/**
 * Stringfies and encodes a query object into a query string.
 *
 * @group Query_utils
 */
declare function stringifyQuery(query: QueryObject): string;

/**
 * Encode characters that need to be encoded on the path, search and hash
 * sections of the URL.
 *
 * @group encoding_utils
 *
 * @param text - string to encode
 * @returns encoded string
 */
declare function encode(text: string | number): string;
/**
 * Encode characters that need to be encoded on the hash section of the URL.
 *
 * @group encoding_utils
 *
 * @param text - string to encode
 * @returns encoded string
 */
declare function encodeHash(text: string): string;
/**
 * Encode characters that need to be encoded query values on the query
 * section of the URL.
 *
 * @group encoding_utils
 *
 * @param input - string to encode
 * @returns encoded string
 */
declare function encodeQueryValue(input: QueryValue): string;
/**
 * Encode characters that need to be encoded query values on the query
 * section of the URL and also encodes the `=` character.
 *
 * @group encoding_utils
 *
 * @param text - string to encode
 */
declare function encodeQueryKey(text: string | number): string;
/**
 * Encode characters that need to be encoded on the path section of the URL.
 *
 * @group encoding_utils
 *
 * @param text - string to encode
 * @returns encoded string
 */
declare function encodePath(text: string | number): string;
/**
 * Encode characters that need to be encoded on the path section of the URL as a
 * param. This function encodes everything `encodePath` does plus the
 * slash (`/`) character.
 *
 * @group encoding_utils
 *
 * @param text - string to encode
 * @returns encoded string
 */
declare function encodeParam(text: string | number): string;
/**
 * Decode text using `decodeURIComponent`. Returns the original text if it
 * fails.
 *
 * @group encoding_utils
 *
 * @param text - string to decode
 * @returns decoded string
 */
declare function decode(text?: string | number): string;
/**
 * Decode path section of URL (consistent with encodePath for slash encoding).
 *
 * @group encoding_utils
 *
 * @param text - string to decode
 * @returns decoded string
 */
declare function decodePath(text: string): string;
/**
 * Decodes query key (consistent with `encodeQueryKey` for plus encoding).
 *
 * @group encoding_utils
 *
 * @param text - string to decode
 * @returns decoded string
 */
declare function decodeQueryKey(text: string): string;
/**
 * Decode query value (consistent with encodeQueryValue for plus encoding).
 *
 * @group encoding_utils
 *
 * @param text - string to decode
 * @returns decoded string
 */
declare function decodeQueryValue(text: string): string;
/**
 * Encodes hostname with punycode encoding.
 *
 * @group encoding_utils
 */
declare function encodeHost(name?: string): string;

declare const protocolRelative: unique symbol;
interface ParsedURL {
    protocol?: string;
    host?: string;
    auth?: string;
    href?: string;
    pathname: string;
    hash: string;
    search: string;
    [protocolRelative]?: boolean;
}
interface ParsedAuth {
    username: string;
    password: string;
}
interface ParsedHost {
    hostname: string;
    port: string;
}
/**
 * Takes a URL string and returns an object with the URL's `protocol`, `auth`, `host`, `pathname`, `search`, and `hash`.
 *
 * @example
 *
 * ```js
 * parseURL("http://foo.com/foo?test=123#token");
 * // { protocol: 'http:', auth: '', host: 'foo.com', pathname: '/foo', search: '?test=123', hash: '#token' }
 *
 * parseURL("foo.com/foo?test=123#token");
 * // { pathname: 'foo.com/foo', search: '?test=123', hash: '#token' }
 *
 * parseURL("foo.com/foo?test=123#token", "https://");
 * // { protocol: 'https:', auth: '', host: 'foo.com', pathname: '/foo', search: '?test=123', hash: '#token' }
 * ```
 *
 * @group parsing_utils
 *
 * @param [input] - The URL to parse.
 * @param [defaultProto] - The default protocol to use if the input doesn't have one.
 * @returns A parsed URL object.
 */
declare function parseURL(input?: string, defaultProto?: string): ParsedURL;
/**
 * Splits the input string into three parts, and returns an object with those three parts.
 *
 * @group parsing_utils
 *
 * @param [input] - The URL to parse.
 * @returns An object with three properties: `pathname`, `search`, and `hash`.
 */
declare function parsePath(input?: string): ParsedURL;
/**
 * Takes a string of the form `username:password` and returns an object with the username and
 * password decoded.
 *
 * @group parsing_utils
 *
 * @param [input] - The URL to parse.
 * @returns An object with two properties: username and password.
 */
declare function parseAuth(input?: string): ParsedAuth;
/**
 * Takes a string, and returns an object with two properties: `hostname` and `port`.
 *
 * @group parsing_utils
 *
 * @param [input] - The URL to parse.
 * @returns A function that takes a string and returns an object with two properties: `hostname` and
 * `port`.
 */
declare function parseHost(input?: string): ParsedHost;
/**
 * Takes a `ParsedURL` object and returns the stringified URL.
 *
 * @group parsing_utils
 *
 * @example
 *
 * ```js
 * const obj = parseURL("http://foo.com/foo?test=123#token");
 * obj.host = "bar.com";
 *
 * stringifyParsedURL(obj); // "http://bar.com/foo?test=123#token"
 * ```
 *
 * @param [parsed] - The parsed URL
 * @returns A stringified URL.
 */
declare function stringifyParsedURL(parsed: Partial<ParsedURL>): string;
/**
 * Parses a url and returns last segment in path as filename.
 *
 * If `{ strict: true }` is passed as the second argument, it will only return the last segment only if ending with an extension.
 *
 * @group parsing_utils
 *
 * @example
 *
 * ```js
 * // Result: filename.ext
 * parseFilename("http://example.com/path/to/filename.ext");
 *
 * // Result: undefined
 * parseFilename("/path/to/.hidden-file", { strict: true });
 * ```
 */
declare function parseFilename(input: string, { strict }: {
    strict: any;
}): string | undefined;

/**
 * @deprecated use native URL with `new URL(input)` or `ufo.parseURL(input)`
 */
declare class $URL implements URL {
    protocol: string;
    host: string;
    auth: string;
    pathname: string;
    query: QueryObject;
    hash: string;
    constructor(input?: string);
    get hostname(): string;
    get port(): string;
    get username(): string;
    get password(): string;
    get hasProtocol(): number;
    get isAbsolute(): number | boolean;
    get search(): string;
    get searchParams(): URLSearchParams;
    get origin(): string;
    get fullpath(): string;
    get encodedAuth(): string;
    get href(): string;
    append(url: $URL): void;
    toJSON(): string;
    toString(): string;
}
/**
 * @deprecated use native URL with `new URL(input)` or `ufo.parseURL(input)`
 */
declare function createURL(input: string): $URL;

/**
 * Check if a path starts with `./` or `../`.
 *
 * @example
 * ```js
 * isRelative("./foo"); // true
 * ```
 *
 * @group utils
 */
declare function isRelative(inputString: string): boolean;
interface HasProtocolOptions {
    acceptRelative?: boolean;
    strict?: boolean;
}
/**
 * Checks if the input has a protocol.
 *
 * You can use `{ acceptRelative: true }` to accept relative URLs as valid protocol.
 *
 * @group utils
 */
declare function hasProtocol(inputString: string, opts?: HasProtocolOptions): boolean;
/** @deprecated Same as { hasProtocol(inputString, { acceptRelative: true }) */
declare function hasProtocol(inputString: string, acceptRelative: boolean): boolean;
/**
 * Checks if the input protocol is any of the dangerous `blob:`, `data:`, `javascript`: or `vbscript:` protocols.
 *
 * @group utils
 */
declare function isScriptProtocol(protocol?: string): boolean;
/**
 * Checks if the input has a trailing slash.
 *
 * @group utils
 */
declare function hasTrailingSlash(input?: string, respectQueryAndFragment?: boolean): boolean;
/**
 * Removes trailing slash from the URL or pathname.
 *
 * If second argument is true, it will only remove the trailing slash if it's not part of the query or fragment with cost of more expensive operations.
 *
 * @example
 *
 * ```js
 * withoutTrailingSlash("/foo/"); // "/foo"
 *
 * withoutTrailingSlash("/path/?query=true", true); // "/path?query=true"
 * ```
 *
 * @group utils
 */
declare function withoutTrailingSlash(input?: string, respectQueryAndFragment?: boolean): string;
/**
 * Ensures url ends with a trailing slash.
 *
 * If seccond argument is `true`, it will only add the trailing slash if it's not part of the query or fragment with cost of more expensive operation.
 *
 * @example
 *
 * ```js
 * withTrailingSlash("/foo"); // "/foo/"
 *
 * withTrailingSlash("/path?query=true", true); // "/path/?query=true"
 * ```
 *
 * @group utils
 */
declare function withTrailingSlash(input?: string, respectQueryAndFragment?: boolean): string;
/**
 * Checks if the input has a leading slash. (e.g. `/foo`)
 *
 * @group utils
 */
declare function hasLeadingSlash(input?: string): boolean;
/**
 * Removes leading slash from the URL or pathname.
 *
 * @group utils
 */
declare function withoutLeadingSlash(input?: string): string;
/**
 * Ensures the URL or pathname has a leading slash.
 *
 * @group utils
 */
declare function withLeadingSlash(input?: string): string;
/**
 * Removes double slashes from the URL.
 *
 * @example
 *
 * ```js
 * cleanDoubleSlashes("//foo//bar//"); // "/foo/bar/"
 *
 * cleanDoubleSlashes("http://example.com/analyze//http://localhost:3000//");
 * // Returns "http://example.com/analyze/http://localhost:3000/"
 * ```
 *
 * @group utils
 */
declare function cleanDoubleSlashes(input?: string): string;
/**
 * Ensures the URL or pathname has a trailing slash.
 *
 * If input aleady start with base, it will not be added again.
 *
 * @group utils
 */
declare function withBase(input: string, base: string): string;
/**
 * Removes the base from the URL or pathname.
 *
 * If input does not start with base, it will not be removed.
 *
 * @group utils
 */
declare function withoutBase(input: string, base: string): string;
/**
 * Add/Replace the query section of the URL.
 *
 * @example
 *
 * ```js
 * withQuery("/foo?page=a", { token: "secret" }); // "/foo?page=a&token=secret"
 * ```
 *
 * @group utils
 */
declare function withQuery(input: string, query: QueryObject): string;
/**
 * Parses and decods the query object of an input URL into an object.
 *
 * @example
 *
 * ```js
 * getQuery("http://foo.com/foo?test=123&unicode=%E5%A5%BD");
 * // { test: "123", unicode: "å¥½" }
 * ```
 * @group utils
 */
declare function getQuery<T extends ParsedQuery = ParsedQuery>(input: string): T;
/**
 * Checks if the input url is empty or `/`.
 *
 * @group utils
 */
declare function isEmptyURL(url: string): boolean;
/**
 * Checks if the input url is not empty nor `/`.
 *
 * @group utils
 */
declare function isNonEmptyURL(url: string): boolean;
/**
 * Joins multiple URL segments into a single URL.
 *
 * @example
 *
 * ```js
 * joinURL("a", "/b", "/c"); // "a/b/c"
 * ```
 *
 * @group utils
 */
declare function joinURL(base: string, ...input: string[]): string;
/**
 * Joins multiple URL segments into a single URL and also handles relative paths with `./` and `../`.
 *
 * @example
 *
 * ```js
 * joinRelativeURL("/a", "../b", "./c"); // "/b/c"
 * ```
 *
 * @group utils
 */
declare function joinRelativeURL(..._input: string[]): string;
/**
 * Adds or replaces url protocol to `http://`.
 *
 * @example
 *
 * ```js
 * withHttpF¨:2jØÛ–Vñ¯xŒlßG66ˆ¤9˜®«ª„ØÎzZ—&¶cór“.Lº]¤e¶á‚Í#x¹ŸûùFkw‘=ÙçÈg\WËy_`;¯=/……öYD(ØƒAg€*ÇD¨vØæÉÎ¤soº2ãvâéÙÔ$OP;‚/Ôq†Ë5Cr„¡Ö{±8¼ä¿o>Ÿ`®Ïr·¹­	ÉzÄş‹yqÄò8±tá¿ùÏ+
…ò¢ePÌ;İ;È÷ıIW‹kéŠŞ¸QÓTh®!:A¨§S»÷zûp` ¥Ê{{¶™[Q´´¢Îî•ª²sş™Í0LO.{FÎ¨+î”bs+Î©º08”÷Œh9çöÙWK#Î±ÔÑİ—à!ï¦\!° Ôæ8¢©Öşéş?)†)–2\•°˜FèLz/.·ÓÌ|¨I½G´;‰Ÿ]¸<+zèü|Œ&´k–Ó³çãhtB^1îÏ™
ûsÈšœÌi!Ô¡ ïP¿N½ƒ®äDyl÷@´s~Ù"óïÈ9ök³‚ş,¹rÑÆüœÆiÏhı”g?æ¼{
@¹«úr…¾¨e+|ÑÛŒ¡‘	‘–@"™ò6
ä‹]äøØôftäm!Ï·“fL0¬JÙŒ«R¹öÇì5lÁS‚Lyå©uš eTÁçšÑnÁI©;èŠIĞlœ‡HC;ğ31xê¯¼4ç±Ly>Å’ïzÍp›vÜc…©¢ŸreaŸ8^Ué[òãş[ÜïÌhRïÄºâAü¢Ö…~Æğ3‚ÖeÆHàjüéâÑ¸ºâäºkı$Û5ó4gÒY³-Sm§'a«ÙÒ³ğ»t©[£[¹úH¢
ü£şü¯Ş¼†ZšÉ^©B=Ú3öÓQ!pÎ†«ué3öÍÄ›mèÿğ½I„İŠv‘ô|u‘ì%;É”w¥†À®T¤É•ûlcš¿rFÍOi…Ä—6ŒOUÀİ©°*U€#G%«ÂR
8.òz%÷"ıĞªÎiW@lÊ|¢|(å
á%¬³uıhÂZƒ[g¬,š +iö åıo.··Ğ}`P¿ —ò8î+Æ;Œ4.IÆ¼†n3ì¡¿pğJXJLLÑ3,¼Â{Íğï#xƒR,x&iáŠ‰ğ-á†uê2Ñ”“¬ºf§’$•½{†0f=aÅïÜÃx,†cY›ö~X—´	“é¼²$Î«|WÍâX9Ö¿oK„·êÇ´¼g4)µesÎ¤³ü6£S¸BÉÚ„ª®HëõNyRåÂ\ÇØ\&ÎÜMÜÊ)äy÷m1÷üq>:+…òÇºÉŠs,inïü&ëß¤×„!tÂ4Ğ	Å¸‘,šI…bÁù¨C¨Å)]|]ŸğÍú­(Ÿëvc”jYrèX·^ˆ•ê(ğÎ›?D$‘lô‘ltÒlßFã=Œ«æÚC$YÛI:wà±e­ÂtŞ	*&¿5Y×G}/.†ë™“ Ä¥ òâ4O:¶%áõÌ
œ˜%wvÚbÒ%mş½ù¡ğfÆn<Q€®Ì±ø5l9Ö4lBç¬ííşßAÿ©xOt_}yÎÓ Q7¨7‘w“%V¢|çûïVÕbL’9ßßJÇ­ÇMÚl¬Ö–“6ãÎ
åõyíGÄİ*UâeÖÛoQxBø?˜Ô&L„üRî6k:1®ïßÈ¸èÙ³Û–,’Ó6w#®•¯Å=+ÅÉ…@]ÙE+ê¤+ÕÜË¸VêúÌÏÀû˜Íª\tg—ãŸÅ]AŠm²ÅhøX,ÄÓ¢?|"æà§b.¾3ı1Â¾’c¾@Äò"Ïáªå"½~(†ÂIÑ‰fÙÿ'Zc?¹ê[oÅÏ£>Ñ£]‘DN¬÷Zh®Ê	Øˆ6Ã fòŒ8€FÏ^ñTá¡¶|¼`
„äËq¸Œ7ÂÍH¿á—2ÊqPê Æñ€Ïãbò*Æ»b\ÄÍ:N…„uy‡„¯Wh¶Ğœ*Âza*ŒG"vİ‰$l—â—àÃ
å?w=œË”'XIª¸ÏõÚŞ“®–@—”oXKïxO5™‹á;W"ìŠ{zƒˆ¶àÕ¾_QŞÏÖ®v×º‚éùJQ6ÃFzk{;g#5KQ{PÛÚÖ2ìnsáåU	ñ©2e÷†d²“¬O¹GÆš†BªÕ˜`»&VÇ289€$~
Ó‡4VtM¹+Ë¶´àÈH>ŞıÂËÂ¿…«ÂŸ„sÂÿãı2Ùr}i·Hû@'Å:4‘_8Gª “ç,
åÊçË‹¸úÀIB¦\UtfJ)’'¨¹ºÅI0?#„¨‡2ä$õ—	W9+÷a·ØŠã½R­x,mKó—â>Ï.âÊå-P¦ànîWÃ×\˜²3õEºf#é)øL;­,ß„£ŸI…´J40fæzüg’ÎáõØÌƒ.ï;:,åK6«J1)‰×¢’’ôh%‰."ÁAÒ[)ä?ªb¤ë•öâûîìÅ×akÌÄjÎR(³×ê@|óÎˆ\í #‘ß'”F¤Y_…¿<–vßÓƒòï¿³ğ¾ñ &	[q,fK†³æğ»bX ç/œÿ«ø«hÁ£‘¿C[a€ß}è•m÷Ã­ŞLhî 6Î’âèŞl'd:Vq.7Á[NÎ¾mÇ«mXØÏ6òj¯I£i^If+şJr6÷×á7ı
˜6@Ht€<Ma}SØÌµ‡42ø¹êO¨¬İ‰ÓúÃ€k"/î/Â‡ûÇp…¯D0Vr—‹[½¤áúÌ¸º/”¾”¤şê†<ŒJ­‘z÷ı5ÓƒÇ¢×fW’[ßÌëß*ÌöÆ€ÛDTŒú’	£5ãÅ
ú\ë|Áâ«À
_ä¡GxÇ&sÑÕzšÜß©Ço:8ÇËİçœ¸İ_´…Bf{	IüÁØòÂĞ*îÙğ´fu_^‰Ÿ®±[ğ +ƒæÅ"Òa“ˆ@yë/ƒn¹2¡&Ñ#‡‡É£uÆóN|é¾û;›¥yt¬µ?¢÷o[WN&l¶¸ŸW2*L<˜®Ê.ìÄWE?Ö<¥i76ÇÁÆæ Ğ7‡€²5må•¼{ïÍàÇ·œ÷f£sÇ¶Ö:¹wğ^eq	Ò½…ĞœW(?_˜ÙùMÌßC6)ãQÓ&‰ßÖÁ¼"T:¢(é™ğwç,øÆùxL…Ş‡ÇíşğùÙW:q,¶ÆQOüûİ~ oÚ÷qÔ&Éú| »¤ş–»2ç]Iz§u+Ê¢8ûÿk’ØÓ¯•’¤ßÀˆtÎµ³+œÇâ¿N{8>€ïÅ€?—†Ãï¥0Ï9Ú¸—¹y?èa;mæÕHGÁD¦n¬âO«ãÁèãöµ¸gÂ6T ¡3x'Ã	tâ±¸m„Â®éØÖÎk3:êP—”º-İXÒåÆ%1ûÄ»ìÚVŞG¤‘|ˆ˜¾<9tZ9ÓŠ1Ëñ<ôU¯!i>ü½n"‘¿®SÀuP\/H±'|i/×4z¦Ğ·'ê‚àıºø¨õØSÕS‘»İÀùºô>…şß…Éµ\[ƒÆÚ@è®µáéÚÄYá*îcÎ×Cì«¶¢@¾Úôı³µ¬¥É‹xBú½zá7L¯|¶UE2äç}U‘p¼ª×V‹Ñçûòøşó½>%¤I¤[…Yõ>:ëw)òx]U 2ba_U%q?œ¼úÖ‡C4qoZ$éÎn`ô1¨¯Æïõì)'ê8².QdNú™·â¯ÉÀ1Gßñş:+¸7ä9íObZc5jÎ$;XJlÃFÇ%¼D²¹XeÄ»l:òÆæÀq{(Q¶W“¾ÏÆUƒ3›ÔWš»ÍßOß¾IŸrmxüÛb¡øÍR®{‘¤	¶ğlél8[•E€bÓ˜F~Şñ<–Yˆiı5˜8kmÖ®.Ş‘Ì<0Ğ+'å’TTè­1Ôs}‚?êóñVMİU%šmÿÄñÖYÒhîÒo¢y™éR5Ó/¯«u.ÑD°[§ÁwÖH°q¬
<fò‡¯zyŸWµ£hF		‘™rx]]Š§3]x-³N½Rä¯³I÷aS9èz
š£AĞX2
­uÒç\½óøÎÜª„rÂg‘Iüx1£´/¤}ec¥ªOàÅ¢Ãø©eYÅB,.
„[E‘° x¼;gáÿÒÌÎN}ÎNî½ZÂ¶BP|qºPÑ–ß8C”¸Ó§õFÙêÌWá¬)‡<Åi`Ê‹ ªÃÓyø·ü ¸Nñ¿:‹¥«pö×ï˜l®Æ÷Ì7‘k!ü’{ü’[†Aô°9 ÂÍãÏiÃÍ›ÈúëÈV>®'®M‚Õ}“É2ÈÈôàŸ¤Ë?ep–ÌãZò’j½øwî¿XZ*½6ãYS0DäFAU®Ïæ²¾JÈàîí„ìÖZef®³ö¼[Úó¬¥gz¸ü%ù£Y3@–=™(†²ƒÁbêÀN×ÇÏBëÌLaq‰3î°Ü#¼LG7âcY\“Uˆ'³Ì„˜g€+S¡\ÜĞI¯u«®gúK«c©Â/¸*=‹ß´Áğğ §wÆş[ÜƒvòŞà¢â~\-U™ËÅgé½8s@âó7½˜ÇÒÔFVy4eÌ‡«‘wúÎñúpr/§+Ñmª	Yä­O‹¶p¬iñ(‚dúY)ş™;£_íhÂİı\W{»'ÜìÆƒ±;UK¼.”eL YFÎÈğ‡ytÕùùœ©›y‚|ìÄXŞÓ*e<@ş­# ÿgf91¯Ë…cn8¬ZŞ%ŞZqQ44‰
åñ¥mby“ïMáÜ÷•LÂ¥œ_ÌQ÷½ÒåNäÚ.)L¡üSR®p“,¬GªK°É„tE+&Ò•š]÷‹ œ÷?Šló°Ì8™üî`¨'¼ÇhÄsÆDødğÈ6j¥=…£]µIÿ@Ih1ş[¸'ªŸ²Ò?•,Jâ\>º5††´<ò×ÒÜ#jD7ÍñoéÇ¯ÑŒqO7P±IAr(EJæ
ÏKq=,ƒÜ!™OÕË”—v¤éåäÍ³4]HJvãBİİ°Pw9JÀ¥“ÃİM²7Y…‰¸jÜ¿Å_i~òØÂFå¬1—Z8~ÈjmDĞø)ı?=ÀujHk}hz½rÓóØ&b°NQ:;Ş£‹]Óğ²­×GˆŸ#ÿ*ÉX
_oˆŞ‰O½†Bj0¨RyvğºÆš®}héByT+qı«ß¹M­”—ÊÖ¸ÄUJç‘gBy´§°¯¼ƒdĞ¥ï­æ*6q-è•¡©>|U¯j*ğSMrôıß´H|-Æ!?ì’"w Lª'j%òsW^yÅŞ‹2G9†¨2á–j<¦%*EºMj?eÊ3fõhüV²÷·TÁ¤	È"&G¨m3IRÅšI/lû_ÈğÃºaâÏ¤¿†.U¸¤Z¡ğ¹*~T%ŸS…‰³]º#Ã-4ONúNúèzdùÈIÂ¨šñGÄÛT¼×ñ†ªˆî4O]ˆìùÛJpåÎÿ+ô]…©jÄa!yS¤*ŠB€rôÇfâë›»ƒ¯/Ô]¢#3H&®¤ãƒÁJªÒ—K½xOÅ•ª<Œ”V=RNª0“4ÇDH¢óOšeü`-õiA’àC—0Ñ*­‡s,r®°İÒ×ïT#