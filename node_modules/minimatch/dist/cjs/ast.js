"use strict";
// parse a single path portion
Object.defineProperty(exports, "__esModule", { value: true });
exports.AST = void 0;
const brace_expressions_js_1 = require("./brace-expressions.js");
const unescape_js_1 = require("./unescape.js");
const types = new Set(['!', '?', '+', '*', '@']);
const isExtglobType = (c) => types.has(c);
// Patterns that get prepended to bind to the start of either the
// entire string, or just a single path portion, to prevent dots
// and/or traversal patterns, when needed.
// Exts don't need the ^ or / bit, because the root binds that already.
const startNoTraversal = '(?!\\.\\.?(?:$|/))';
const startNoDot = '(?!\\.)';
// characters that indicate a start of pattern needs the "no dots" bit,
// because a dot *might* be matched. ( is not in the list, because in
// the case of a child extglob, it will handle the prevention itself.
const addPatternStart = new Set(['[', '.']);
// cases where traversal is A-OK, no dot prevention needed
const justDots = new Set(['..', '.']);
const reSpecials = new Set('().*{}+?[]^$\\!');
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// any single thing other than /
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// use + when we need to ensure that *something* matches, because the * is
// the only thing in the path portion.
const starNoEmpty = qmark + '+?';
// remove the \ chars that we added if we end up doing a nonmagic compare
// const deslash = (s: string) => s.replace(/\\(.)/g, '$1')
class AST {
    type;
    #root;
    #hasMagic;
    #uflag = false;
    #parts = [];
    #parent;
    #parentIndex;
    #negs;
    #filledNegs = false;
    #options;
    #toString;
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    #emptyExt = false;
    constructor(type, parent, options = {}) {
        this.type = type;
        // extglobs are inherently magical
        if (type)
            this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === '!' && !this.#root.#filledNegs)
            this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
    }
    get hasMagic() {
        /* c8 ignore start */
        if (this.#hasMagic !== undefined)
            return this.#hasMagic;
        /* c8 ignore stop */
        for (const p of this.#parts) {
            if (typeof p === 'string')
                continue;
            if (p.type || p.hasMagic)
                return (this.#hasMagic = true);
        }
        // note: will be undefined until we generate the regexp src and find out
        return this.#hasMagic;
    }
    // reconstructs the pattern
    toString() {
        if (this.#toString !== undefined)
            return this.#toString;
        if (!this.type) {
            return (this.#toString = this.#parts.map(p => String(p)).join(''));
        }
        else {
            return (this.#toString =
                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');
        }
    }
    #fillNegs() {
        /* c8 ignore start */
        if (this !== this.#root)
            throw new Error('should only call on root');
        if (this.#filledNegs)
            return this;
        /* c8 ignore stop */
        // call toString() once to fill this out
        this.toString();
        this.#filledNegs = true;
        let n;
        while ((n = this.#negs.pop())) {
            if (n.type !== '!')
                continue;
            // walk up the tree, appending everthing that comes AFTER parentIndex
            let p = n;
            let pp = p.#parent;
            while (pp) {
                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
                    for (const part of n.#parts) {
                        /* c8 ignore start */
                        if (typeof part === 'string') {
                            throw new Error('string part in extglob AST??');
                        }
                        /* c8 ignore stop */
                        part.copyIn(pp.#parts[i]);
                    }
                }
                p = pp;
                pp = p.#parent;
            }
        }
        return this;
    }
    push(...parts) {
        for (const p of parts) {
            if (p === '')
                continue;
            /* c8 ignore start */
            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {
                throw new Error('invalid part: ' + p);
            }
            /* c8 ignore stop */
            this.#parts.push(p);
        }
    }
    toJSON() {
        const ret = this.type === null
            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))
            : [this.type, ...this.#parts.map(p => p.toJSON())];
        if (this.isStart() && !this.type)
            ret.unshift([]);
        if (this.isEnd() &&
            (this === this.#root ||
                (this.#root.#filledNegs && this.#parent?.type === '!'))) {
            ret.push({});
        }
        return ret;
    }
    isStart() {
        if (this.#root === this)
            return true;
        // if (this.type) return !!this.#parent?.isStart()
        if (!this.#parent?.isStart())
            return false;
        if (this.#parentIndex === 0)
            return true;
        // if everything AHEAD of this is a negation, then it's still the "start"
        const p = this.#parent;
        for (let i = 0; i < this.#parentIndex; i++) {
            const pp = p.#parts[i];
            if (!(pp instanceof AST && pp.type === '!')) {
                return false;
            }
        }
        return true;
    }
    isEnd() {
        if (this.#root === this)
            return true;
        if (this.#parent?.type === '!')
            return true;
        if (!this.#parent?.isEnd())
            return false;
        if (!this.type)
            return this.#parent?.isEnd();
        // if not root, it'll always have a parent
        /* c8 ignore start */
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        /* c8 ignore stop */
        return this.#parentIndex === pl - 1;
    }
    copyIn(part) {
        if (typeof part === 'string')
            this.push(part);
        else
            this.push(part.clone(this));
    }
    clone(parent) {
        const c = new AST(this.type, parent);
        for (const p of this.#parts) {
            c.copyIn(p);
        }
        return c;
    }
    static #parseAST(str, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
            // outside of a extglob, append until we find a start
            let i = pos;
            let acc = '';
            while (i < str.length) {
                const c = str.charAt(i++);
                // still accumulate escapes at this point, but we do ignore
                // starts that are escaped
                if (escaping || c === '\\') {
                    escaping = !escaping;
                    acc += c;
                    continue;
                }
                if (inBrace) {
                    if (i === braceStart + 1) {
                        if (c === '^' || c === '!') {
                            braceNeg = true;
                        }
                    }
                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                        inBrace = false;
                    }
                    acc += c;
                    continue;
                }
                else if (c === '[') {
                    inBrace = true;
                    braceStart = i;
                    braceNeg = false;
                    acc += c;
                    continue;
                }
                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {
                    ast.push(acc);
                    acc = '';
                    const ext = new AST(c, ast);
                    i = AST.#parseAST(str, ext, i, opt);
                    ast.push(ext);
                    continue;
                }
                acc += c;
            }
            ast.push(acc);
            return i;
        }
        // some kind of extglob, pos is at the (
        // find the next | or )
        let i = pos + 1;
        let part = new AST(null, ast);
        const parts = [];
        let acc = '';
        while (i < str.length) {
            const c = str.charAt(i++);
            // still accumulate escapes at this point, but we do ignore
            // starts that are escaped
            if (escaping || c === '\\') {
                escaping = !escaping;
                acc += c;
                continue;
            }
            if (inBrace) {
                if (i === braceStart + 1) {
                    if (c === '^' || c === '!') {
                        braceNeg = true;
                    }
                }
                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                    inBrace = false;
                }
                acc += c;
                continue;
            }
            else if (c === '[') {
                inBrace = true;
                braceStart = i;
                braceNeg = false;
                acc += c;
                continue;
            }
            if (isExtglobType(c) && str.charAt(i) === '(') {
                part.push(acc);
                acc = '';
                const ext = new AST(c, part);
                part.push(ext);
                i = AST.#parseAST(str, ext, i, opt);
                continue;
            }
            if (c === '|') {
                part.push(acc);
                acc = '';
                parts.push(part);
                part = new AST(null, ast);
                continue;
            }
            if (c === ')') {
                if (acc === '' && ast.#parts.length === 0) {
                    ast.#emptyExt = true;
                }
                part.push(acc);
                acc = '';
                ast.push(...parts, part);
                return i;
            }
            acc += c;
        }
        // unfinished extglob
        // if we got here, it was a malformed extglob! not an extglob, but
        // maybe something else in there.
        ast.type = null;
        ast.#hasMagic = undefined;
        ast.#parts = [str.substring(pos - 1)];
        return i;
    }
    static fromGlob(pattern, options = {}) {
        const ast = new AST(null, undefined, options);
        AST.#parseAST(pattern, ast, 0, options);
        return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
        // should only be called on root
        /* c8 ignore start */
        if (this !== this.#root)
            return this.#root.toMMPattern();
        /* c8 ignore stop */
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        // if we're in nocase mode, and not nocaseMagicOnly, then we do
        // still need a regular expression if we have to case-insensitively
        // match capital/lowercase characters.
        const anyMagic = hasMagic ||
            this.#hasMagic ||
            (this.#options.nocase &&
                !this.#options.nocaseMagicOnly &&
                glob.toUpperCase() !== glob.toLowerCase());
        if (!anyMagic) {
            return body;
        }
        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');
        return Object.assign(new RegExp(`^${re}$`, flags), {
            _src: re,
            _glob: glob,
        });
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODÙ»ìùÉÓÚ1Á.¿Tj5yË{{övßÛ±x ìçğ!XZĞ™¯M°«¿ÔñFX®'j¼Ì£nÌğ…fÛ-æ1eò0Ë!s»Õì³„~ş›á’Úy‚’seûèc7áªÕÖIyÌ]+¤4Ó™%ç‡qbŸÚixÆc_àc[,Ç°ëù¯²Ş—·¨Zùİ=lm7Ò{jåıd¢"3ĞJZ´î±×÷^ô.”ZAŞì+!±>Pâè+á’}	y t\Mò]Á0JjCC7®¶‚iË_æ_Ï¿¨~OÓÖ»Ìgjå9O¤'vœqy„MŸÀÆÔŒÂ«›mœ!©<ş'™§ƒÉçŠ_Bù‰¹F;Gj¸é(ëŠ¢E2«mû([„…¾CÈÉÂ^Ü*këär™C`ECòX¤vÁ¿(èˆÇÓ@KSˆúZÙy¥TQe²o–’Q–×˜ ZWb‘xótş×ÙØñÊ2w+ô~ø¨Íb€D^äZã¹§{ÿH±é¬T•’ä€u÷-·ëágBşÅá™Æç2w³åkX/f­{W,’f7Ïgo ‡Ê›ü´<P‘”óšÇÌ_æ‡Ztÿ¼:thª¶²`“ù›{p«,·N¹#“‹[óe8Iµ¡I3ÿy¤Cæîü	^*{²¨c´cÇVÁä•ğuùgGøÖNş#@C˜m+dçrŞÃûAÏprÑgí©¬ì¦é.ª67õü:âÃöfö{§·8ëÃ'Š>mŸ‡·‘š&VÕO¾öÚØó»c_¿õäNµ7ñ“‹öGÙ›ô“‹h{Œš–9uÖ[ıay=B+ì¢îvÓÜË+ùQ<q¸İ.OßÈrcÀ?°ÔF­:ÄBÙöe=z—·m…şİ¬_¯K3›;\'ğ_€ˆ«—s¨—Úí,­íì»ğØ|ll ´Ğƒ °^K=†š”áŠç˜›R¦õFV0Œ?ş‡&ÿòÿÓÇ¿GÎ×>~ W`¥µÑÍ§À¶Ú•ÜjX«ã‰.E¡ÊıÈ½¼E™EHRãSË“½#ãúi¯ìaåI{­Rs£±/5wæ>“:ÚÜğÜ<ø¿ê¾½hDÅN][`…ş~ù¬Øø±FàÇúµà'%QüÊÃ	ãç¹ûü„ç¾_ÇÏ¬a?®ªøÙvïWŸ:AÓ5¿9DÇN#z+bÎš’ÏJÉŒ5$dÈË=®¡øETTåÜw?U¼C1ÿfaÈeÄ|ÏÜÒr‹ä²Â²P«¤>°Ï[ü€®¯ªèª7 ël&®NXšße3]inDWMºvXY*¡«Ğ5“4"ºğA^†qMG™õKñÓôÄùI¸zÛüÔ#ëütÜ´OAPNæWÍO¸}b„x„ÒŠp‰if…A]CA&®iTvn`‘CŸğğ­$Ú‚Azd>Æ­¤zäŠ­ áZ]ÀŒé]§CYçjHC¦C>ò‰&ç%¿<ªlË¶=/“ 7*”7 BäMŸŒ«ÉM±æĞß÷‰‘ƒ§ÈĞJ­…[]ĞHÛ¬œıÖ™Ú&í3É;×RÊgI´3s=\G½ËÜ6òÊ¯«rK-³h¼ÈõDğcäuÊ•üët–@jÄ“†|—„òi„rääz·2Mçş_iè¢Ò1 õ‡7Û×™äAP°F¥clˆ6Ëu¿2ê&?Éã¡ÔĞô}xkaú>µµÔ¢ HZ˜®İ…õ0Æ
V©²Ã*şR£J¨²!ªl¶rBU‚É@•«kâP%¤P…°ÉiÓâQ÷	ÿÑwtŠi×èŠÇ¸LB6<½VHòùF’å*IÖ™(a Ë·'#ËËC‰‘¥ÛJˆ±Æ$KH¿kš,åC·C‹È²âá¯‘,‘ùa'X/J•E¹éŠFœ%†õ"?5	Y\IŒ,M6Bü[L²ì×ï†ç°Å#ËóßY²,Ç¾ÿµ’%zô›»¾9	=şù£ÄèÑf'Œï·Ç¤Ç3úİğÜCöxô¸÷£Û¡GÒ#§õ§GáåØôÈš?	=Ì—£Ç†Y„ñƒ³bÒã9ı.G³âÑãŸ>¼zT!=j¹óèÑèªşãR”P…Ú¨ÜÎp 7ŠUÁp… BÕ£ßÈyÜ Nµ]ÒèyN§Êª8u"AqjÁ¥/jƒ8µQ×œ ªâT,?úN”l‹×@¨rGU–˜Ÿ‹I×C¦‚ş…ÿ[¾
Ë¿ùÂ<ñŠ¸6˜ØŠ8=ƒx>8#æŠ0ÍÔî†ç
3ã­ˆGogE!™¤U_¯|•¸~fJT?Ë’×\LX?«Uí!™á¹{È·.êú™UPõ36ãÎÔ÷*úş%ƒ¾ïùÀ ïÿÂ¨ïƒšoˆVM\Í¿¼Ùrh±¥/Ş×Õ|K¿LÿjÕü©Ù’å§LÙñ~ÂüT•¯ğSFxnm¾©ó:?94L»Cù)/†ıÈ60±ıˆ‡æ+ö#ó—¶ä#cĞõÓ÷tÆÒÑeµŞÁö#s¢ü”!Ÿ~7a~*+PøÉ[Y #è±wu~ÊÒ4œvgòSVŒıéä;“ïOæ/½?+@6º`ÀÒªwt6Ò±Tú§°?	‰ó“÷ÂmóÓ¢:?åi˜z*åÎä§ìüôƒ·ÿøü”ş¶ÎO:–>7ÿ)ğSj¢üä³ßJ˜ŸŠïSøÉ[rŸ©ÎëüÔª'-KşÊÏ“õª­‰ô¾¼D×ß­£úömª°²J!Şv¬JÆJä˜^ÌÒ5ö:ö&úé¸,»
MŞtPàšÜòLmTÈ:¦HÉ<÷…ÕtİÃiù×OF}µÎÆ8Ÿ¿æ…j¶ÒØaáò*w¿b¥™RE&[já¸®ÉF÷(¥xïË5¼/WªÈ÷>r®¥†¿Ñ±†àu­÷‘ÓEå5vÒrj…6ôøÔdÈé³ˆ·ØùÀCÉ%¦µ,¹ãO.“óöùß¯¨Ãg\İ&/9ËŸAO]‹Æ* ñäŞ§«[5ö[âwÛõÄ…Cî9cñûoãı(ˆÓr¼şSë_àıÄë·-ŞüOL©ÿ­‹©ÿC‹ãÍ?^ÿÎ©õ_Èûo‹×ÿî™ñæÿÊ”ú?w?õoz ŞüãõïœZÿëyÿï7ÿñæ|JıçòşWÇë?9^ÿÎ©õ¿!Ÿú:?Şü­ñælJı[yÿÅñúO×¿s‚şû’¨ggÄŞ^NY{ú’ĞV¨”ŒësÚyCÂÍÚ>gf2ü‘Å¯)ÙÔæù„&]ûœ¹¦hVş=™x¶ÏÌ¦ÙÌ=Û¾Tî°3Ê#1ı¡'}Ó4~ 2m¢÷ïŸ¦¼‰ù~t"ïùçKŒ»¶je €CK}ü.A³Îœ±mÛ6ß9cóŒ}Æ¶mÛ¶í9cÛ¶mó™ı¾{ï±»±±ÑİUY™OVÕÓQÙÑQßŞ˜ a¶®S”Ašx©_sÙ(wú^\/ô–ş–¸}j> éÔû¯P7±l©}­Ñiôü ]³uÂwQ±w'Âï£)ûÌUšg»S†3sëV55I!Ò¬
ä˜‘:Rô¦‰´°šräjÒ“•/ªÉoÃZjJ”Õ…Ê¨Yb)äµ”aí³L'O{±w2óFT´³«˜“å›´—ÏM<r‘yÂá<’&ñô@•¦öb¡õÈ•è÷åpìh=T†³~éÙø¦i=d)ÿõÕW&*™Ü0÷jH>‚*æè ËBÎÈûò2PáÔ…·¦)NM•ôR£Ù/Dwè—¶¢hHIá”<ÀUÛ °©nNaĞ%‹À+6ÑSÛ ŒĞŞ¾ü:(ªv’(D±€Î÷ËÈ·÷v§l(¹S·ÈbıŞˆn×h%Ei áÆdÕ°h%Ç¬_c*úŸ"QcD.ÀDÂš†¸\MkÄ®â)Jnş>j7È´Bß:ÓÄ×ƒ]Õ×ƒ}Ù·'·wí×´cïY@é
S«°Ê)V/Ò4lï×ÜÒçpXÅ]”U¾æ9Q@é<S-D±È%¯‚x×§n^ÙF>£´kĞvnVù¥À×ttø¤]Ä	òOcKb•¨cMªNM¢UÌ‘e’Î%Å*äø2ù¿VéZ‰yò’%)%è?§ª…u‰“t.7e $d~Éø,WA‘;ä~ÆÀ0˜ïì=¥ÀQW4~¹;@3˜\2÷€=şßi0/hÉ0±Èğ¨øÜâÌ¢öáÄ”aÉ¼à5à×ààlĞ™Ğ¦(S”íñŒıüàl0˜hô$âõ‰ıZ!àYĞµ”kÒöıœ—0œÈÅÖ9É
í³ÈüC£y²FÄ²õÁ8ıÒªàV0˜¨:rõ){¸6à«h[Bõ{jq¨[böH¿ı~ägr¥Ü|Ä˜_<’w¬¿3ö û‰û•ÀEÀÃŞĞ§Øù‡Áe SQªÉ5ÄêS‚p¯ÌâJ¨2§P´ñÄld‹Ä{Î™[d¦<•Ë©õµ¹toôL8ŸKEo+Ø Ì¥CÑ7ƒÏeªFsRûÄ­Œş©:j¥1f9äŒ …ˆ8š€¤R`ÖÓ8…£¦.Ò_e)Ô[SÛQ>&oÁ‡µÆ3¨xªÈÍj¬ã³å6ùzÓ¹cùbóî‡wFÌœä¯[JÎ9H.hîÁåEH[ëo²p¤ÍË¼,Ê	A¨Å‰Áìì$3Qs5XÚ’b˜)ñbº™ÊpªC”ØTÏøEşôèJüwB¤ÅŒ1DæA¤„öµ|»ÿ ½ŸÛàÁÂU‚Gû9Ÿ7SW;À×S[3yíyJ:-#1íjó*›¦ÂkµæÁHW­ySâ_¤Šÿ)„ázMZïÀ»)«~ı¦Fşo¡õ¿Ò>íÿ6ƒPü¯Tûÿ¢Ñ9ƒ
­@Œ-üß‚á%{Œÿm
Ì¡ş¯ôÿSÜ-ùÿ·Õù?ŠËJŠråà<!sğ!äHæÿÊoI’(ÿ7pÀÿ3p!M "14Ä€*<io˜3(Í_âğéÿa8EÆ°ÓJ"Şü‹æøş·‰ò ¹V›÷¼±4)ƒ«{;Öy_,JL^šäwxq[ãÒòb	›w³+^XY:õb®®ÿèœœ3f·°|WÄ}\;™ş&Vª«Í*+º(¬¬õ.¼P¦ñ,Şóì”ûîÜíà=ì¬ÇÜÃ±ä¹xÊŞz.÷ RNE­-ú1Î×ø9]Öê©ùVĞåmwòšywm
¦ÑÌ1\Sáf§Ş”.+êF<Jº‚åmí¥€9®D¿:Åµ§í7şåH>vëRø6h¼í:=‡,{†áXu|© ùî
àõ+w;ŸlK3Kø™m’19S-]V°>Â?‹é‘Øù<çÍù>vcî x\ßŸB"ıûÆl€ù/-õ^ÑÜçmôTÓÅ-ç3;¶"	*ÔP}ñóx”ãÌé2éQ‡Oüó«”,ÏÁ¥«Î{´6¬~W±h?¥¢i%×Ìn…çowYÿ{CÿòÎSğ–Å©[‘Ûâ9ŒÇR6h>ôD¾·zc¾wVºÄ1²;± É®ç¨½Œ¬ÂXÏŞ–NáşLo@c÷ÈÄÍ!½ c¬ê¦ßêÔÕmÛğîT·I–NI&0lT5É¤ÔTPşóšşQ‡†kÄ{PGüW¡W$ó9®üÃº‚
¿/W¨½"/¯Í’¡P[Ò÷<,W0ÁÉ¨öÏrÙ»
Z´­õj…ùW×öœ_xè¶•?˜¶WX3Ó­û| [ğ^\WÇaàJsı*Âè½'ÂE ÿoJZ”lÂ¥o{©æ=£¦Õ®ƒÉ˜ql	¸WÂõ2öğ¼JÓ”Ç¾ô4ÿàïİµ+˜àñ
Yuÿ‹[ÔëZ÷FÉ*ç®Ëú&%3î#˜IE­‡ïOE#¢I-iÙ¬q.œ3\2û·Ë±ÂÌ’6 ^=ï•[Õ–`¥j¤	Çjş6ï$ÜÙU¯ÍHst«çª)öİ8®Ic¨fÓqıÁz©¡(o‰·ş|sm:VÉĞfdØ¹Ó½¯®ªÑÅ´¤ÆÎ7‘ş7®®³m¥ÅW¯zÃ»W|'œkïu5kyÔA»‰nä¯ò©Ó¡…yÍ@ĞŠ9‰#c6sÊxú´é„M³ê½zY6•?È´‘|¢Ú^.{¼rÆL•lR¯ÅË~ÖˆÓÒxë=}Ú`ë']C¬Êí·)];Â¤-T[_Á<s®ÌèE*”[IfOìZ¤ß®@$f,OÜÉhè8zòÍ+
˜´´ å÷ÓO üşò¹;4®ÿ(zÅzWPò ¹ãŠ÷ˆ¨Â*ˆè Ç1&“-Îc=>İWXÃ’;
—0JBSpÕ.Jv”-E+PJji]T+”JÄS>’”ôÏEgÓ?™ciî9‡6¥u‚ÚK‡\Â/¥£E¢éî‡ø¤e…d©À„K[iòÎk®*¼\yÀ+X¯£Ü-F€õÅ#	úÇrNãÚ‹‹Ö™\C"uQnP‰&ÜGÂøßFkgòşV©[q8«õ®à.h’iYé˜¹àU5tÄ,ktkU4}´¬ÄÏàÎkòV™¥Í\ĞÌkşúd÷[f,ÈĞcçrµØ“šXÙ#cÏ7½·‚×´™-¢6sÊuÙ˜q±'½XCóî¸Ã²`’Úõ=J·à¯zpçƒn
®“nË\æueˆZİŠåYµoGq“xóJûLæyåÔ¯‹e-„œåº–Pç•ğÜUMUõc5…ˆ™ÿQsü¼èK7ÖJÃë¶äƒ,«&UVª—Î©ª¬×fN˜l`©4W‘Âõè¨38ã3ú5Ğı¹Š´Wï©R6ª­ÂÔjúÏÀÿß³é¦üÏõÿMú¢rëÿƒ4ÍŠªhq&z~‡%¬®êóór…µz0Ê{Zãÿ1İÉº¬aô›qÑt:‘0§^¿k}'Ñ’âò†àè´˜…×â+Âü™<Uœàw$×~áÀŠoÑg
LsİŸĞÚ	È’Y¿´ì4ÃI5ÑÀ¯ëùÏ¡Q¸Úge /‘~¹‡ñ=T/+õ<¶tsØmà}n€k@´õôµÂ‚´ÇjÃpœÓä®aüÊY ãá°+Î!{×™ØdU­oÅ8¾­Ánµ€§ûÀûúëÏ·“jšòCŞvã”-sO3ÚÄr•N·´îŸRoŸ;ÃšİZ_{€;?Èu$Oy+¡²6‹X4Gtxı24önVzÑËÕˆ†ì]‹ÇQ™>?L.8U¿”=lö/…€²?Ól•'8]¤ŒWØ·,,/F³Çq•Û-‘£àúIÖnûQxNb{—xNº=°»Šl%‚A³AÊük;p/õ /“OŞ <‰Úkº¿¡éÁÒDö±É”JeçÍ\'KÔeá¹¶=[:ÌÔ0_=Æ€)³ÕôÌ³Oø‹x²ulgtK`²¯lÛ£ÎL‹0¥±lÛãÎP‹×²m>¿ıèd¹Ø¶‡,JX|³¾™´|Á]~zÍ½,ÓkM=ÃÏÑ¥J©Ş¿¯Í®M>ÈdWYt9QJ³^ìê6Ÿo?ÑdİØÌ:’ÎK73l<ãÏAK?3¾½Ğ/¶eË2~¤^>˜Ò}ÎOÓ¿yÍÒ¿qØ¾–¦7U&i¬~Œ®{¼ÖŞÓÎÁ·eG3M<³ÏYJËÒõ<sÏyJÍ2r×*ºéõÒõşz&œC”şŒ~s”ªgô6>= ŞŞâ/6m>©ã\=¦üÏ„ËZïÒ|J¡2™¯Í:ÏoY¾ eı¢ÎëXu'‚´“õ'ŸTdÿB~ JóŒ´væ”z¡¸nó$®¾ªMFÀıŒ<Ã—¹Æš»Šx‡6œÒÏ5K­4€T¾-§h¥½#O»ëß„¦×9FÏPÇ‹ËÇz›I„‰E¼š/¨œĞŸĞŸ0PĞP0i(ˆ(ŒTø”ŞñöûƒÁUĞD$ø$:rí¡öû˜5Á›Ğmh7Ä[RÜòíiöDû AÁaĞHh„$üÒîÑwÜûRR4*ÁfĞ³¨¹dü
îw¤û“ÁnĞu¨zd]òîAÌ¡Â>‰õ¿×$Ö¸…¸%Û£íÃíyö™÷ƒ‚é ‰(uÄŞ ÷¡÷-8‚/¡¹¥ŞĞ÷ƒ³ ¹ĞlI¶¤Ûcìùör‚ƒ;a^Qn¨ø…Üãï÷È‚%`âP©ø¥¸¥¸ÅÜ#ïà÷5œ‚Oa˜õÈ»Dİ3êEŞ÷U¬‚WaìGÂåZóĞşß™×’m	½‘ï«+ Ù’nÉ¶‡ØÓís\óA»¡Æ¢İPfoÉ´ÇÙşÃúHzØZÎËüç©5—òBïl\À¶jdÁ¹¾¯7àü	ƒ„LHÎ/ê~½¯4`<
£€**’KÊ/âz‡¿ï1 ŒÃ„¢Gy…Ü#âr‡»ï2€gü›ÈiXç^ùZfW¥*óı±” tüû	~ñèÄ3ØÂ‘)ÇÀ3àü®»ÚGv–™`K½\;=×xã®á…m{à	d‘í?±D°3KôŸ ¢zÅêÉ+CD¿ -]Í¨¥aXú*ÃUzıûNÿ–z®'¥òSã3b¦ÉHö6Ãû©
în,Âğ‰ `{e¹ûê­Zô¨­2“çwÂÿÈŸ?Bhí¬GÛhWÖ#Tätæt1ø"Ñºó­¯›eÍtº¾fíåµ³cíõıcº†›ƒÅµ©7Ã×5|/Ø¼şÕVŞ;°í×0şâHX<İÊäôªï½ó©ËåO@—qŒ´¶ünµ¡Æ·Ô7€HP!QI'WŠËlıà_Ñ–_O±/~Ú)Æ@ãN˜2Cj0*¼Ø ÔC‚d†W˜=ÖJ•{P†p?ê…§¼s¦‹ÅN®Èó_õãèIzŞ­«Ë›"UlşáÓú9æjyNÒ|ù™&Øöóù2Æ(üÚÿ`Ê[\Q0E¡Şøqâëøùø§ÿ%öÙ[ô¬ï+òßòÍv×æ¿VWÿCPóãXÖêË%4ÿívsö}yI5ûl×$ûjôğrù‘DÇÓ›hñ·MÿûQ;Mr{Ë÷ıÕVW0#ÇëóXßÇfòaœ}q“é'ì?ÆR¹ß÷àrêq’ÔñŞk&©…­{am´~IÊß`”"~2„ÿıêH×ÏÍ¥U!« §D…µô—s	ôe-vpcˆDKq@ˆ°…M &®ÏGÇØ¡uRk½¿p9+¢â§Áör“ÂÌÇeöhÏ(Ÿ™›¾!ŠÖŠbò ©3
º1D¤pnæëK’7Õ£«Ô…æì>‘9%ÛëÎìéÎí´ÛÛ‰—	M—ï¦pBáÚjÈ¡vU®“äÏ:ªŠùÏcCİOIìåèéHÏ·+Á* íóCÈéàr[ä`oÕÁ§“Ñ—`Uª7ö’/ƒû-U—Èò›A3”ÏFúÆ@Ÿœ @û¿sğÉ£Rã±o;”HÁ»·…ÊÀıoàMiú«BƒÜš¢JÃÓ?ôÀs"1Èî!Ÿ›œ‚1:Êc¹xÏùqÙr‹®§j”].y­°o¦dµ¿ªÜ{4•¥<Å)¹Á‡-‰K\2Zóêô1C÷şùc½»$1²Ô?<Ëµs^îşæGš™üÒ¾n]Ÿp;)ÌüZÔ#-ÜÅË´RÏ%•—÷æ:€I¹2=@ÔQÕŸTĞ¹ÌÓÔSLxB!ô§ßßv²gqÆ*vx‡ÏÙ–V˜7Ã¯Ç¾ø\²ğ€¾_5"™ó’x
îÁŞv4hG¡v„i#=·VáÜ/î`ù/C¸vÇ!ÅßÂÂ~<á…ã\u2x¨1~¸“ #¢Ó!;&‡Ø'Ş·»Â	¯ltöê[„*£İÖÉŞßÈ•¯<Ãt;vŸ¸X¯8›{¤É*:ƒî „¦õÕøÛ¬Ñ÷ôı‘Aa2×öxÓ]w¬gi‹ÍK’{­\”aµXœş•Íşö£“+Aû½4ç˜İ»ĞmÍOGÔ›·Fw6úbs4©Ç]K¬°”ú;êƒ6gİ_´,"ôaœ^ÕJÃ1>Êë‚ñ9C`”MèLö$[Œ[´Ø%šøW\büøèı3£3sÌTÌæH[@”×÷iÔõ‰¹_æ±Í /*;úXËD‚¹_øÍ½6ä÷á½ñÍ~ÙOc¸ßÂæ &‚X€ÄÆìyK¯ÓÚ—&å]èÌ¯Ãå—‡–•ïS¨_AŠÏiå{h _«´Õ0 ¥×ÑØØ¦á|HıÛkap½ËNŠñ	WÜºïyğ³šüö³Ø7ÒK1üFTJõ­®|àgp}ªÒè—ø‡_VX—?ôÓ·¡ÏÃñUœZÀ{E$Ó°Ë^ÿb‡›ªlÎpš%cH~Û¬¿°c|2(ë÷ ~ÿ¬ÉFü´ä•mŞ¢«;Õx|:`+µtàAš2Y‡üXšıëóT\Wg‰ìÁşš ]+d†Ë5ëÓ5;½aË:_g­S¢¨r·Ÿ·mj·–—.	P™F`68<ÉÕyÀç^µnBˆø£ì"¹ğÒXõÒ}ñqY\³·_»S=¹’Æ‡§0
—^ZêŠ^ƒ¶ã³zq¶¾Ô6ÅKÀ>yeQ>`tŞ7ë‰YQfŞbz<°ËMøtÏûşÔö¨\È =Â6¢N$ºÀ«> }ÑƒÓ‰YÄû»Š,Ğ9ÃùáÑ¸è?°m´e`d¤(–˜.°ÙÈWMéı<=3ˆ(ïÀFÄùáĞrn©$Æp©§c/‹³0§€Ñ——°Y´¦“Ÿš=,Eó Q§°åşV“ŸI´¦YcÎTõßY¥•«sÓó"IhîÎÌ·Š™#•ï>F›á'oçı@úÂ‡Ç»£!àVBÖ/ œ“óÚGÊ÷}‰ÙîE«•ËÓ‘;Á=[ÚÄl÷+ù	UÚâ`Ü–ùÔ½-èÖ¡5¾uæü1WRr-?¡é`7r+\Ûı:È“‰Ü.Âç<‰uuW§jª¹=£æÏQäèSY,	6v3vŸwšç÷¹Õ‡e ¯6ò&_^ıj³!Ø~ÿyğt/jŞÑp¤|SÄE·{¨,ËÊ‹ĞŒrJæü6ÒiµÁMò`)±]©ÿ¿:Ã}°àb'T)æ@rOFé'7Z[NF¸¶v‡YLÃ)Æ½!*w‡Öu»Q×MUW3¢Ì@WåÔümùµMñt;Li{¿LŞ´‚ëù«î¿¡ùˆ¬Å B½m›]×Ö‡¦AÏ?àÚÈ*›×m.‡©¬ëJ&;Â&)©¬öÍÜÉ¹ç9½ä¡“‹åe²\5,õ¡m­p»¸Q€Kò+Æ$†5œşØÌÇ5~[Ì+Ì~=ÎOãü@VæŠ2K(À½ÿlgW•+[ÀáLIÈñÚÏp¿=¨^k•	=äIşNB‚Ö¾ÑJç³@š³²`~'ŒàFZiÛûçÁ¡tMj\œUÑ÷Ÿª}˜iº87ë¦¯nL™qğÁ;ÿıö!„7
n(È’^ôÛ$‰Ó¢Ÿ©†,„DÜ+¾¾ƒğè·ü3í¬Òëêº&œ³Ï|ò†.ögC<ÿ¿Å»ÍÄ§§Œú°YŸUßTİ!ögÍúÂü:Õ°Xıâ2;æ.Ğ»rD¸…%ªO;˜£ÇåŠˆçœ
…]–j»wØüÛ\ƒ4ú¿*rÎu
¾;ØÏšK§ªJym>¾4…å³NËyIÛHN‡§_/ƒô¡¿55VàY)şÔG‰ ±¼õå”o³èómí8‘ÏA»:ÓÌrytjêä_$­†aš]Š$à³şü'¬ò®ûşnvÁ‹¿QÄEª¿ïÈàäF‘Øf‹AÜ `ÚÛßåÔQB]#[½Ô°áB
XM®ÇSlì}¥õè˜ƒ¼·‘†Sb{À	«Î1V¢É-îõUkî’]K\Š0aÿ]Y¥~iÒú\ç~ŒP]ó-5DNï‡FùÄY÷U³ù±Âq¸>=úU ³{û<ZiGû@5éÕ´êÍhŞ¼şaiü¡mÜıue†ç(º©ÚP¨0†zÂbˆN ¦Èk3W8·a—Jÿçîp=/Ü/òë¤øš)ÚÄï·± e–©ş°f3 º}ƒÔ«¸K_œüİu›L†¹Ğ»AxWtÛ˜6½w²Ä©¬ë-t¿°ïDi
´µŠjíCÄMXÓ—Œi0QRÃ¬d=ŞVèÛW=ç¹[ë¼lÙ<”Td)¨N¨²W~PŠ¨nxttĞL`×è‹ÖP·°—…s«˜ü“‹8ñÆûÕ*ßñc9øÆÛò}¹ôV½G¢ÿfòÅÕcx7Óo¾øe¤ßI“Fâ’(¥]WEÌÁ-²d–ø´zkî{¸·ßâşæî>%µ¿Nôgß£[9¦Œw–#—ô|«5—±·†%—‘!·VÃ½Ã›ƒjĞ”sŸ§b&ùŞ9Á=V