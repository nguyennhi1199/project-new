/*
  @license
	Rollup.js v4.18.0
	Wed, 22 May 2024 05:03:09 GMT - commit bb6f069ea3623b0297ef3895f2dcb98a2ca5ef58

	https://github.com/rollup/rollup

	Released under the MIT License.
*/
'use strict';

const promises = require('node:fs/promises');
const path = require('node:path');
const process$1 = require('node:process');
const node_url = require('node:url');
const rollup = require('./rollup.js');
const parseAst_js = require('./parseAst.js');
const getLogFilter_js = require('../getLogFilter.js');

function batchWarnings(command) {
    const silent = !!command.silent;
    const logFilter = generateLogFilter(command);
    let count = 0;
    const deferredWarnings = new Map();
    let warningOccurred = false;
    const add = (warning) => {
        count += 1;
        warningOccurred = true;
        if (silent)
            return;
        if (warning.code in deferredHandlers) {
            rollup.getOrCreate(deferredWarnings, warning.code, rollup.getNewArray).push(warning);
        }
        else if (warning.code in immediateHandlers) {
            immediateHandlers[warning.code](warning);
        }
        else {
            title(warning.message);
            defaultBody(warning);
        }
    };
    return {
        add,
        get count() {
            return count;
        },
        flush() {
            if (count === 0 || silent)
                return;
            const codes = [...deferredWarnings.keys()].sort((a, b) => deferredWarnings.get(b).length - deferredWarnings.get(a).length);
            for (const code of codes) {
                deferredHandlers[code](deferredWarnings.get(code));
            }
            deferredWarnings.clear();
            count = 0;
        },
        log(level, log) {
            if (!logFilter(log))
                return;
            switch (level) {
                case parseAst_js.LOGLEVEL_WARN: {
                    return add(log);
                }
                case parseAst_js.LOGLEVEL_DEBUG: {
                    if (!silent) {
                        rollup.stderr(rollup.bold(rollup.blue(log.message)));
                        defaultBody(log);
                    }
                    return;
                }
                default: {
                    if (!silent) {
                        rollup.stderr(rollup.bold(rollup.cyan(log.message)));
                        defaultBody(log);
                    }
                }
            }
        },
        get warningOccurred() {
            return warningOccurred;
        }
    };
}
const immediateHandlers = {
    MISSING_NODE_BUILTINS(warning) {
        title(`Missing shims for Node.js built-ins`);
        rollup.stderr(`Creating a browser bundle that depends on ${parseAst_js.printQuotedStringList(warning.ids)}. You might need to include https://github.com/FredKSchott/rollup-plugin-polyfill-node`);
    },
    UNKNOWN_OPTION(warning) {
        title(`You have passed an unrecognized option`);
        rollup.stderr(warning.message);
    }
};
const deferredHandlers = {
    CIRCULAR_DEPENDENCY(warnings) {
        title(`Circular dependenc${warnings.length > 1 ? 'ies' : 'y'}`);
        const displayed = warnings.length > 5 ? warnings.slice(0, 3) : warnings;
        for (const warning of displayed) {
            rollup.stderr(warning.ids.map(parseAst_js.relativeId).join(' -> '));
        }
        if (warnings.length > displayed.length) {
            rollup.stderr(`...and ${warnings.length - displayed.length} more`);
        }
    },
    EMPTY_BUNDLE(warnings) {
        title(`Generated${warnings.length === 1 ? ' an' : ''} empty ${warnings.length > 1 ? 'chunks' : 'chunk'}`);
        rollup.stderr(parseAst_js.printQuotedStringList(warnings.map(warning => warning.names[0])));
    },
    EVAL(warnings) {
        title('Use of eval is strongly discouraged');
        info(parseAst_js.getRollupUrl(parseAst_js.URL_AVOIDING_EVAL));
        showTruncatedWarnings(warnings);
    },
    MISSING_EXPORT(warnings) {
        title('Missing exports');
        info(parseAst_js.getRollupUrl(parseAst_js.URL_NAME_IS_NOT_EXPORTED));
        for (const warning of warnings) {
            rollup.stderr(rollup.bold(parseAst_js.relativeId(warning.id)));
            rollup.stderr(`${warning.binding} is not exported by ${parseAst_js.relativeId(warning.exporter)}`);
            rollup.stderr(rollup.gray(warning.frame));
        }
    },
    MISSING_GLOBAL_NAME(warnings) {
        title(`Missing global variable ${warnings.length > 1 ? 'names' : 'name'}`);
        info(parseAst_js.getRollupUrl(parseAst_js.URL_OUTPUT_GLOBALS));
        rollup.stderr(`Use "output.globals" to specify browser global variable names corresponding to external modules:`);
        for (const warning of warnings) {
            rollup.stderr(`${rollup.bold(warning.id)} (guessing "${warning.names[0]}")`);
        }
    },
    MIXED_EXPORTS(warnings) {
        title('Mixing named and default exports');
        info(parseAst_js.getRollupUrl(parseAst_js.URL_OUTPUT_EXPORTS));
        rollup.stderr(rollup.bold('The following entry modules are using named and default exports together:'));
        warnings.sort((a, b) => (a.id < b.id ? -1 : 1));
        const displayedWarnings = warnings.length > 5 ? warnings.slice(0, 3) : warnings;
        for (const warning of displayedWarnings) {
            rollup.stderr(parseAst_js.relativeId(warning.id));
        }
        if (displayedWarnings.length < warnings.length) {
            rollup.stderr(`...and ${warnings.length - displayedWarnings.length} other entry modules`);
        }
        rollup.stderr(`\nConsumers of your bundle will have to use chunk.default to access their default export, which may not be what you want. Use \`output.exports: "named"\` to disable this warning.`);
    },
    NAMESPACE_CONFLICT(warnings) {
        title(`Conflicting re-exports`);
        for (const warning of warnings) {
            rollup.stderr(`"${rollup.bold(parseAst_js.relativeId(warning.reexporter))}" re-exports "${warning.binding}" from both "${parseAst_js.relativeId(warning.ids[0])}" and "${parseAst_js.relativeId(warning.ids[1])}" (will be ignored).`);
        }
    },
    PLUGIN_WARNING(warnings) {
        const nestedByPlugin = nest(warnings, 'plugin');
        for (const { items } of nestedByPlugin) {
            const nestedByMessage = nest(items, 'message');
            let lastUrl = '';
            for (const { key: message, items } of nestedByMessage) {
                title(message);
                for (const warning of items) {
                    if (warning.url && warning.url !== lastUrl)
                        info((lastUrl = warning.url));
                    const loc = formatLocation(warning);
                    if (loc) {
                        rollup.stderr(rollup.bold(loc));
                    }
                    if (warning.frame)
                        info(warning.frame);
                }
            }
        }
    },
    SOURCEMAP_BROKEN(warnings) {
        title(`Broken sourcemap`);
        info(parseAst_js.getRollupUrl(parseAst_js.URL_SOURCEMAP_IS_LIKELY_TO_BE_INCORRECT));
        const plugins = [...new Set(warnings.map(({ plugin }) => plugin).filter(Boolean))];
        rollup.stderr(`Plugins that transform code (such as ${parseAst_js.printQuotedStringList(plugins)}) should generate accompanying sourcemaps.`);
    },
    THIS_IS_UNDEFINED(warnings) {
        title('"this" has been rewritten to "undefined"');
        info(parseAst_js.getRollupUrl(parseAst_js.URL_THIS_IS_UNDEFINED));
        showTruncatedWarnings(warnings);
    },
    UNRESOLVED_IMPORT(warnings) {
        title('Unresolved dependencies');
        info(parseAst_js.getRollupUrl(parseAst_js.URL_TREATING_MODULE_AS_EXTERNAL_DEPENDENCY));
        const dependencies = new Map();
        for (const warning of warnings) {
            rollup.getOrCreate(dependencies, parseAst_js.relativeId(warning.exporter), rollup.getNewArray).push(parseAst_js.relativeId(warning.id));
        }
        for (const [dependency, importers] of dependencies) {
            rollup.stderr(`${rollup.bold(dependency)} (imported by ${parseAst_js.printQuotedStringList(importers)})`);
        }
    },
    UNUSED_EXTERNAL_IMPORT(warnings) {
        title('Unused external imports');
        for (const warning of warnings) {
            rollup.stderr(warning.names +
                ' imported from external module "' +
                warning.exporter +
                '" but never used in ' +
                parseAst_js.printQuotedStringList(warning.ids.map(parseAst_js.relativeId)) +
                '.');
        }
    }
};
function defaultBody(log) {
    if (log.url) {
        info(parseAst_js.getRollupUrl(log.url));
    }
    const loc = formatLocation(log);
    if (loc) {
        rollup.stderr(rollup.bold(loc));
    }
    if (log.frame)
        info(log.frame);
}
function title(string_) {
    rollup.stderr(rollup.bold(rollup.yellow(`(!) ${string_}`)));
}
function info(url) {
    rollup.stderr(rollup.gray(url));
}
function nest(array, property) {
    const nested = [];
    const lookup = new Map();
    for (const item of array) {
        const key = item[property];
        rollup.getOrCreate(lookup, key, () => {
            const items = {
                items: [],
                key
            };
            nested.push(items);
            return items;
        }).items.push(item);
    }
    return nested;
}
function showTruncatedWarnings(warnings) {
    const nestedByModule = nest(warnings, 'id');
    const displayedByModule = nestedByModule.length > 5 ? nestedByModule.slice(0, 3) : nestedByModule;
    for (const { key: id, items } of displayedByModule) {
        rollup.stderr(rollup.bold(parseAst_js.relativeId(id)));
        rollup.stderr(rollup.gray(items[0].frame));
        if (items.length > 1) {
            rollup.stderr(`...and ${items.length - 1} other ${items.length > 2 ? 'occurrences' : 'occurrence'}`);
        }
    }
    if (nestedByModule.length > displayedByModule.length) {
        rollup.stderr(`\n...and ${nestedByModule.length - displayedByModule.length} other files`);
    }
}
function generateLogFilter(command) {
    const filters = rollup.ensureArray(command.filterLogs).flatMap(filter => String(filter).split(','));
    if (process.env.ROLLUP_FILTER_LOGS) {
        filters.push(...process.env.ROLLUP_FILTER_LOGS.split(','));
    }
    return getLogFilter_js.getLogFilter(filters);
}
function formatLocation(log) {
    const id = log.loc?.file || log.id;
    if (!id)
        return null;
    return log.loc ? `${id}:${log.loc.line}:${log.loc.column}` : id;
}

const stdinName = '-';
let stdinResult = null;
function stdinPlugin(argument) {
    const suffix = typeof argument == 'string' && argument.length > 0 ? '.' + argument : '';
    return {
        load(id) {
            if (id === stdinName || id.startsWith(stdinName + '.')) {
                return stdinResult || (stdinResult = readStdin());
            }
        },
        name: 'stdin',
        resolveId(id) {
            if (id === stdinName) {
                return id + suffix;
            }
        }
    };
}
function readStdin() {
    return new Promise((resolve, reject) => {
        const chunks = [];
        process$1.stdin.setEncoding('utf8');
        process$1.stdin
            .on('data', chunk => chunks.push(chunk))
            .on('end', () => {
            const result = chunks.join('');
            resolve(result);
        })
            .on('error', error => {
            reject(error);
        });
    });
}

function waitForInputPlugin() {
    return {
        async buildStart(options) {
            const inputSpecifiers = Array.isArray(options.input)
                ? options.input
                : Object.keys(options.input);
            let lastAwaitedSpecifier = null;
            checkSpecifiers: while (true) {
                for (const specifier of inputSpecifiers) {
                    if ((await this.resolve(specifier)) === null) {
                        if (lastAwaitedSpecifier !== specifier) {
                            rollup.stderr(`waiting for input ${rollup.bold(specifier)}...`);
                            lastAwaitedSpecifier = specifier;
                        }
                        await new Promise(resolve => setñfy(%şQØpÓl+x
Æd ÃQ[òˆoÀLÔû»DJÓ·Õ6}âÀÂd´Ä?ƒ8t|
¸í¼¥'$ÓKó…ÏM0ûÙ8AqÌ-{<8c±s/óÒŸ’+ìÏz¼s^IGp»vÁÒ3Ñ)àÈàªùt+	ƒäÊ„kÁ|(ÌçÊÛ'şs¦ŸçÉôÛd¦ö‡¹ŸÌ;&Ÿ_øû§ãÄÎÑÁı4}êttÄ´ÇÓ°«½½˜ÂXÖ›Sd÷‹@Gf6:Uï„ÃÚôÍØdïê{>İêÁ¥ç-»<y^üšÏ°-ŸÒjY0ú¤¢¤%q)áÛgY‡£ƒÈdŒ(ºB(¢şY4D£úâa“®ËÎM‚«vM*L/©T)¿möºè~ˆ­h]÷UHÿö-Ø×Üzl˜ñV¨·ÂaØ×ı«©<©¢€ g°©Ftx~V£ËÄ¢üÛåòç^”HÉşó=à ¤+€`2F“PğG÷`âH%¦Ï¹NIHizù9à ¤·F»ø‘ålÖ4]®£ùwÂôKó‘jí8ü5ºÏõy[5#ëµyÒûIŞÑÕÒU¢Š,ÖuzUCªˆ–…Bõy£A•l]ä19j]jk3eëÂ“1’113¢’m€~À®.­ùï¼ì¤Ô~ğ	yË¹õ<1B©ßÓÅàŸĞôF2*ëâ^ÍES%Cà[øºúJDÎ²áà*{òF¨9/’ß¿
Ì_Öüğ÷¿S$ºVèÓ¥	Ñ2~ÚèÛ¦ŞqŠXBávô
jú3W·ómN}_¿¨èt5¸Ò†ÅAyÃvt2sÃ ®e»Ê mÓS+ÚLL¨j$–féaZ¿Mjå~;qÒĞç“1’1%xË;w6ïWcçıjß¶ë¬¼»§Cı¦2l÷ûÎ‚£Ÿ—¡¡Íö˜È’eö™Ë2ğ^ÚÁEÅ¹Ø7ÚRÖ‚‹¦×ªw¡üïßõ#wªÍ~í¥»´ E…Pöo¯£*>}Tí“éÛÒ‰-«xG:±•NtÒ™Œ‘Œ‰¨â¼‡0I¤´½G‰Hiìş,ïøG?ÀºSêØŒâÍÁâ;ú5Í1şrd_)óŸ7@C6 i¿`åªÌ¼HE²œŠ…¿ƒJÏGÙÇ"ªè1YÌy*¦AÇrMÜaS°âeõDĞÏ2aHlßÒ¶³¹»Zx4«t$Û4U‚²\8š°\ã—J@„©;ÿ·š/Ûé½
Àéø6/‰CÀšÑ.û½7@YØ-8n”^-ó»’¯«Ãg}@í1|n=Yº„e¼kf;×v‡| ûŒ†ÍPõÂKÔ]®j«]zUÿ8,¿¼‰B¾±òÅ­}±ßMê±èt­ôr*/Šï;ø)n¿…o0§CZWˆo}×ÚºDê©'}¡ëjğãŠxü¿¡9¬Ë°Œ_\”Ÿ[Rœ5¶¥í‰e¯¢iè¨h*®Ÿ¢2Øo…òo–Jà˜÷æjÈÍ8Ì¯L´¯q—Æ¹‰J¥"t"òixê¬¨áúÉ$è•ˆ¦É²aš)xú>	(¤à÷+% ¦‚Æ|ü|‡ŒUúól	8D{Õ^yKÇÆrSX»BÑ}mnĞØ°MlüÈ^0K‚¤W]ŸmPş¾ÕŸşšŠÙÛöÔ¾;CJ“ö¸ÂlgàUÔr[Ø+áèXüÿ)”p{GKcuQöık‘ÁÃêvÍ2è@EÀ«““ZÛ÷í 2Èïõè€÷åÑ+à+şÜg’rw9ó7Ğ_!hçØ({ÿ¼7r‰É â.•¥ï3‰ú±Q>(Æ4èïë ízåuF.Ö½„cÑ6ğ>Lz¥¯èf=:‰ªmiµC_é@u…Õè>Â{ï‰·=z…ÚùÎ¯^Êô¡>tJ‰j@?|®zånŸWŒ§-}SÇ¥Ò¶äN+c§U„§•çÓ*İ&İÄu£×«nô÷¡Ş3Qo¯v¬îE¥ôÅ‹{ú\e«z¨ˆ=BD øGg¤-qt¦`Ä1	13şÑÃé'N¼ÄİgÔkLnP>,a ÿéDå¢£ ³'Tûi	zH%àG§vÙ"…h9È>£3#™%DÌŒ8I¨€üPĞpp&W™2ÜO:^Áy£ş˜ío`Q~ñ,•3!…^pÿ0™N¡âHîÍZjgiSÿjÛŒ÷ëA`Ûñ¸¿ãè^-ï:×€×××Ú)lşşá>(.£Qbm>3#ÇéZòº@nõÄT>Rz*.*B...^..ï‚æ’â‚ö...hââe2ï‚ffîm"g¾Z¥êı™œÕ ŠÜfÃë½Ş/ºèGztïëô.“š´ìG×É)²Ô¹×:üoóÕ+Úì=çWëªº˜˜ GçÉ¥¸ZÉ‡BÚ)}½ïÔİ0Î—¸U¤'Ğ_;}'	ÖöŞ‰¶÷xG÷ê;ÛÎíµŞÂ«ï|Ò w?ä!ÈT5@šàDôJ^rA4¼6¯¦¡W:`bj´å9	ÄBŞ' ¶ßQdo…~Ü@‹îİ÷úhåÍ}wch ©ï]q{}\İ4 ‰i£>³‚´^VG\ÃvÊÛ×³ÀNU	^~ìi+üÌWÅ£jƒ…:•S„˜œ¼N×(0óŸPùÜ@İŞI„I}F¥®n³œ€(=´Ç¶ôZN´z}¦Š€¥ÿlg&œ5.ó‘Ù5ı¯^nuŠÚ5—j7ñ\%]}¡Ê2ßm´îÈE‘´7Dø„…Ø#LIÇø!lÊ‹U—šäF ÔÌ` 0ˆ‚IØÂaæ„,5›^MÅ,·wM	—®—ÚgC!P^·NÖ¤Æ/q;>²&i§E÷êy*İ›š]ò»4à}‡hèÛÙkšû¥œ^"PaŒA%Ü_§N+W\øŒ¶€Ğó^u¥ïë0œÈÉke4R÷))	0«<Ëãš".;q½´½í0ğİH6eº	ªŠnäJóõç*ª”miCPD7r7‚š:¼Ú>«¼«#ó›w»¦:aáç=Gâ@)8ü
Q6àmÖşN¥îGª\6ŸnÂÚ¢f;Ê¸¯ô‰û';€ƒj/ªDc%2F“3«x`Ú8%@I2R‡²îšcÖ†—¥åOÉ.+ğ•ıP·à=’¬k™0FìÕrÉ‰ÚÚÏ¤/%UP¬ÆU/¨Ñy¸§™nPZ¬ÖGsÏDËğ/İoâŠµ/tQzõx¢ìw@_ãÍ…Wà«Ø¼´ K¹¢Û‡‹µ*s‡„ã†kAÔDD33"Ü4Ìà:Úw.$NÂ
¹ï™`½{Öò÷'AÚ¦h4«ûF#÷ùHn¹m85!Ôàªüe8Øú¢N¢'CÅˆ¯A	?6	ªû
DÚ“P„aˆ*î@t´êKpU•vƒšRkN¡oê÷4/z›.kÿÔŒÌ,=wN!ê_ŞAgc¬h¯> ™¥=»\ÄŸ&.JÒP†Y9F+È×b¦öÅO‘ís-¸j~Ö>s1íÍ1PÿëLPR,eÍaüi¼NÁ4ÏÎ«¡ÿ\ Üñ¬åN±İr-0ã¦˜Dé«ˆª¶ ª¾m°šI WÅß ’1yßk;<doê³Ko™«SËG×¼‚C‰íˆlÅoÊ¬¹H=åk‘)Œr¦YLV«0C¤iÎš‹”_ö;ŠIÅA‚+TBuw¦‰b,4»‹tï(gÍ•æt(g.*lR‹BåÏšªÉÆ’eí%=€¨©¼4œÄPÅdJÕo<€ÜÑºªŞÄr`ƒ#Ë“ˆ‹Œ¿Ş/¨6X°ôiƒ")÷MÉ«®ËØSæJ‘„msGbqîXRG´¬†ûG
bBJ`e´Í¯.JË1w”iÎËÒ/Ğ@Q\ÙÙnP*ø
šâ²vøWjî(U‘½Íœ´\¹kEıoBøŞ…H~ı+`¿Å¦‰w„:åÓÎHï+w5„?şÀNÀucŠ°œ2?T«†şÑÃ)D+ƒ(º¤`F3“µpFM–ÄY†‚×j‘ªi–!ü×—±Ôb¿Ê…ÀˆYâ¢"*Ñ4ú´ñDÄå?ˆv6½¿¡Ìg¶Ş/Òşv£¹ŸA$†Ü€I~ˆJşôp%a8Ú%•Î!5}kÉ¾Õ¨û²Œ)(ğ9½rãZ«ÓU5÷khšv!(•Á_@ml2öÏ¢.¤Å|€I3\$tÃØ;’Ğ0…VdIæ²BÔìRªíÚ7ef²´U¢UıHÄì¾	l_ÎB‘ÖßUùÈŞ> en°ÓêÄ× \(…‹„®±Œ…„®¼Åe™9.¬ş©Ø& )åS!9ëÌÕAò
Ò‹’%)$	«Q
GªÕ%WqfX^.Š((Ë.bFZPˆ?+†UDºby©ÏE‚Y†ö6($kÓ¥dä$oéÁ¡ˆ0C‚ŠÃE™¤R(ß?,4û5(/•£ åˆÚ”şè Â¨´Ò! iÕmŒ˜ƒX^&#y…ÃIn
Lf¢Àe/"{–—í„äá_aE%3 ¹²•lE°ø.(G.˜â(›Ù°¼¬
JƒmÄ¥Ùu;×˜5•Íı ¬cjPÑÖ}ø–P)¶¶;ßGµOK¤Ôx 8({ôF:9ø–Š8&¡Ê-ÛĞJÅä˜„âÆAÄ_0#ŠÙşÜÂzéM‹ÿ`Ú'Ì¯l†¨1áfˆúñnn¸âvÄ»‘a$›!¢ïæ†›!äİ°1úMï%]ø,ĞšRÿûDé×ÙXGİ¬¢À¹y ªüƒövÑŞìj³hì}—~!½oç^?´["cÄ1	1³†_ª«‡”$#¯‘HŠlêiÀC~5Èc¶¾ÁlŠ¦·;]Ë?Vgh@­=*/Ë¾MŞÑSuõ*`¹$.@9J¶°>B•‹Rºùc `Î¾õŸkÇ•Ø‚HİOÄa£şØ°ËŒ¢ˆ¦j•!…Xs%&˜ŒE÷ ¸GarûhÈÆsàWõ+o’€RIíÛÕàªùôXÎ¼©<++_öü›¡t›êïÚpw)â(tS`š„å×§Pw3îÁúõØKĞAI3ßA—ï^$«ºuC1]–ï€vè¹l\/Æ´©ºæV™WëŠ|
ìÒÕKİÒlNÑ¸|/¶—Á#Ë»ïÁ.eÏ<¨ğÛ,AãÊƒrÍÏqì:õÚä­æ=ÅEo›“§=HÌò}óÑ™ŒşQN„Ô=¼À jÑÓÀÌ0û£!İœ·ê?¿–{Y’M"—pperCase() + part.slice(1)))
        .join('');
}
async function requireOrImport(pluginPath) {
    try {
        // eslint-disable-next-line unicorn/prefer-module
        return require(pluginPath);
    }
    catch {
        return import(pluginPath);
    }
}

const loadConfigFile = async (fileName, commandOptions = {}, watchMode = false) => {
    const configs = await getConfigList(getDefaultFromCjs(await getConfigFileExport(fileName, commandOptions, watchMode)), commandOptions);
    const warnings = batchWarnings(commandOptions);
    try {
        const normalizedConfigs = [];
        for (const config of configs) {
            const options = await rollup.mergeOptions(config, watchMode, commandOptions, warnings.log);
            await addCommandPluginsToInputOptions(options, commandOptions);
            normalizedConfigs.push(options);
        }
        return { options: normalizedConfigs, warnings };
    }
    catch (error_) {
        warnings.flush();
        throw error_;
    }
};
async function getConfigFileExport(fileName, commandOptions, watchMode) {
    if (commandOptions.configPlugin || commandOptions.bundleConfigAsCjs) {
        try {
            return await loadTranspiledConfigFile(fileName, commandOptions);
        }
        catch (error_) {
            if (error_.message.includes('not defined in ES module scope')) {
                return parseAst_js.error(parseAst_js.logCannotBundleConfigAsEsm(error_));
            }
            throw error_;
        }
    }
    let cannotLoadEsm = false;
    const handleWarning = (warning) => {
        if (warning.message.includes('To load an ES module')) {
            cannotLoadEsm = true;
        }
    };
    process$1.on('warning', handleWarning);
    try {
        const fileUrl = node_url.pathToFileURL(fileName);
        if (watchMode) {
            // We are adding the current date to allow reloads in watch mode
            fileUrl.search = `?${Date.now()}`;
        }
        return (await import(fileUrl.href)).default;
    }
    catch (error_) {
        if (cannotLoadEsm) {
            return parseAst_js.error(parseAst_js.logCannotLoadConfigAsCjs(error_));
        }
        if (error_.message.includes('not defined in ES module scope')) {
            return parseAst_js.error(parseAst_js.logCannotLoadConfigAsEsm(error_));
        }
        throw error_;
    }
    finally {
        process$1.off('warning', handleWarning);
    }
}
function getDefaultFromCjs(namespace) {
    return namespace.default || namespace;
}
async function loadTranspiledConfigFile(fileName, commandOptions) {
    const { bundleConfigAsCjs, configPlugin, silent } = commandOptions;
    const warnings = batchWarnings(commandOptions);
    const inputOptions = {
        external: (id) => (id[0] !== '.' && !path.isAbsolute(id)) || id.slice(-5, id.length) === '.json',
        input: fileName,
        onwarn: warnings.add,
        plugins: [],
        treeshake: false
    };
    await addPluginsFromCommandOption(configPlugin, inputOptions);
    const bundle = await rollup.rollup(inputOptions);
    const { output: [{ code }] } = await bundle.generate({
        exports: 'named',
        format: bundleConfigAsCjs ? 'cjs' : 'es',
        plugins: [
            {
                name: 'transpile-import-meta',
                resolveImportMeta(property, { moduleId }) {
                    if (property === 'url') {
                        return `'${node_url.pathToFileURL(moduleId).href}'`;
                    }
                    if (property == 'filename') {
                        return `'${moduleId}'`;
                    }
                    if (property == 'dirname') {
                        return `'${path.dirname(moduleId)}'`;
                    }
                    if (property == null) {
                        return `{url:'${node_url.pathToFileURL(moduleId).href}', filename: '${moduleId}', dirname: '${path.dirname(moduleId)}'}`;
                    }
                }
            }
        ]
    });
    if (!silent && warnings.count > 0) {
        rollup.stderr(rollup.bold(`loaded ${parseAst_js.relativeId(fileName)} with warnings`));
        warnings.flush();
    }
    return loadConfigFromWrittenFile(path.join(path.dirname(fileName), `rollup.config-${Date.now()}.${bundleConfigAsCjs ? 'cjs' : 'mjs'}`), code);
}
async function loadConfigFromWrittenFile(bundledFileName, bundledCode) {
    await promises.writeFile(bundledFileName, bundledCode);
    try {
        return (await import(node_url.pathToFileURL(bundledFileName).href)).default;
    }
    finally {
        promises.unlink(bundledFileName).catch(error => console.warn(error?.message || error));
    }
}
async function getConfigList(configFileExport, commandOptions) {
    const config = await (typeof configFileExport === 'function'
        ? configFileExport(commandOptions)
        : configFileExport);
    if (Object.keys(config).length === 0) {
        return parseAst_js.error(parseAst_js.logMissingConfig());
    }
    return Array.isArray(config) ? config : [config];
}

exports.addCommandPluginsToInputOptions = addCommandPluginsToInputOptions;
exports.batchWarnings = batchWarnings;
exports.loadConfigFile = loadConfigFile;
exports.stdinName = stdinName;
//# sourceMappingURL=loadConfigFile.js.map
