import { notNullish, isPrimitive } from './helpers.js';

function normalizeWindowsPath(input = "") {
  if (!input || !input.includes("\\")) {
    return input;
  }
  return input.replace(/\\/g, "/");
}
const _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
function cwd() {
  if (typeof process !== "undefined") {
    return process.cwd().replace(/\\/g, "/");
  }
  return "/";
}
const resolve$2 = function(...arguments_) {
  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
    const path = index >= 0 ? arguments_[index] : cwd();
    if (!path || path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = isAbsolute(path);
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {
    return `/${resolvedPath}`;
  }
  return resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString(path, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char = null;
  for (let index = 0; index <= path.length; ++index) {
    if (index < path.length) {
      char = path[index];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index - 1 || dots === 1) ; else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path.slice(lastSlash + 1, index)}`;
        } else {
          res = path.slice(lastSlash + 1, index);
        }
        lastSegmentLength = index - lastSlash - 1;
      }
      lastSlash = index;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
const isAbsolute = function(p) {
  return _IS_ABSOLUTE_RE.test(p);
};

const comma = ','.charCodeAt(0);
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const intToChar = new Uint8Array(64); // 64 possible chars.
const charToInt = new Uint8Array(128); // z is 122 in ASCII
for (let i = 0; i < chars.length; i++) {
    const c = chars.charCodeAt(i);
    intToChar[i] = c;
    charToInt[c] = i;
}
function decode(mappings) {
    const state = new Int32Array(5);
    const decoded = [];
    let index = 0;
    do {
        const semi = indexOf(mappings, index);
        const line = [];
        let sorted = true;
        let lastCol = 0;
        state[0] = 0;
        for (let i = index; i < semi; i++) {
            let seg;
            i = decodeInteger(mappings, i, state, 0); // genColumn
            const col = state[0];
            if (col < lastCol)
                sorted = false;
            lastCol = col;
            if (hasMoreVlq(mappings, i, semi)) {
                i = decodeInteger(mappings, i, state, 1); // sourcesIndex
                i = decodeInteger(mappings, i, state, 2); // sourceLine
                i = decodeInteger(mappings, i, state, 3); // sourceColumn
                if (hasMoreVlq(mappings, i, semi)) {
                    i = decodeInteger(mappings, i, state, 4); // namesIndex
                    seg = [col, state[1], state[2], state[3], state[4]];
                }
                else {
                    seg = [col, state[1], state[2], state[3]];
                }
            }
            else {
                seg = [col];
            }
            line.push(seg);
        }
        if (!sorted)
            sort(line);
        decoded.push(line);
        index = semi + 1;
    } while (index <= mappings.length);
    return decoded;
}
function indexOf(mappings, index) {
    const idx = mappings.indexOf(';', index);
    return idx === -1 ? mappings.length : idx;
}
function decodeInteger(mappings, pos, state, j) {
    let value = 0;
    let shift = 0;
    let integer = 0;
    do {
        const c = mappings.charCodeAt(pos++);
        integer = charToInt[c];
        value |= (integer & 31) << shift;
        shift += 5;
    } while (integer & 32);
    const shouldNegate = value & 1;
    value >>>= 1;
    if (shouldNegate) {
        value = -0x80000000 | -value;
    }
    state[j] += value;
    return pos;
}
function hasMoreVlq(mappings, i, length) {
    if (i >= length)
        return false;
    return mappings.charCodeAt(i) !== comma;
}
function sort(line) {
    line.sort(sortComparator$1);
}
function sortComparator$1(a, b) {
    return a[0] - b[0];
}

// Matches the scheme of a URL, eg "http://"
const schemeRegex = /^[\w+.-]+:\/\//;
/**
 * Matches the parts of a URL:
 * 1. Scheme, including ":", guaranteed.
 * 2. User/password, including "@", optional.
 * 3. Host, guaranteed.
 * 4. Port, including ":", optional.
 * 5. Path, including "/", optional.
 * 6. Query, including "?", optional.
 * 7. Hash, including "#", optional.
 */
const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
/**
 * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start
 * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).
 *
 * 1. Host, optional.
 * 2. Path, which may include "/", guaranteed.
 * 3. Query, including "?", optional.
 * 4. Hash, including "#", optional.
 */
const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
var UrlType;
(function (UrlType) {
    UrlType[UrlType["Empty"] = 1] = "Empty";
    UrlType[UrlType["Hash"] = 2] = "Hash";
    UrlType[UrlType["Query"] = 3] = "Query";
    UrlType[UrlType["RelativePath"] = 4] = "RelativePath";
    UrlType[UrlType["AbsolutePath"] = 5] = "AbsolutePath";
    UrlType[UrlType["SchemeRelative"] = 6] = "SchemeRelative";
    UrlType[UrlType["Absolute"] = 7] = "Absolute";
})(UrlType || (UrlType = {}));
function isAbsoluteUrl(input) {
    return schemeRegex.test(input);
}
function isSchemeRelativeUrl(input) {
    return input.startsWith('//');
}
function isAbsolutePath(input) {
    return input.startsWith('/');
}
function isFileUrl(input) {
    return input.startsWith('file:');
}
function isRelative(input) {
    return /^[.?#]/.test(input);
}
function parseAbsoluteUrl(input) {
    const match = urlRegex.exec(input);
    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');
}
function parseFileUrl(input) {
    const match = fileRegex.exec(input);
    const path = match[2];
    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');
}
function makeUrl(scheme, user, host, port, path, query, hash) {
    return {
        scheme,
        user,
        host,
        port,
        path,
        query,
        hash,
        type: UrlType.Absolute,
    };
}
function parseUrl(input) {
    if (isSchemeRelativeUrl(input)) {
        const url = parseAbsoluteUrl('http:' + input);
        url.scheme = '';
        url.type = UrlType.SchemeRelative;
        return url;
    }
    if (isAbsolutePath(input)) {
        const url = parseAbsoluteUrl('http://foo.com' + input);
        url.scheme = '';
        url.host = '';
        url.type = UrlType.AbsolutePath;
        return url;
    }
    if (isFileUrl(input))
        return parseFileUrl(input);
    if (isAbsoluteUrl(input))
        return parseAbsoluteUrl(input);
    const url = parseAbsoluteUrl('http://foo.com/' + input);
    url.scheme = '';
    url.host = '';
    url.type = input
        ? input.startsWith('?')
            ? UrlType.Query
            : input.startsWith('#')
                ? UrlType.Hash
                : UrlType.RelativePath
        : UrlType.Empty;
    return url;
}
function stripPathFilename(path) {
    // If a path ends with a parent directory "..", then it's a relative path with excess parent
    // paths. It's not a file, so we can't strip it.
    if (path.endsWith('/..'))
        return path;
    const index = path.lastIndexOf('/');
    return path.slice(0, index + 1);
}
function mergePaths(url, base) {
    normalizePath(base, base.type);
    // If the path is just a "/", then it was an empty path to begin with (remember, we're a relative
    // path).
    if (url.path === '/') {
        url.path = base.path;
    }
    else {
        // Resolution happens relative to the base path's directory, not the file.
        url.path = stripPathFilename(base.path) + url.path;
    }
}
/**
 * The path can have empty directories "//", unneeded parents "foo/..", or current directory
 * "foo/.". We need to normalize to a standard representation.
 */
function normalizePath(url, type) {
    const rel = type <= UrlType.RelativePath;
    const pieces = url.path.split('/');
    // We need to preserve the first piece always, so that we output a leading slash. The item at
    // pieces[0] is an empty string.
    let pointer = 1;
    // Positive is the number of real directories we've output, used for popping a parent directory.
    // Eg, "foo/bar/.." will have a positive 2, and we can decrement to be left with just "foo".
    let positive = 0;
    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting "foo/" will
    // generate `["foo", ""]` pieces). And, if we pop a parent directory. But once we encounter a
    // real directory, we won't need to append, unless the other conditions happen again.
    let addTrailingSlash = false;
    for (let i = 1; i < pieces.length; i++) {
        const piece = pieces[i];
        // An empty directory, could be a trailing slash, or just a double "//" in the path.
        if (!piece) {
            addTrailingSlash = true;
            continue;
        }
        // If we encounter a real directory, then we don't need to append anymore.
        addTrailingSlash = false;
        // A current directory, which we can always drop.
        if (piece === '.')
            continue;
        // A parent directory, we need to see if there are any real directories we can pop. Else, we
        // have an excess of parents, and we'll need to keep the "..".
        if (piece === '..') {
            if (positive) {
                addTrailingSlash = true;
                positive--;
                pointer--;
            }
            else if (rel) {
                // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute
                // URL, protocol relative URL, or an absolute path, we don't need to keep excess.
                pieces[pointer++] = piece;
            }
            continue;
        }
        // We've encountered a real directory. Move it to the next insertion pointer, which accounts for
        // any popped or dropped directories.
        pieces[pointer++] = piece;
        positive++;
    }
    let path = '';
    for (let i = 1; i < pointer; i++) {
        path += '/' + pieces[i];
    }
    if (!path || (addTrailingSlash && !path.endsWith('/..'))) {
        path += '/';
    }
    url.path = path;
}
/**
 * Attempts to resolve `input` URL/path relative to `base`.
 */
function resolve$1(input, base) {
    if (!input && !base)
        return '';
    const url = parseUrl(input);
    let inputType = url.type;
    if (base && inputType !== UrlType.Absolute) {
        const baseUrl = parseUrl(base);
        const baseType = baseUrl.type;
        switch (inputType) {
            case UrlType.Empty:
                url.hash = baseUrl.hash;
            // fall through
            case UrlType.Hash:
                url.query = baseUrl.query;
            // fall through
            case UrlType.Query:
            case UrlType.RelativePath:
                mergePaths(url, baseUrl);
            // fall through
            case UrlType.AbsolutePath:
                // The host, user, and port are joined, you can't copy one without the others.
                url.user = baseUrl.user;
                url.host = baseUrl.host;
                url.port = baseUrl.port;
            // fall through
            case UrlType.SchemeRelative:
                // The input doesn't have a schema at least, so we need to copy at least that over.
                url.scheme = baseUrl.scheme;
        }
        if (baseType > inputType)
            inputType = baseType;
    }
    normalizePath(url, inputType);
    const queryHash = url.query + url.hash;
    switch (inputType) {
        // This is impossible, because of the empty checks at the start of the function.
        // case UrlType.Empty:
        case UrlType.Hash:
        case UrlType.Query:
            return queryHash;
        case UrlType.RelativePath: {
            // The first char is always a "/", and we need it to be relative.
            const path = url.path.slice(1);
            if (!path)
                return queryHash || '.';
            if (isRelative(base || input) && !isRelative(path)) {
                // If base started with a leading ".", or there is no base and input started with a ".",
                // then we need to ensure that the relative path starts with a ".". We don't know if
                // relative starts with a "..", though, so check before prepending.
                return './' + path + queryHash;
            }
            return path + queryHash;
        }
        case UrlType.AbsolutePath:
            return url.path + queryHash;
        default:
            return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;
    }
}

function resolve(input, base) {
    // The base is always treated as a directory, if it's not empty.
    // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327
    // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401
    if (base && !base.endsWith('/'))
        base += '/';
    return resolve$1(input, base);
}

/**
 * Removes everything after the last "/", but leaves the slash.
 */
function stripFilename(path) {
    if (!path)
        return '';
    const index = path.lastIndexOf('/');
    return path.slice(0, index + 1);
}

const COLUMN = 0;
const SOURCES_INDEX = 1;
const SOURCE_LINE = 2;
const SOURCE_COLUMN = 3;
const NAMES_INDEX = 4;
const REV_GENERATED_LINE = 1;
const REV_GENERATED_COLUMN = 2;

function maybeSort(mappings, owned) {
    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
    if (unsortedIndex === mappings.length)
        return mappings;
    // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If
    // not, we do not want to modify the consumer's input array.
    if (!owned)
        mappings = mappings.slice();
    for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
        mappings[i] = sortSegments(mappings[i], owned);
    }
    return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
    for (let i = start; i < mappings.length; i++) {
        if (!isSorted(mappings[i]))
            return i;
    }
    return mappings.length;
}
function isSorted(line) {
    for (let j = 1; j < line.length; j++) {
        if (line[j][COLUMN] < line[j - 1][COLUMN]) {
            return false;
        }
    }
    return true;
}
function sortSegments(line, owned) {
    if (!owned)
        line = line.slice();
    return line.sort(sortComparator);
}
function sortComparator(a, b) {
    return a[COLUMN] - b[COLUMN];
}

let found = false;
/**
 * A binary search implementation that returns the index if a match is found.
 * If no match is found, then the left-index (the index associated with the item that comes just
 * before the desired index) is returned. To maintain proper sort order, a splice would happen at
 * the next index:
 *
 * ```js
 * const array = [1, 3];
 * const needle = 2;
 * const index = binarySearch(array, needle, (item, needle) => item - needle);
 *
 * assert.equal(index, 0);
 * array.splice(index + 1, 0, needle);
 * assert.deepEqual(array, [1, 2, 3]);
 * ```
 */
function binarySearch(haystack, needle, low, high) {
    while (low <= high) {
        const mid = low + ((high - low) >> 1);
        const cmp = haystack[mid][COLUMN] - needle;
        if (cmp === 0) {
            found = true;
            return mid;
        }
        if (cmp < 0) {
            low = mid + 1;
        }
        else {
            high = mid - 1;
        }
    }
    found = false;
    return low - 1;
}
function upperBound(haystack, needle, index) {
    for (let i = index + 1; i < haystack.length; index = i++) {
        if (haystack[i][COLUMN] !== needle)
            break;
    }
    return index;
}
function lowerBound(haystack, needle, index) {
    for (let i = index - 1; i >= 0; index = i--) {
        if (haystack[i][COLUMN] !== needle)
            break;
    }
    return index;
}
function memoizedState() {
    return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1,
    };
}
/**
 * This overly complicated beast is just to record the last tested line/column and the resulting
 * index, allowing us to skip a few tests if mappings are monotonically increasing.
 */
function memoizedBinarySearch(haystack, needle, state, key) {
    const { lastKey, lastNeedle, lastIndex } = state;
    let low = 0;
    let high = haystack.length - 1;
    if (key === lastKey) {
        if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
        }
        if (needle >= lastNeedle) {
            // lastIndex may be -1 if the previous needle was not found.
            low = lastIndex === -1 ? 0 : lastIndex;
        }
        else {
            high = lastIndex;
        }
    }
    state.lastKey = key;
    state.lastNeedle = needle;
    return (state.lastIndex = binarySearch(haystack, needle, low, high));
}

// Rebuilds the original source files, with mappings that are ordered by source line/column instead
// of generated line/column.
function buildBySources(decoded, memos) {
    const sources = memos.map(buildNullArray);
    for (let i = 0; i < decoded.length; i++) {
        const line = decoded[i];
        for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            if (seg.length === 1)
                continue;
            const sourceIndex = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const originalSource = sources[sourceIndex];
            const originalLine = (originalSource[sourceLine] || (originalSource[sourceLine] = []));
            const memo = memos[sourceIndex];
            // The binary search either found a match, or it found the left-index just before where the
            // segment should go. Either way, we want to insert after that. And there may be multiple
            // generated segments associated with an original location, so there may need to move several
            // indexes before we find where we need to insert.
            const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
            insert(originalLine, (memo.lastIndex = index + 1), [sourceColumn, i, seg[COLUMN]]);
        }
    }
    return sources;
}
function insert(array, index, value) {
    for (let i = array.length; i > index; i--) {
        array[i] = array[i - 1];
    }
    array[index] = value;
}
// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like
// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.
// Numeric properties on objects are magically sorted in ascending order by the engine regardless of
// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending
// order when iterating with for-in.
function buildNullArray() {
    return { __proto__: null };
}

const LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';
const COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';
const LEAST_UPPER_BOUND = -1;
const GREATEST_LOWER_BOUND = 1;
/**
 * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.
 */
let decodedMappings;
/**
 * A higher-level API to find the source/line/column associated with a generated line/column
 * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in
 * `source-map` library.
 */
let originalPositionFor;
/**
 * Finds the generated line/column position of the provided source/line/column source position.
 */
let generatedPositionFor;
class TraceMap {
    constructor(map, mapUrl) {
        const isString = typeof map === 'string';
        if (!isString && map._decodedMemo)
            return map;
        const parsed = (isString ? JSON.parse(map) : map);
        const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
        this.version = version;
        this.file = file;
        this.names = names || [];
        this.sourceRoot = sourceRoot;
        this.sources = sources;
        this.sourcesContent = sourcesContent;
        const from = resolve(sourceRoot || '', stripFilename(mapUrl));
        this.resolvedSources = sources.map((s) => resolve(s || '', from));
        const { mappings } = parsed;
        if (typeof mappings === 'string') {
            this._encoded = mappings;
            this._decoded = undefined;
        }
        else {
            this._encoded = undefined;
            this._decoded = maybeSort(mappings, isString);
        }
        this._decodedMemo = memoizedState();
        this._bySources = undefined;
        this._bySourceMemos = undefined;
    }
}
(() => {
    decodedMappings = (map) => {
        return (map._decoded || (map._decoded = decode(map._encoded)));
    };
    originalPositionFor = (map, { line, column, bias }) => {
        line--;
        if (line < 0)
            throw new Error(LINE_GTR_ZERO);
        if (column < 0)
            throw new Error(COL_GTR_EQ_ZERO);
        const decoded = decodedMappings(map);
        // It's common for parent source maps to have pointers to lines that have no
        // mapping (like a "//# sourceMappingURL=") at the end of the child file.
        if (line >= decoded.length)
            return OMapping(null, null, null, null);
        const segments = decoded[line];
        const index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
        if (index === -1)
            return OMapping(null, null, null, null);
        const segment = segments[index];
        if (segment.length === 1)
            return OMapping(null, null, null, null);
        const { names, resolvedSources } = map;
        return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
    };
    generatedPositionFor = (map, { source, line, column, bias }) => {
        return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
    };
    function generatedPosition(map, source, line, column, bias, all) {
        line--;
        if (line < 0)
            throw new Error(LINE_GTR_ZERO);
        if (column < 0)
            throw new Error(COL_GTR_EQ_ZERO);
        const { sources, resolvedSources } = map;
        let sourceIndex = sources.indexOf(source);
        if (sourceIndex === -1)
            sourceIndex = resolvedSources.indexOf(source);
        if (sourceIndex === -1)
            return all ? [] : GMapping(null, null);
     ú½àO1îÍ˜Fz›)5±—~äxXDpx¯™OóÍCÕDvi^…¿ÚZé) TPCWß¬Vuj¡Û§š‡×º7ã‹ Z_4UŞ¤Å£ıVËed}Ñ¦tWsZv—oL•Æ¨À¦êgI*Å¯£^`}ö#åÛ‹ÅòWH÷®6IUøÙV¬€öS"4²ïòWTÛ&ú4Ã‡à¿äèKGö&ü¾üGÆ¬Ò›d4şAÇø} ï°Fí2~"M€¶]v?·‡ˆ‘Ir
Zœqô‹c]²¦ä'¶öŞ´¡Á8@)ÿg[zHÁk¨mNÓ&y9¬ï‡W‘/(º3š%éa,Úø´ÀšN”¤×ğığq6íƒxÆ_÷]•@ÄÌ$¸ ~"IÈÅY²V ş±½‘«‚C¥‚
º«›=SÚóB{RÖi¬?t±Ë­Å²‹FÇtq55Igóa‚ØÿGÛ×ÀEUe¿FAQ155)-¨µ°’°Ó§VNÍˆ’¢öaÑô¥6¯lswãysË6Û´ÍvİÍv­´¨Ğ0\Á$%cWJÚh»8¤ø‘"ïÎ¹o¾ -÷ÿÿïo“yïİsÏ½÷ÜsÎ=ÿ‘h¦ÔR’I¹.«Ù=Ì•ÎZfFŸÇä†¹qAQ&×wGòº¡ßJ$…ea$ìˆi¢“³‹óÎ[/å
¶"Q_©¯ã"yÅº*œyšõ© O+úÌl³eå3Z»(ñ·Ğ€ûf¼ák¢o×Åæº°B®LE/§JÍ©.Î©wCÑJpjlL”D‹gÑ*:‹Üƒ€§à}:QR’³ÁK#8@¬óDsO•»'óT¬‚¨3¹öUŒ‘ú}Ø»=bÈ‹ Â
¼÷¼;_ø1ŞÃÄgqN‡ª¬Eæ{(Æ»œNQ0áé"Ô!˜& ÓSÅv3¥ú,ÛĞ +M~SˆS»°ĞS#éCWÒ bbˆGSó« SIşl.ñg/ÜIÇR~u—ŸÈÕm@Ò¬’˜,Bı¶{NF’‰­º*‚öû³»u:hãüoû„^G'‘nñ©SJ <æ)uMœ	-šHŞ<²M£åv¾2¹µÓVN<û*[ÔAŒÚ¿òĞÂGP¢æ—ªùecÆ¢}Ç¢¬1LÙÎbMĞã€nve#“7ÿªŞ.“¼<»jş&53q¶µ¼í=b+
ğ$â± 	zÁ lT×ğwÍpœyÓèä‡t*Æˆä‡Gî‰¸Á¨tò[ZÛ‚Ê¿J;ÿíïÅ‘uşïrş¦ßğ+´·w‹—ÜÓùşª¥-òı}WşÒÁ]-š–WŞ-?†'iÆÙûÿ½è¿ãîÎı;£û_¶ª›şQãçÛRI(ÏÎƒ¯??²M ¢täóSQ€œy6ˆ#£Ìn·s#u_€æB%Í	Àœ¼åGıC"³Y™bVI¨T…`uÒİÛÛa€“¸Ãdñİ>€7J¼„i‡CÒ·ËRtşğZÆwH¼ñı'âø¬®ğ¡n·)È\WøPM;ŠÀ¨Ç»Tğ„•BEîgÈTÒÕêªSd€’0¦ökÄDlEa&`f§C[ƒºµEWëªëP^S×•Ğ¿¥ºFä<İf±¥ı>|íãXRrµ-8p>â±8`¤3ÁºW 
‹¦{f]5I“Õuõ¤O‹”Çc0Wt¯_ÖU<¤Û^W+ 2;tlÆËV¼´-Ô3©Æ3vÙ³3öç1c,^j[ÚIŠz|aœÖğò;)c[°Ì›‘–È•Çå…¬%ŠŠäÅf§IfHÆ~¥|˜#äƒÎã
Ê6ˆi.£>&]íh˜&F€ØJ7ÕÙBÇ»t':¿©4NuË8XQc› ÙB ë¾m›ÎRK%FM6b¦.
nŞar÷Àd¤1.ãñÍî°8œ~")ûJ|Ì.X‹zÌy/¢e£(ğÒ† (¨’9É¼8…ùĞÂ’yÖ-Œš¿&¼$ôjı[µ\İ¼¤ xŠ­	4¾JÒØùîFmë³Á²b² B™¾¶I×„Ó™P:yÛ±3À+¡&ŒXƒuM„fT¯;!Q/8×°…‹; »3éşÁmfô7Ğ‹‘>‘ı)fgG%	<&R±É-ƒ±‰Á¼Mè*Cx~®Vèa¡nÀû„şğ,üÈ8¿‡fÎIT.P×‘¶!Ç¹5¸u
Ì•Àìúi·å·ĞIÄgnÑáŞÒîùæ\”¡gÑĞÍÂ
kÁBm!é#øÖZbZúh¤7b±bÂÕu-¡]Cİí††A` Ï0ö”öh(ì'5›]ÇlB;`v+ÂÌÍ–æ³+¤ =¬‡ı¢­°>JÇßU3OUçø¸àG#q*…[OmUp¦•+¡K˜¢‰‡Ş.€9ù×¸3Tì{°¹=êfæ·?µé|¢‹¹«5òöê>¡’Äoÿ{FX5Nˆÿô–`$óÖy(oïÂu+$l¤âüU	X‚¡ÏÙ°óH¥ˆ³I º €îôxL´_ÎÄ
¨ ~	\!n[ÂåiE4F”#X¿8õhijB	Í/Q½ş(Æ¥áyZuõ¹ÎÓB§Ïì|zš£ÎÓ·‹Ãç)¿`Lä5ğÙûGÅŸzÎşÿ*úóÎÎıŸ9Õÿåı»$7»Üc¢úc°VrÂv-´[3Œòô‘VËêò	bçÂB}8\¶ñDÚÆ
Ì™v¶“ÿaL˜+›©CåöEĞïĞÿ˜×ÙéÆè»INO•¿•ÿÖ¥²1²²_õLôœã}<ÇîàíÒ9ïã	¶Nè¡`AÄUı?èª~Hî$š?ƒ“¯ÈøÅ«û„4’ú'qìáˆI$4t­l•ßèRùôOQ+ m™‡Ëàrsa•ü½'psßxQ•‰Çñ¬ ·¥®ÛD´3Ì“etd£HÄã®Sú]#=&=v
•xƒH‰W°Î`ıèCTâ-[@J¼ÆEĞŸö(I·È`ñÇkBËv»p…ø¨Ş-ìâSQsZ?·ˆECÇ¤ÃÀÌ¨ë$qnšq¤¡y“(¡w+¾Äm˜¥èzf+¶¾Ÿ, ìúõšŞÎŸ[u¾ƒéŸU<ãøc{Z5¼%:Di€Õ­:ßÕƒ‘¶ç~xèv^Üa0Ã´‚a«C³
K_Ù“Æ@_ırğ¾iÒ/.zˆsÚé«¿ÔM/©æõhùè¶\VÈn3Qß'Æ% mŸ”ËSñ
K—uÜİW€-zëuêt¹ãN¼ïD„	fFà”R¹hnÔR¼‰°‘¢Â»q#Y|»Q!¬§ÚŞa„M`w2NŠ.ã<ï’3Z^27ÑüÑäç—¡fùìÒ34ÎÁgÑ=5(ºGÃ·ÈİäŒäD>®£T:Õ-ú}U¢8^ø?»Ó“±/¸?¬¯kï¤w’Z<U`Ï$®¸PıMn‰,nš£{…Up3‚Š3â!Îƒß|+¦áƒÓ¶ËWz%¥·Sß=÷¼²Ğ˜Rtä°UÛ™\Dİ‚Ïš=UÄˆ‘rG¤d{·Ÿ6²/1oÅ±oZ¡EÂ.İ¨A†Å¨/óï?ÒE?saÓŠc¹†îÿ[{J¼øiáRñ¥!ÑÆ/u¥‡a²Ç·^NdÿNşn 'Ò<‡˜	ï‡˜“IrßÌ¦îŞ''™JpÕDõËb Ñt³ƒ|û$n¶]°^Øî7ÙÈv¹iæînÉŞ[‚ìmÌîLöLQdoÌÒ.öX.#ÿçÔmœK
RBäjK²1fÎò%É¯Ró«Õü „û\0!U|òtğ¬N“«ò\óÒ¶gm_hVów4bìA5¿1q€åTM€—,¶w
3øsJ§”:‰2À§âüƒ¾²E¦òA‰ıJ½³ ïÏµ…&ò´|½÷ş öUÆ®mÉh#iZeZiñaã½­&åğU ÙJÃg+†Û¥‘©{•*\à#P8òTgr÷wMœ	hÚV;U1€N®IÛéš(@ÃÆ_ávídÜğ)ú0Ñj.ô”,E¯õ$×ÊU¿­LÍ,B¤×S&	%M)ë?ú›8rJ¸[§•PcX!Õ03¹ÒW¦$ĞÀëqkZı¶Z³UiLvmjŠÑüÎë©•DJVM©Õúİ»@Øs~I6"ğJ×Ì¥i$ñu¡|Ş,UÈ›Hù,—ˆ`@›\xå¿Ú|ú^İ¼Á¶‰ßñCP…L­½z¨-$šbYİ"&bíNÆ@=Ê ³j†f½§qBŸÇlêjï¼J}ö—F”êU*!\*8û±ÌV&¾”…/¯AÑO„®:8QŸ5Şs²n.$W©rµ*×,/ç«"›ãîøŸ”ì\ÖÆö¹	[:óÏ.¥-;ÿäGÚòòë´ãKÄ¿–?Eßİ–““aÇB§eâş„
ËÇvóbºló¸Í¿
3yŸ„·ùm±°öòŞÍäåò!?D1y6Oh›ÃÅòï¯¤'£Œí±Ûí®8şt<;B†á¡q½ûşğø¢ñÙùÁÿÒø&G/“¿<JR´ËÈ)Çç,È6£Í˜+€é:Âı8ÂšnÙØ•±DÈ¾¿½3›Õ5Âë#ã‹é4¾¾ÂØi|İÍ_Â(}ş´º¿GkşğÆåbãùÌßbşzÜŞyşò¿ÿ©Nó7"3z|fY’f—»¬%B*İº(Ib
æ¥çqî	^np§N-¾§AC>æ1‹˜‹±!½ª»/hRHéîK»$X’‘hî±ÂæÚIt(~YÁ2™G‹+WCÄE‘íepÂ Ÿ J³Îîø•'KÒFkÏm4d‚^‹h\S '¸ÜŠªq¦p¿Üä´ókOZê§À¹}ö»Mò·Ÿàïü×*éÁØP+ñ'ñ¥ğñyxÔ}}ğ±ÙŞÃqîLïaƒ{Èíğ¯2!’£Á£ùu ½Ëkèı:I{­6Æ«ÊøÈ'€¦$KcĞNâÙŞ0YSŸ–Mn L™²ÕŸ)'[Šîì/Ic{àÊT5RåZU®Ã´òU®*•q`B1ˆ!r=àVàÆHJ~[½å…²Œ}S¼õŸ{Ë®²ó¿§Ãî÷c  ¾ëX‹°+°­àÏ-o*~r8²ñÖşÉ©AŸ”KFcˆsÀg¨jçùßÑüò
(Ucçöü8@`-ÛÎ”º-™sJSmñÈq‘ÎŒ¤úwÏ
%I…‹×RÚ
Œš·šOYŠÉ$2´Leµ°²cò
€*4lëã÷§t­Ü+5èi¶Ì
ï´i©Â÷kƒÎUl‚Èæ›~R[^K§ƒ¼Á?åßÒ@“+šã‡acaF€`g(
¨©ûÒ¤ÉYÕ–5Á	nÄ+Lıû8aáùi$[ãKØ¹

î‚<¢I/>ë`[ÑûX«ÎpÒ|Z#tCÛ«`ùõ®‰s|Ü3˜ÜU5ÉLä`Ö·À¹^”“yZ9™-MdåY{&³™Äˆ”o£è Ïæ»oH¢{VÌl‡’tß
½ì€.¦3êâ«á.vè]TEuaîâ	74ÿ5¿CÂC×;¯
š±Îk| P¾Énók³N»‡¸Òg“-(2tdÆ;ä½£º´Šğ[EÖËï²±îÓÔ_E·º1!È[E 6æ[ô¤«VR©™ +Ğ–&#Ó*²*,¿›,äÂûË£ğ~ë—gP	D{gœÿ3á¼q> ¤ä^vœÏˆÄùİ	¿„ó.]´wP'Æï{ãu¼[ŠNÅâ-D7¸oüÆ´>0!“Ö…—èoÔ(Tİ…ªnVè‹ñç­+ÅP.÷+±5&ş¼±µçu±3ëØzİÂÖ®gÃÖ_àKÖQ÷…Ì³1Rô^`ñR ZU©e
Päõ )cÏ§Í ô©,e½rŞ;\`WU*yŞâV$±ğ,ïpƒDvûe:‘Õ©j[.PU¹6M®ÛÉé%ñHNÑÄ†gˆ_Aæ7:9M rÚú”ÈÍÓDôô3tgğ4u!©Mg:“Ô~[aIMôË…Hjî:IíÉäB$©w$’š šã/ÛI%p¿ø2Š¤â*ªš'¨*¹ù)ªN¦ª§U½4DU©xì¿ÃKvñ²¨%ûĞŞhªÚyÁş7ö¼láiZM‹2å‚õÆ÷‚"ºè—y;µGhÁ~Ú†j–îìkğÅ‘q@à)›z²U”‘È¢w6&,é0XVæô@i¼šŒpäz]<7ŸPÙ[¼)…7¯/ 7–ÌüRKÑ÷°2óa6şmŠ\ß&×¨P’Kı¶jKëam…Ó¿RÍjKÑkT³:,—>kri5H’8}…âîQÄU¬ -K×=¤á­1
~d~E_„ˆJfuşµXû² ¡Yıõ«6İ0šÚn=€Ró)à‘ï5
˜‚ÿj«ô=ĞßoÛ±øåÍö@öT}ôgòfÜ³ëh@Ø,ñ î‹ïCÑ Eë¡*qõ×EAèïFHMğzª%ô³¯
¨Õ‘Ë?îëğò÷x£–ÿÃUç^ş?Æœ÷ò_ÚBkóÉk~åò/Š9ïå¡è¢ÿ5çXşGÿ+WıEsÏüÈŠ#—ÿùj’õ‰¡¶º&¯ÅC¿'Í®m™–ã÷}×=}zş˜ ODOøSŸı¿ğşÿ
OøŠ¥Q¾ø³sOøIÃyOøª“4Åc~å„?o8ï	¿\tqñ˜³N¸{îÿ«ÉŞş3Mö‡AÅ.Dm24¾*EMÛÊ6ìÅô‰‹WóK;Ï¼+ë4m‰¡i58ks¿ÏÚWOGÍÚÎJı^ï£ô‰.>¿…qXŸÔÅ­ašîÑôSÑM?XyNöö¿ZëyŸ'ÄùwÕ¯=ÿ"ºøµçŸè¢ßUç  ·Mœ)íg;ÿNbì0¹!ã$AiÛ¡KUÙ€çÌaT7íSsª½ÀvZŠŠPĞ>XJJÂ‘ÇLV,±YÍA[î¡Èa‡ƒ‘é•å”Á'4ÙÄğ]§)ou½_Ùè·QbF'ƒà¾Ò4#ÀSä$WL„Ó(¼ğá•YfşF‹×ÜpõàA-–SÏ¯ò+¥Ø3hî«L°¶Fã¡yÆn˜ËRUY-œâğ/0¢ÀX¤Ê›ù„¯¬’ï$SŠÜ}àtŠ)³kÊz'Ÿó€H+*oÎØ¥Nj¹OMœ„£È´•"¹)’ Pr´Òx± dÂjG
å  “t3d+òßr¢q’aà˜­Zcöû1%4ÿí´GD|°òŸî§·©Ş­X°şé…
% Ê;¯{º˜ù(­4 ùb¼ĞÑÜF“xk×§d*SŠ;¿8jøùÄEcpøsôáoŒ~ª×SLä¶88~e³
Ò\&ÍÃQ8BÑ@Ä'†±-Îc,bàÁ/hCÒß¾±'yĞ}OŞ^ôê·JO)«Üâ«ñ×B_š¯ ˆ«—úm›"ØËüò¦NìGÍı¸”Ù6y·Ÿà¿$öc”Î~¤|I,ø8¿ÛµóÙf¼u§ƒ(!ºrdÉuîdVÉ¥råZWúÌ˜r †‹)NãöVım¦\£ŒôzÌqÊğˆš‰Psç§h_ˆ§@A™†éƒY-Œ˜`ıl†Ô/“tTšP—ö%fQØÀrª‘K”b¾NÛûò¥I´W³š›ŸsğšrŞ&“6Ù›uÒƒtu`lĞ&vSc>úhK&Köw–Ÿ"gLr¯y¤5¬ÁZykLÑ0„ı g ÚËí¾aaÉêr’¬^}DHV›H²By6ŠÆw–¯lMºW&Îã~¹)~*õ:ÍfìÍ'P\T¦˜vÊc@¤ËéÊ‹•»“½õB¨k$}a+Ç
=KØ‡{¸«]›6:Jè¢±ÌÚ	BW£ï@à+ë"ğıÆï_Œm‡Üh¿oqW(ç××ÜoUÀeWğ-»ËE»üõên$?âë°>„ğ··CşÜKÁ·<¬3VÃ¢«ë‘±rOgMª
ŸyÏ,Š:óØNg¦W„OÓKáwclHtÄVïk	Ú¬R£¥»Ã^İèEÛ;¤y‘éº–ó>H¯ı‰N¹ß¤9]g‹d8Js#Ò±-ç}”îk¢N>»,Ø‰®'^^d,.//oüÓ)§¸ö”_Ş@ÛÆ^à£›–'¯î°0U÷"ªª?Ù‰İKä¥ãîğ­qÁ8ôÇºÛ2ÌÊ‹æ&Iì˜ªÔáıp-Šúë`!B:ìfşvoº\éÇúáîë£h¶ÉR4ï»“fğ^P¿<Ruõ*qğ­š_¯æ7`R1ß§RÂ€íAöµáèñç?ìşÙ§:à$ŸŠ^ùhZ:-$íAP¥Õ@ÂpÅÌ Î°İôĞ/WGï‚;o8Ia‹ó	;å#’ÕÉ5ŒîŞú3PÎ?øŠvüÜ°x7Û9	¶³ßOá_åZşÈçmšwö	Ê¶…#’0·ğÛVñ\±Mò*üôĞïh7Jªgƒ*oeœpÀÕûı¸T?|G+aÛÀ7W ”Û@"Œ²›ükMĞ€ÇŸ³*âÖu-%ˆ*=ŸŠb^ qåãSN‹åb>lJOİå–úzuk›Øk«øÓÀ/ëÀ•p%ª\Fª$¹Äi×‰ßŸJ×ÍÀ^è8Ö·"|Yœ}\¥_%Õáµ–È\³#:únß#áÍnoıw2ïúïJTdìCo™;7ÆJõeò;w÷Å§Ò/W1Ïg®'×áQ¼ +¢ãÏµ{µÕñ‘Ÿ«YüıÜ›	’*W“ñ)”‡)}¤Ê*8Èî¿AV¨ÂOÙâ±z)O†ßäCIƒ¸×%=Ó:]°[ï¥Ô-œÍ<g÷B©G¢r^®¥_\"üPômìTã_Ñ¤9Î·GƒóØ×ªÒNĞXŠ~‹v<ÿD]üb\]¨†§q`0Û¹°8#`qß-àüH7vGJ=ìõ_Ë·Â?hËÅ(/+o\ƒ_®Sóë"/œ—š‰.-f•:¿m³“şÏïÍf ùôoAKúX‘şÍDÓ˜l5¿‰{‰õü¤Q$’Ô{*ƒ¤k\2’.b µ]mÂw¼3áºcÖwCµ*ä&¼V&Ê5i¡\í@×¯(²õF&ZD7ãx^,7=úş–·UãâıÃ.«ïª¨ÖİÛû}‡ß¶°vx¡ç¸´	•¥èC"R%üİÇ‚Dª$H¤2ˆ}¨ ½CéZP©Œ‹dªIGŸ·ƒdª†÷*'wEA¦Ê°Qcu˜L•t"S€‰Ø+í¹.dj‘©µüÉ	A2E}µ”´év	ÿúBO°.öú…¬¡s°mÒª~ÿ§aZ5¶;Zåt–ÏÕBµ`Ğ} DPM1İVüÿ¤ {/ŠÚq¼tFWm×Ô’\\¬_ÏÀÃ7>Z#…$VG+×w†—kÙAÒLÑåA²œq sCXŠ.ÀïoÅ*ú¢½‡ÅG‘/nâ2vëÀ#é`8Ğë_xìggd¬ì†X8 7yw&ëTÏ&´p{0Á’âÜ`Çê5O¡C(‡Ş¸á5\9V›/Ë†{q¤>è7)öÀÓü¤F§\"8ˆås2	ü%½Iñ
&	:}xÇ«5¢UKê}¨•hûêÉ64ç­V|*3Ñˆ7v®¤ÀIÑ{ÆAZúÇS Æüœ®S—¿­ÌÉİ¢.e1PÊDÒ¤ëâEş´p­j'Ï×ª¶sW I