import { format, plugins } from 'pretty-format';
import * as diff$1 from 'diff-sequences';
import { g as getColors } from './chunk-colors.js';

function getType(value) {
  if (value === void 0) {
    return "undefined";
  } else if (value === null) {
    return "null";
  } else if (Array.isArray(value)) {
    return "array";
  } else if (typeof value === "boolean") {
    return "boolean";
  } else if (typeof value === "function") {
    return "function";
  } else if (typeof value === "number") {
    return "number";
  } else if (typeof value === "string") {
    return "string";
  } else if (typeof value === "bigint") {
    return "bigint";
  } else if (typeof value === "object") {
    if (value != null) {
      if (value.constructor === RegExp)
        return "regexp";
      else if (value.constructor === Map)
        return "map";
      else if (value.constructor === Set)
        return "set";
      else if (value.constructor === Date)
        return "date";
    }
    return "object";
  } else if (typeof value === "symbol") {
    return "symbol";
  }
  throw new Error(`value of unknown type: ${value}`);
}

const DIFF_DELETE = -1;
const DIFF_INSERT = 1;
const DIFF_EQUAL = 0;
class Diff {
  0;
  1;
  constructor(op, text) {
    this[0] = op;
    this[1] = text;
  }
}
const diff_commonPrefix = function(text1, text2) {
  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0))
    return 0;
  let pointermin = 0;
  let pointermax = Math.min(text1.length, text2.length);
  let pointermid = pointermax;
  let pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};
const diff_commonSuffix = function(text1, text2) {
  if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1))
    return 0;
  let pointermin = 0;
  let pointermax = Math.min(text1.length, text2.length);
  let pointermid = pointermax;
  let pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};
const diff_commonOverlap_ = function(text1, text2) {
  const text1_length = text1.length;
  const text2_length = text2.length;
  if (text1_length === 0 || text2_length === 0)
    return 0;
  if (text1_length > text2_length)
    text1 = text1.substring(text1_length - text2_length);
  else if (text1_length < text2_length)
    text2 = text2.substring(0, text1_length);
  const text_length = Math.min(text1_length, text2_length);
  if (text1 === text2)
    return text_length;
  let best = 0;
  let length = 1;
  while (true) {
    const pattern = text1.substring(text_length - length);
    const found = text2.indexOf(pattern);
    if (found === -1)
      return best;
    length += found;
    if (found === 0 || text1.substring(text_length - length) === text2.substring(0, length)) {
      best = length;
      length++;
    }
  }
};
const diff_cleanupSemantic = function(diffs) {
  let changes = false;
  const equalities = [];
  let equalitiesLength = 0;
  let lastEquality = null;
  let pointer = 0;
  let length_insertions1 = 0;
  let length_deletions1 = 0;
  let length_insertions2 = 0;
  let length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] === DIFF_EQUAL) {
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastEquality = diffs[pointer][1];
    } else {
      if (diffs[pointer][0] === DIFF_INSERT)
        length_insertions2 += diffs[pointer][1].length;
      else
        length_deletions2 += diffs[pointer][1].length;
      if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {
        diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality));
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastEquality = null;
        changes = true;
      }
    }
    pointer++;
  }
  if (changes)
    diff_cleanupMerge(diffs);
  diff_cleanupSemanticLossless(diffs);
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
      const deletion = diffs[pointer - 1][1];
      const insertion = diffs[pointer][1];
      const overlap_length1 = diff_commonOverlap_(deletion, insertion);
      const overlap_length2 = diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
          diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));
          diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
          diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] = deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
};
const nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
const whitespaceRegex_ = /\s/;
const linebreakRegex_ = /[\r\n]/;
const blanklineEndRegex_ = /\n\r?\n$/;
const blanklineStartRegex_ = /^\r?\n\r?\n/;
function diff_cleanupSemanticLossless(diffs) {
  function diff_cleanupSemanticScore_(one, two) {
    if (!one || !two) {
      return 6;
    }
    const char1 = one.charAt(one.length - 1);
    const char2 = two.charAt(0);
    const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
    const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
    const whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
    const whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
    const lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
    const lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
    const blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
    const blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
    if (blankLine1 || blankLine2) {
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      return 3;
    } else if (whitespace1 || whitespace2) {
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      return 1;
    }
    return 0;
  }
  let pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
      let equality1 = diffs[pointer - 1][1];
      let edit = diffs[pointer][1];
      let equality2 = diffs[pointer + 1][1];
      const commonOffset = diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        const commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }
      let bestEquality1 = equality1;
      let bestEdit = edit;
      let bestEquality2 = equality2;
      let bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        const score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }
      if (diffs[pointer - 1][1] !== bestEquality1) {
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
}
function diff_cleanupMerge(diffs) {
  diffs.push(new Diff(DIFF_EQUAL, ""));
  let pointer = 0;
  let count_delete = 0;
  let count_insert = 0;
  let text_delete = "";
  let text_insert = "";
  let commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            commonlength = diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] === DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength)));
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            commonlength = diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length - commonlength);
              text_delete = text_delete.substring(0, text_delete.length - commonlength);
            }
          }
          pointer -= count_delete + count_insert;
          diffs.splice(pointer, count_delete + count_insert);
          if (text_delete.length) {
            diffs.splice(pointer, 0, new Diff(DIFF_DELETE, text_delete));
            pointer++;
          }
          if (text_insert.length) {
            diffs.splice(pointer, 0, new Diff(DIFF_INSERT, text_insert));
            pointer++;
          }
          pointer++;
        } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = "";
        text_insert = "";
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === "")
    diffs.pop();
  let changes = false;
  pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
      if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  if (changes)
    diff_cleanupMerge(diffs);
}

const NO_DIFF_MESSAGE = "Compared values have no visual difference.";
const SIMILAR_MESSAGE = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.";

function formatTrailingSpaces(line, trailingSpaceFormatter) {
  return line.replace(/\s+$/, (match) => trailingSpaceFormatter(match));
}
function printDiffLine(line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {
  return line.length !== 0 ? color(
    `${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`
  ) : indicator !== " " ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : "";
}
function printDeleteLine(line, isFirstOrLast, {
  aColor,
  aIndicator,
  changeLineTrailingSpaceColor,
  emptyFirstOrLastLinePlaceholder
}) {
  return printDiffLine(
    line,
    isFirstOrLast,
    aColor,
    aIndicator,
    changeLineTrailingSpaceColor,
    emptyFirstOrLastLinePlaceholder
  );
}
function printInsertLine(line, isFirstOrLast, {
  bColor,
  bIndicator,
  changeLineTrailingSpaceColor,
  emptyFirstOrLastLinePlaceholder
}) {
  return printDiffLine(
    line,
    isFirstOrLast,
    bColor,
    bIndicator,
    changeLineTrailingSpaceColor,
    emptyFirstOrLastLinePlaceholder
  );
}
function printCommonLine(line, isFirstOrLast, {
  commonColor,
  commonIndicator,
  commonLineTrailingSpaceColor,
  emptyFirstOrLastLinePlaceholder
}) {
  return printDiffLine(
    line,
    isFirstOrLast,
    commonColor,
    commonIndicator,
    commonLineTrailingSpaceColor,
    emptyFirstOrLastLinePlaceholder
  );
}
function createPatchMark(aStart, aEnd, bStart, bEnd, { patchColor }) {
  return patchColor(
    `@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`
  );
}
function joinAlignedDiffsNoExpand(diffs, options) {
  const iLength = diffs.length;
  const nContextLines = options.contextLines;
  const nContextLines2 = nContextLines + nContextLines;
  let jLength = iLength;
  let hasExcessAtStartOrEnd = false;
  let nExcessesBetweenChanges = 0;
  let i = 0;
  while (i !== iLength) {
    const iStart = i;
    while (i !== iLength && diffs[i][0] === DIFF_EQUAL)
      i += 1;
    if (iStart !== i) {
      if (iStart === 0) {
        if (i > nContextLines) {
          jLength -= i - nContextLines;
          hasExcessAtStartOrEnd = true;
        }
      } else if (i === iLength) {
        const n = i - iStart;
        if (n > nContextLines) {
          jLength -= n - nContextLines;
          hasExcessAtStartOrEnd = true;
        }
      } else {
        const n = i - iStart;
        if (n > nContextLines2) {
          jLength -= n - nContextLines2;
          nExcessesBetweenChanges += 1;
        }
      }
    }
    while (i !== iLength && diffs[i][0] !== DIFF_EQUAL)
      i += 1;
  }
  const hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;
  if (nExcessesBetweenChanges !== 0)
    jLength += nExcessesBetweenChanges + 1;
  else if (hasExcessAtStartOrEnd)
    jLength += 1;
  const jLast = jLength - 1;
  const lines = [];
  let jPatchMark = 0;
  if (hasPatch)
    lines.push("");
  let aStart = 0;
  let bStart = 0;
  let aEnd = 0;
  let bEnd = 0;
  const pushCommonLine = (line) => {
    const j = lines.length;
    lines.push(printCommonLine(line, j === 0 || j === jLast, options));
    aEnd += 1;
    bEnd += 1;
  };
  const pushDeleteLine = (line) => {
    const j = lines.length;
    lines.push(printDeleteLine(line, j === 0 || j === jLast, options));
    aEnd += 1;
  };
  const pushInsertLine = (line) => {
    const j = lines.length;
    lines.push(printInsertLine(line, j === 0 || j === jLast, options));
    bEnd += 1;
  };
  i = 0;
  while (i !== iLength) {
    let iStart = i;
    while (i !== iLength && diffs[i][0] === DIFF_EQUAL)
      i += 1;
    if (iStart !== i) {
      if (iStart === 0) {
        if (i > nContextLines) {
          iStart = i - nContextLines;
          aStart = iStart;
          bStart = iStart;
          aEnd = aStart;
          bEnd = bStart;
        }
        for (let iCommon = iStart; iCommon !== i; iCommon += 1)
          pushCommonLine(diffs[iCommon][1]);
      } else if (i === iLength) {
        const iEnd = i - iStart > nContextLines ? iStart + nContextLines : i;
        for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1)
          pushCommonLine(diffs[iCommon][1]);
      } else {
        const nCommon = i - iStart;
        if (nCommon > nContextLines2) {
          const iEnd = iStart + nContextLines;
          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1)
            pushCommonLine(diffs[iCommon][1]);
          lines[jPatchMark] = createPatchMark(
            aStart,
            aEnd,
            bStart,
            bEnd,
            options
          );
          jPatchMark = lines.length;
          lines.push("");
          const nOmit = nCommon - nContextLines2;
          aStart = aEnd + nOmit;
          bStart = bEnd + nOmit;
          aEnd = aStart;
          bEnd = bStart;
          for (let iCommon = i - nContextLines; iCommon !== i; iCommon += 1)
            pushCommonLine(diffs[iCommon][1]);
        } else {
          for (let iCommon = iStart; iCommon !== i; iCommon += 1)
            pushCommonLine(diffs[iCommon][1]);
        }
      }
    }
    while (i !== iLength && diffs[i][0] === DIFF_DELETE) {
      pushDeleteLine(diffs[i][1]);
      i += 1;
    }
    while (i !== iLength && diffs[i][0] === DIFF_INSERT) {
      pushInsertLine(diffs[i][1]);
      i += 1;
    }
  }
  if (hasPatch)
    lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);
  return lines.join("\n");
}
function joinAlignedDiffsExpand(diffs, options) {
  return diffs.map((diff, i, diffs2) => {
    const line = diff[1];
    const isFirstOrLast = i === 0 || i === diffs2.length - 1;
    switch (diff[0]) {
      case DIFF_DELETE:
        return printDeleteLine(line, isFirstOrLast, options);
      case DIFF_INSERT:
        return printInsertLine(line, isFirstOrLast, options);
      default:
        return printCommonLine(line, isFirstOrLast, options);
    }
  }).join("\n");
}

const noColor = (string) => string;
const DIFF_CONTEXT_DEFAULT = 5;
const DIFF_TRUNCATE_THRESHOLD_DEFAULT = 0;
function getDefaultOptions() {
  const c = getColors();
  return {
    aAnnotation: "Expected",
    aColor: c.green,
    aIndicator: "-",
    bAnnotation: "Received",
    bColor: c.red,
    bIndicator: "+",
    changeColor: c.inverse,
    changeLineTrailingSpaceColor: noColor,
    commonColor: c.dim,
    commonIndicator: " ",
    commonLineTrailingSpaceColor: noColor,
    compareKeys: void 0,
    contextLines: DIFF_CONTEXT_DEFAULT,
    emptyFirstOrLastLinePlaceholder: "",
    expand: true,
    includeChangeCounts: false,
    omitAnnotationLines: false,
    patchColor: c.yellow,
    truncateThreshold: DIFF_TRUNCATE_THRESHOLD_DEFAULT,
    truncateAnnotation: "... Diff result is truncated",
    truncateAnnotationColor: noColor
  };
}
function getCompareKeys(compareKeys) {
  return compareKeys && typeof compareKeys === "function" ? compareKeys : void 0;
}
function getContextLines(contextLines) {
  return typeof contextLines === "number" && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;
}
function normalizeDiffOptions(options = {}) {
  return {
    ...getDefaultOptions(),
    ...options,
 0P²‘8ËÑ¥L5„ÆÆ01’ã¾#İöG°$N¬Õè€±4Š‡a9ÕŠ—&Å;#­B€uaå ¶Y+ã²JJ¦ ”	8ªI~è@¤æI”Wó”ï2tß“îìt¤Î|
•@“Ä|
t‹‡ÑB•=@òÏãs¨}$©â:ñÑ6Ó0EÄÓ\©´
¨H =Úœ\“Ğ‚w²í
ÉoŸI9Œ%)@÷²…Ô²s8ùS¶Ã¸ò;i€ÿ$èIâ¢Ãç}Š”$|K> µ*PùÓƒ}z]dM•åGÂ
®GKS¤ƒhîXz¡şR=®İ zL{H·w¼`0}o}’¤şèF{‰9)ú®0’#µ>aOÎ‚B
ñceÅíµ‰6q©I×òÏşü6ıª–ûwJ&2æ¨abN¨ŞZ¾§¿úãyíÇFíÇÚşì¶Ó†/pa*îZ%uÙR©Y,h¤uÚé&ŸÇ¿Ç%„Á–ô¡Œ®ú@€ÇÿEoïõ¹åä;h¨Zõ–àoºÙ+Ÿ-şº+[~ı(4ßØ&íß‡}1CìTmÏŞS{b4w,7ı›áÛTÄÇ—0{H 9ÎS¥2ñUÎi¿"œˆ®Ñ›ê7Â/XÈTàÅq×¦KĞ¯aq­3ş¬¤ıá—ãœÕ7*`ª”'c&Gy2Öfõ…[mA“xÑ,œ'~Äô¨€´iZŒäß‰‰à×qÙÒş½ˆˆ¼	p¡A±wts­¡ƒvÃÏÎÉ¿BŸq0™z|ä”=†,V‰´eüµş. ^*©ğ¿Í~á·`ÆÅ'wËP^oõ£ã8¿ÄKi+'VšÉ	IÆÂäˆ$oG{^—k9ŠyòìÇ–-ˆZÆw²i¯Äšá8²òQÇ÷%&2	Q@µu.Iâ-$Ù]ÈG1LGD¼	kğ[=õ%aP’j¥rk¿ƒ\ Š<‡Ïa ùR3acz–°ÖÖE TXÈ1ù ±À÷/—ÄÖêŞFäK’gê%?+d—¶°0Ã`ß@<ãpñ¯²GÊÍÛ—ç¦JeBZÜÅÆ:×´p†ÄòH2+%/êbùÕbK»X±Çx±–EhÈ\álï^>¾ßÀøÜßÇçod›«³õ`ı¿æ”Y¬.iËöÿh˜[Õa>ßs˜±0ˆÿm˜Ã‡YæÃ¼³åu‰•ãĞÊ‡Ø0gE‡D`6´|˜‰¼WØØqÆá´˜xuR5ëí¹Tøáè o!¬]„õÌ1¿c|x4åÿGc|hP1À”c¬ÁöšZ†@æİˆXËqÇ)2ñc&>£	G“Õß‰Û'Iù@>ñò‰ÿ	ÓLâ%˜ø‘á­õÅÉn ûIö<|ëÊ~Ü¯äİAÂÖ_³…O$ƒ%6çB	â.uZç`çŸ$Œ@W
6‚_·7ğ^ ¡utµw»£½ûŠ=0‰ÓÊ–€1˜!³yz‘w&ï'Ò)É8¤Á/ôkõÕï;``w3úÍÆ5G³T~+f”çè[p?˜”³Ú#í@ûæê#$‹Æ_ÄË1dzù
2ıƒJ¦¿QÉ´©Ä@ŞÃ™ÿs>òä[yÊ³ÒÁ=ÿe·Á¯FüT¯¼J˜°PI¨jF”ªdNUâ.gï q&êP_gÅ4`7}$…Q•]%·9İäã`(|¯uäç: Å/Gd“ãÑNœ¥çtÇÈ–æ¦/«=0)”“X´‡L0`­x˜Nç·À¥TŞı<O/G·ÒbøºUFïu­,şA/lÖıƒ!ÄaÇ¹üÒP ›&p8PÄõÂVôD„°lÖ7Lş(&›ü¶-›Š±ÖM	/²i€nÏ¸Ü¸¨_ı$9ˆ9ü
>•‘üÕamfµl7¨ö^Ã1Mg-	OcX»Êş@‘­íÜ¹ÛoJåì‡xR—C8öãw~=)ô‘´‘õ‘Âk¿'R©Şú4ss¿’`´S#,\íÚ¿öçïa(¢ejş–zãô1·éÿ[Œ…ft_)'†K¬¿šÊŞ4]l+dt0\eÖ—0‹pŠ°I¬QòÖ6`-OXf.ÃazY8É¿‘Œ½CÚ‚Ã€8ôÃıu ¹|X:ˆ:™lzƒ”ÇØ0ífô#Œq|gõŸC;€åûñƒìÑóZê…-ˆBh,Âğ“yY”µœ™Á¸Xâ+p‹;å SúŒ5œTı€¡ML¿êÜ…ğŒµĞSúr–•g€xö^/¹D`«_ØÉli^,±–£Çd¼•§Á`S—Á¨µ+Zm¬è eF¨•a,Y›	ë©Ç·VÿİLn‰N?,¥‘gmŒFöê¡_!l¦epu‹ı¶ú7#‘ñ™ı›‚×¨§È{`Æ Yáø>ßßĞä^	²{G,´k9´[¡MÀUáFu¸ÉÚò’I¥Ì?š4¢‚ŠÕéÿ¬	ÂãvçN™ehZ*QÎ ß9º@”ÖòL±D)ÎÃ·»ûbçÕLä1Èe4q·
Æõ\fßs™g7G¹Ì¾ËeÆ<{5.c}š©-§íVäĞj·¶”hçIÆó¶–ÿ‚1Œàô}>:}‘¥³é‹?´éû|dúŞ)Çzêïøtp#“
Km¢_]J¸ôêÁ}TÜTeäÖ¾*÷±–#+`ˆÔÇ úwı‹¨µ<j
}ä` ®Â<°€Æ<6E˜f–ä½æÁâÿ5óxş?cˆB”yìü/˜ÇN6§7iÌãù+˜ÇÎ(óØùï˜G¢ş¿gÄ0½½™S£b™‡:ÄwY"Ìƒ¿°áúH£y>¡¬ş7Ù­öñ)ö&1è„ŞÊ­YËñ²/Ì‹æNq#E#‰Z•$+Èã’ã[ ^Å·>B¹%T-œSmh™=à<>£¶á™$•%µÜ®0]s%U
YYqN1ø©wñŸñâä nQN•Ø˜Şå¯÷­F?²¤œÑ¥7ñÎO‘STÉzpª‹Â'#mWÖ|3y0(%ı ïù
RmËu?Ñ–C‰™nYc¿lJÒo[ğ,@ÇuÌ/8Ó¶äÕzÎk&¨(Ã`Öë¤WûŒ©v~êMÄ¾rØK÷8	Ÿp„¡óEl‰:?Ê\C3cfò¾—<èÇÅËÓ\œ`ÊÌ*8J<•ïÌH3LD®`x®Id´ëWŒuÄ™6×\i A£¿œQæq´©ÔÆ:[ö÷Ø–a—½¥;ò{Š¶Pçƒ¶}i[v”°¬=	ë§ãÖ>ÜùTÏ¡XNÙék…×¼$ã˜ıdç~ÔwËe:¯4V¤Üş3tÂDÅ‹}@òô)4~ËûÁ±¿‚M§ñ€ Z7¹¡ØV—h(6c`)ÖaW®Eó”iy4çíìõú²ƒ>dh0$Yöãæš›šoÑî¥ÑásùaŠv
»KÂ÷æ™ºM›&ŒBkæ¢9
óÔğ³u‘Ûı»…dúíL<c>'ùë×Œv$ûêûÚJÒHPüdz0ÿp}&1ù×àM„³ÍcÅæì¢Ã´:Rˆ$Tc|‹¢ôşŠYNµ8âö¾6_‚›VãÙqÍ·WMi[ÅRRqûÔ”s<%ÕW¥¦å)i¸j5å-’îˆ¨)»yÊhGÜ»jÊoyÊ$G\£šRÎS¦8âÎ¨)+yJ¶#®YMYÊSf;âÎ«)xÊ\GUS¦ğ”ù¸V5åLY¬½ßQÏ‰SñÜÆ^ï)@ÏãETrµf‘=hónpÁ}fÁ
jˆ+üÎv¨¤åvĞV¼n¯æàcÏ6¯Nºè)ù;p#0»¥óàÅ‹‘˜'yJÃô55"ôñĞ— R:%¾½‡ÙF-Ê –h[¯•h§¥‘ı=tŞµw†İô!VôaEå‹Û;°@F³ŠĞÿãÙTÒ&m”ëM)ÀäıÌ6ûÅ@ŠÛ;HËıb49Õí¬%?=şİê—4ÉÙæö¦j½Ñ2én¯[KÎ‹&v{sµä)Ñä±nïP–ZÛ˜Æ¹½C´/IÑ7¸½wkÉí7F’3ÜŞ|-ùl4ùF·×£%×Ü[ıx··@û²'Zà&·÷.-yK4ùf·7OK^M„ì50#•õ¨~Š:ÜÔ-­õ3$ßM­õ3$ˆ&ÏÕº’Í=ªŸ¯õ&|ù:¿¤$ÕøÆ‘¢®<:y;]X¢ÒÅÏØv7Í)agZVâ#ùü6Ò?d­4LÉ\k›’µŞrcf…afÙdotè«)¡|ÇL_É«ôeÓt¾/Bß’Ò.FèŞ”Âïw±‚ßbºfR<V‰çI$›Ù8P›¥³ö;SÊÉÔ~OD7ˆÎ°do¬D,ggı>c›b&óÖ‚à.Ö)mÖ ^¨üËPiåE)YK7@ü
ÏZZùÛXRbYb-qşå+D{„ÛÕ)>g%›ô&GÜN5åVbvÄíVSFñ”LG\ƒšÒ§LtÄ½¯¦(¿ŒeWò‹ ğ`ÎÖ,q/gâÎ,Ğ?%g¼¨Ö‘ãu{$¡¦¬½ÀülãÍÚRÓ²sÖ&˜ñØİ^}ïi´Ù•IÓµˆB!p•~
0™_@Ì(ÌnÉÁiYoïe¬=Ç@ÁYA(ÖFj1XÁ±÷W]Ò4 !Âò{û2–ğÒ¸§01NaeÉd\„&Ín¯­€İ›aSù—Ñ/™n¨D¥É{ÆÅRëD7Ô£~É§QëDŞ…ÂİÕ®bd'^w…séV0š-,	$¿=B©¥>¬QªĞJJÛ€ ¡ î´ê-%±ìßĞP6T­ÒÔ­+zÒRYoZ‚‰°¥çDx&‚ĞµQŠß„ä¾c7Í;X˜¹ã}Nl¹O‰Üv´ ës–4O‘ºŒcbĞl18j†î<5ªÉgSn£zì‚2G^e*t\Úb¯¦àîem:¨b/nLx˜§±VšóZ,p™í§½¤KaÀzîÁcİüöP>$îô&, ät’K²éM´¡$;[=8t®Ç»ß]Iø ·æ¢lª¶îö(Br`†-}…OqûØ;VràH®ŠùLJÃq˜¹m+~]È¾ dóÔ.«¿˜Yî5{'-Å¬]µÎvs	Ô ÖXÔò <õzF¢I #C“
±+®¼¬Öë°%aşi_O'®‹¢!L9*& Za@ä§píãöÕÀî`ùå§gÉã´äJ5y¾>šj/Q“İúhnH^t§~ø²Õ3B«g¦Z`'KN×’3Ôd|é.6Ú`ŒÕ/ıÔ/{Ø—>ÚCc"@îÖs (‰ZAşáeê£@ «5y‘¾ø²‡U5%é0ŞZ²8»7#µ–ãØz<ô&´Ş““æE^É~NòZ`¬ØÏbü™Œ?Y§bÅ
.E0Û-uÀ¼;€í¦ÙOl+ıü”ŸÚÇjwÓ\¢<Õ Æ1‹t³å§ğ¨	ë~}NÓóØYl¾CÚÂ aGĞÅ¬zl<Íc?±Át.û‰s„N}áØ(Øà2‹ÛÇ<A$¼®³…\Å²·¦ô—«´{™hƒ¹ëáJhh‡ŞÛÅ=8¡"v8™‡~Ÿ
ñ-ó¯®ö)ä¬x–M`²òR- ‘"±ŸÀµ£àpŸÄ{—ÁåYı|™Ì'àÒ‰¦­†Yß°Iù]äÔò¬ü.ß@±Æ`}cĞrÿIávÜ‹^Â?X’\|"ÜÃi½ª[eöİH¨l9†N'ZßH%.wœòƒPQ?¬¨ª±×C^á£XÓ¹Z÷ö2¼SÆïÆ+¹ùîÌxPOaæ·×M‘eüR çìŠf<ªV¸ ró‚n˜-¨Ôæƒ¾7O³Ïe[¢^,ëïàk¡üşamä-cŸöÓ@â÷¾RQ—ü8Ú§2Yî8,td·Ÿ>qQ¼h$LÖÍ‡¥Å¶ègg`pÜ`ß­›RúÉM~‹DZHì§%%/Ïk,Îü ÑFëjC-0w¬[Yßú¤õ×‘ğÃŒ;]‚QZlU5z Ö«¨ØL„:’Ce Ó›m œŞ0;rÌ&­òo?'ıõÜ$õÖ¡bxÆÊxø{Ïª>b`{%mœú”ŠUHÔ±ëe4é›MïB–ıkq³İdÁƒMÃê7|×¦(‚`
¹´µ–mµõ¹6gavK^`ãÜÊª»éÅçğƒôÂ…¿3¶úÑy­7[ÍBr–"c€
ãôPŸ»€>Ïë3_»xaË·Ìî™Z››¾ü¯EplX°Ğ„‡Ç˜;¥à¥*İüknÄÚ „–uä,4K²/Bïñ‹bjÿ|w‡º$.XhèY·ogè{(©ÆĞû2^A
Ùô=³YËÑ©Uè’³PµâZË£¶`)‡ÕÙäÍÆNÄ6»7õ¼ÿTÃZ$-^ˆ‹¿Ûõ=ş—­Z÷€Ğx¼áA<³/õİ½á²É³Pş-6zyÖP~à˜Fí²áßf¼§v7ÿ.zrÖ5åÕŒÁ°-…Ü‡Áî)%ÜW¯Á±`‘PT@ñ”Gc4Yì¶Ÿ”çAV£xØ€¾Ú/ ÖM'.Ó¥hÆºo1"b8ÚË³ÂWbh-¿û/d?}e«„¡WËËı¤†Î±Y¯fHéûÛø>‹ß°b³Ù©Ò{ûUèıÑ)œŞÑ“°wĞûRNïFïêHu½ËF*é=äá™Ù %ÿN¥ÎÛÈñ<ûéŸ¤Ì¼£B2İÓ­	™½šğÆêØ‡aÜxİÎ=.dé­åxßø÷läÄr2y¹cš0œ1ñåä	ÀbA°â5€$
çHC(nØIñˆŞÒ·äGbK¥a©´H©äH)_BèŒfÿo$*] *YŠ“tºô8dÔnzî03÷–Tèö\:ôIè¦hV“-’õ¯,+»8œÌÜ¼	ñÊÀùwYm=Œş¦ö(°0èãöz¨CJñö4Ìù‚æ‡![ßNŒ5-€6‹ì'fÚÇšyĞì¹²iÚs‡ê¥'.?üEru)Íè}-“NÛ¼½ô$«âB•÷/m’9”øxœ\¢„Œò“zG÷º}÷Úş“K€u/1ı ò”›Ü©°}!É–W¨âLZ`^.™åuhÀ\fKi¸”€²·wPñ¦ÿc°Ñ;¸ÇCX5Ç{ğËÂ2$Ğ¡Ñ#}å"îÀfå˜…[<Şìbú"Já… W†“{½‡— xEÁBŸäs!VhW²Ö™­åœ"Î3è¿]¸ÒoãK>4»¡›ş€KÃ/Ùïöû4³ˆRãV¦±g-ÖòzfèA¤Lf{[»VÙ%oK×sg Æ˜¹àíÚd •İ›ŸGïœaÑ"“Å8×òèÿÙƒ¼Ø†İ”WŒ2G~:]u(á_ïô.É£óªõÜªG_ïMytªóôfçy´3y!ŞÄˆÙO}1…9¿P-Ê¨ÂZÛ]ãc,cÓözó¾`£7NB°tR5 ‡"|Şƒ¤­³Iã,šu«BÔÃÀãíØk²Cv©”ÜM«~­2•íãr§h5I«ÍÒjIˆåìåâ´Ûª¢Jw; Õ`WÈwË¿4ÄêZÇTÃ‹o“‹—cæƒª	§¹CgÒ¤ˆÒ‰ô<ëjƒ%$(0 ®ªÁw3%féŸÇFuœ¥%&_BòÎßqEX|ŒjÎ"ëªViDTùAÔöŞöÓ¨q¼PÎ"Ğ‘ ŸÄÕšÚK»úÏ´*•>º®F–Û}Äİ¥†ÿ†>’ÄëñªXËûL?ˆPÉ¯7áiz âvsı¯à<Z£æ ³zkY‘
}¯Ejqsf´–´ÁŠÚXèÁƒp¿øä"o¦R²(&÷mšº4N´€É<w¬!X³¢‚uÌ[$ŒÀÊ†’Á‡ôÂ µ«*”ä4'ÄèKL{™·”}iMo})Ú!	RBKˆèDó?«6£xƒ•éIƒ³f-õÙT…bpÖSº_ËšµÈBœg$¿	MıöÂ\ÆDıĞ¯ŞCÔ×l¾P3ãm¡×áß.{  YXãÄDºQQ`?ç¡«"åûòòYKP‹¿ê4¾í¦ÓøGøMµÑÓ~{”v1¢·´7=]½û¿¹?ç¹Î‰Ø¤[¡İ¡Qâ“Ku‚ÑÀø˜¬×hYSÑàüsš™P•=™Ø ^Ñ®Åã{´öØ;¬o$.÷×û²
¼qKäÛä»?­6o6¡æ¾há	âñ‚”?õb°!ø…Éø-/'Å÷ƒ1+c®½Õ‹~ó¿Õ‹ŠşzQzO½ˆù R'Û8ÔŠnÍ¥·=ZÑ=µ¢˜Œÿ^'b~]—;*tçm¾dtñNYù³ıŠk?‹e¨%Áv›Ébo2š,6›ù³ª P2F0“0ƒM¹7|‚`ŠağÒ7Ô£ÜHd:„.ßX|`åIV»å0¿ã™Ë èø«İßè¦]B¿Æ\6;Oæÿ» mMMÃQÑBı'”‡["ZV#QPj5jTKôsëß¢n,¸Ì×ZÄ É$.›¤ß«}y¥bˆ;¦¤ÈÆæ„ä¤tW&>…tË¥m’³Õxùå—é¯!IvµÙOJ8MägØ,g«”)¯1IV ¾¸“2tGë‰¶‚¹n®…Md;­¨ˆ”òÛîÿby–Í÷s’€N¼ğgÚÁ¢¡’Õ‡ıô¢ùÒ6]¡Õ;;èxÊÛ
u2%­™û+.JšÂ«™¤Vó›h5£.2"a€ú! K¾õ·Ğ€Zgî§p³1üqªAÆo§+ÌX×SÈt:ÏëÕæ¡ÿèÒô=ß?¸®çû;×ó|cu<ßkh/£[…èvâ¤ªºçl…u$×æ!mô«Ó¾Å(‹LåÂÔsoâæASéX=UÕñn¶«À`7Óì˜Fíó­ø55‚Xçzh{¢¦©µà“Tô<X{‹
zØ<=x1şá@¦Ñ$ãÙ54áA¨,Æ1óÕ²LÊdá\èõ!Ç­ì@éÆ2JüÃ™ÄtËtÌ6Õûf‹k©Šo*}y8»#Œ²2Ú|)è® şÜŞöÙí½2º½Ê@ª¼q>E´xTäL}pĞEº”1Çw±[H/=Í>ÒI‘ü¡Yşú5×«÷#®<¸ï˜m,ãÉlsjÑaú–Z><2oÚÏ5GQWÂëR˜KÜÁ7wâ„.”Wè×@§Bm˜›QòDmô,ÚŞ¡,îáÄÄ®¼ı{ò×.…eÓˆZgW>Äqâ×¸è±Drµ‘‰ÿÈlÁ‡Öfï=ÇĞÉï„^N~BÒÀ|çörò[cí‚Î]Œ9n¹£ÁwB•¶“¢0|¶¾q2£Á7Âòq³\¨ ¡xùq=àâ¸l}æ1…µ5”@Lÿ˜àU5ŸéóÕ¶™è—B´Ù_á/ÑÆåÛH’:İûÇ7sÍ~„¶8!|Â0„¸ö6½c°á™ÂãèSÂB8Â“N„­NgCø&Ú‚İÉ.„ğ„Bˆ¾¬W@xmtBø7+ DÿíÕú™Şq¼ ¾Â‡ñ]o5·ú.ÄÀğÅíãˆÏF[¢–â@Cˆ>¨ÂwôG¡û›ÁæÄvAíY >ıQCø4–{›Ûñ¹hƒâè;â/A8B¼–4Â; ¼Â¿¢MR_F¼ _pn>q¼Ô
åÑÎÛZˆß‰í8ú¯€ø±]şÂíâÁÅqUYá¯±]¾…í‚/÷İ)„x®B<Ğ¶yØØq+«à!Á†ø	l„g±¢³½¹Áv@ˆWÚ–Bˆ×ãmS¯p'{`°¡Z½	ÂÑF*„¨Xì†°ÛáÛˆ„èëû(„øò¢B\7Ÿ‡¯"¶AØ„xAXƒí«æ¶SÍ ë/Ãtˆ£‰ˆˆ£¯Ù3ÕÜ†j:Ä‹‘Ş ~Éo„ø|¤7èoôÑ1	â%ØşjnÓu6Äñ£BT
AˆwÕ‹!tAèƒğ ¾;ƒ·ÿ‡z¦¡-Xˆãfğƒ¿Â­_øTs›±;!¾ û¾£‰…½÷a}ÕÜFl5ÄÑ¤k„÷ ~6jß‡8ºn…øXœO÷âxCœÙ¸…ø}Xo5·m†8úv¿âhÛÖtÈ`Ã.„¹8¯ª¹­Û4ˆ£ï÷Àg<Î;ˆ£O÷‰G£®!¾éâ“qB-O©æ¶mwBútœ—.a?Aˆ>ä§@ú-Ø_ñ¯æ6m}Ç·šÛº-ƒørì7Ñ"‹	Ê¡YÅ­G_ó;!ÄmÍïüöB×åw`Aõ„!•ë nOŞ‡p5ö„ö„ÈNgWs[¾aˆã³8Óaƒínìq=¿šÛ
Nƒ8ºˆ^õŞ†ıñuHçğmO„¸¿WsÛ¿Ù/ÀòâiÇBÑB1„Ûp@ˆÇpVsÀ_ˆó¤šÛŞñBì€7ç3ÄÑ|Éñrh„«Ş!Äó¬µÕÜÆpÄïÅ~¨æ¶„Ï@´RñéDB4jf~×`Ã¥TñôXÑdü$k±?¡<ÚNñE8GwCüâ	áAÌ = deleteBuffer;
    this.insertBuffer = insertBuffer;
    this.lines = [];
  }
  pushDiffCommonLine(diff) {
    this.lines.push(diff);
  }
  pushDiffChangeLines(diff) {
    const isDiffEmpty = diff[1].length === 0;
    if (!isDiffEmpty || this.deleteBuffer.isLineEmpty())
      this.deleteBuffer.pushDiff(diff);
    if (!isDiffEmpty || this.insertBuffer.isLineEmpty())
      this.insertBuffer.pushDiff(diff);
  }
  flushChangeLines() {
    this.deleteBuffer.moveLinesTo(this.lines);
    this.insertBuffer.moveLinesTo(this.lines);
  }
  // Input to buffer.
  align(diff) {
    const op = diff[0];
    const string = diff[1];
    if (string.includes("\n")) {
      const substrings = string.split("\n");
      const iLast = substrings.length - 1;
      substrings.forEach((substring, i) => {
        if (i === 0) {
          const subdiff = new Diff(op, substring);
          if (this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty()) {
            this.flushChangeLines();
            this.pushDiffCommonLine(subdiff);
          } else {
            this.pushDiffChangeLines(subdiff);
            this.flushChangeLines();
          }
        } else if (i < iLast) {
          this.pushDiffCommonLine(new Diff(op, substring));
        } else if (substring.length !== 0) {
          this.pushDiffChangeLines(new Diff(op, substring));
        }
      });
    } else {
      this.pushDiffChangeLines(diff);
    }
  }
  // Output from buffer.
  getLines() {
    this.flushChangeLines();
    return this.lines;
  }
}
function getAlignedDiffs(diffs, changeColor) {
  const deleteBuffer = new ChangeBuffer(DIFF_DELETE, changeColor);
  const insertBuffer = new ChangeBuffer(DIFF_INSERT, changeColor);
  const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);
  diffs.forEach((diff) => {
    switch (diff[0]) {
      case DIFF_DELETE:
        deleteBuffer.align(diff);
        break;
      case DIFF_INSERT:
        insertBuffer.align(diff);
        break;
      default:
        commonBuffer.align(diff);
    }
  });
  return commonBuffer.getLines();
}

function hasCommonDiff(diffs, isMultiline) {
  if (isMultiline) {
    const iLast = diffs.length - 1;
    return diffs.some(
      (diff, i) => diff[0] === DIFF_EQUAL && (i !== iLast || diff[1] !== "\n")
    );
  }
  return diffs.some((diff) => diff[0] === DIFF_EQUAL);
}
function diffStringsUnified(a, b, options) {
  if (a !== b && a.length !== 0 && b.length !== 0) {
    const isMultiline = a.includes("\n") || b.includes("\n");
    const [diffs, truncated] = diffStringsRaw(
      isMultiline ? `${a}
` : a,
      isMultiline ? `${b}
` : b,
      true,
      // cleanupSemantic
      options
    );
    if (hasCommonDiff(diffs, isMultiline)) {
      const optionsNormalized = normalizeDiffOptions(options);
      const lines = getAlignedDiffs(diffs, optionsNormalized.changeColor);
      return printDiffLines(lines, truncated, optionsNormalized);
    }
  }
  return diffLinesUnified(a.split("\n"), b.split("\n"), options);
}
function diffStringsRaw(a, b, cleanup, options) {
  const [diffs, truncated] = diffStrings(a, b, options);
  if (cleanup)
    diff_cleanupSemantic(diffs);
  return [diffs, truncated];
}

function getCommonMessage(message, options) {
  const { commonColor } = normalizeDiffOptions(options);
  return commonColor(message);
}
const {
  AsymmetricMatcher,
  DOMCollection,
  DOMElement,
  Immutable,
  ReactElement,
  ReactTestComponent
} = plugins;
const PLUGINS = [
  ReactTestComponent,
  ReactElement,
  DOMElement,
  DOMCollection,
  Immutable,
  AsymmetricMatcher
];
const FORMAT_OPTIONS = {
  plugins: PLUGINS
};
const FALLBACK_FORMAT_OPTIONS = {
  callToJSON: false,
  maxDepth: 10,
  plugins: PLUGINS
};
function diff(a, b, options) {
  if (Object.is(a, b))
    return "";
  const aType = getType(a);
  let expectedType = aType;
  let omitDifference = false;
  if (aType === "object" && typeof a.asymmetricMatch === "function") {
    if (a.$$typeof !== Symbol.for("jest.asymmetricMatcher")) {
      return null;
    }
    if (typeof a.getExpectedType !== "function") {
      return null;
    í÷Àk"¡e.4TÉIKƒs‘ŠN&R…©êêE’wì´{óv¦HÖŸıˆ'ègL?:ıĞŠô#`ıH:xú‘´ıúäé'Ç\´=SÏá±Bò…Wú®ä{#¨~pÎptßÊ•V=¥2y£üãOg*å¾åî3ö#–g´Ùyz¿X)íê¬–H$âî93È¿LNL­F)&´s
@Íq˜”o²ğ;+R|\ƒ‘0-yíE‰ªÓÊ¨±±pÚÅ¦ÂR…o×›6mÃ¥kœªrŠ˜Ú¹s³w²×Ïı»®Z=—:9³:qL¾û„€+Wº™Ö¿‚ãÎŒ_ÆñÎ˜¼<?î«>ğÿlüé?‹Wˆ|¿¤#5?+êİ=§§EÜ/KpG>±XÊv†ººë±wÄòs>›üÕEŸ»ã·ëPü\Ûg£_3¥ƒƒ7Ğ¢Ÿò–dŞ„ùóOÌÉ´ìv)bí¡ø7¨åk"s¸Ño	5?U‹9êLÍ¢„ÿÚ³”Ë´ÿ|:³h²Å?Iï-ä‹NSC7:¸—7„œ*Ï8¡‡¢n²ÒJ‹T‰T47%W•¢krìÃĞ''I;lï¶'óæÖ“š2NÊp9Ş/pËhX=ÒpØê>.ä†Âw$İ@<[jXşü[ä…ûÚñæRkí‘ÃE;¤úe×]d¦³~À'™|Ò`~áı–™çmÔÑté@l8º¿3¦N1£HDúÜ¢¦å¹eóv[	Ï§SJ^L™EÛ½Qnßì¶'Ü¹z{Ä3~›Ğeºˆd‘êô„ˆğfÙIÄ„AËÓK¤••…%¤»3Š%·³v—<¦¢älß™zí|‚×º#94ø®IÕîâö¤ú=\¢ÒÒH0¶O+fd¦ø½Z~ˆLRƒi²dQŞéÒ¿¿†‰ähb’_‹1ĞE±{¢c‰XO>¥O2H.½ÔÈAº¾0»¶Ú„vÆ0Ñ›cşÇÇÈô†õ› ÆDs3t ˆŸ¹-Mµe ´˜ÂYø¡I³wÜPLZu¶ãÚ¿üMÚÇÔM›Û«´íN<¾Æåğ³ë‡˜£·×‹¿ »q¾H®ôğïL•ìƒË[ec¹hv|ŠÖe½Ê§-i!	íZÜ_]öXGåİåğrÚr™şŸëQ× Õ3­®§®I~ËÁüå8ªLßqgÿ)g:G<:åÚ¢f~"jsÊË‚;QÊÒÃîˆ¦*ï†5ËJ˜Ğôá&ÑYH¥ÀHOi½ÈııVıNYvJOdR)`ÚšpØğ]ÖR–$+7%†SÒœãÑ²|rê¹Ş.ÓŞüGÄŠÃàímÓËºwTT6ü¼d1CfÛ³ó»=Ğ>_±'= xlyXÁc˜ïN¹Ì¸Kñ»ñrõaá;	êõ^¨?$/JIÛÚÆ‡ıèY~~ïQÉÓ&Ó·„#‰NÉÓîÚ"—ù´š´ëàïxjhÌ¹J”F‰˜şis¥*ê}ª“x´OÅ“Ò¹\;m?¸÷·4#ZÌˆ8ôD¯Tè½Æ8–£W(ôëoÆöŸËÊj‚Î%ğêÑ\ó÷ ¿B%IHaà¿Ê—Š«­â¥BÌË	[ŒáoRˆóº€¶ˆ‰‚€.'Òà·€Š
Gõj±Z\/D¬St‰>Ñ-zÅ~p/Á_;‡†ßa†a‹NüeERdÄ”H)?ƒnˆôíØğa‹¸ÇÙ	|ƒûÅø_òÈl#·‰Òøûñõ¨ œ8b.Q1b¤©±§ñ?¥ŠòE6ùİ RÃÿôƒ
HG)mÏü†Ò&¦_wæ"îÏå(eæ¡„ƒ¢È%wfŒJ~©
'RšÅ‘ïN|KU×Ï|ÜÃ*–K¼ì!sœ}¼ª8¬<ÂwøûHQH/å~´WØ5åB6vŠ}Øª°[ÄRLåÑÂM3Á_øcPyØJM„J:ŸdR>sğGµáğRğ±¥IMšÊÃ‰jrb}uél"3ß˜Ã©f—‚Ÿ|g[µœ­*¥ƒãºJq.{à×Aº¨Ş8…q®‡‹Q‚6¸)6)ı‹5HwşDÅâÅ	Zå¢À)ëãœsè¦ŸòƒsÅŠçú^,*Ëİß¡Ú˜îæ;¹ì‹ËO·"³>2ÜÊ²Œ-0£Š¯êãÙuFá~rì.Ûd§A· QİƒRéÃøF~;¬Z…µ¦,o3=âü)!ÿ¿_ö ãÜZváÿa„œRWœ?W‹hfúÄŠbwİ2vs­!Æ¥s…$–tq>¨=õÁ-Á6Gˆú	±å•E\6÷K1Oç·>ÁmEÊ*s1ïbn|!È’pûÎ‚ÜoF¸¶ ´ë‡Ñ£‡ºİh	»Qkbúş!DœàÎ*›˜®4J°.1>‡&2 d¬Ù­s\‘1Ÿ(eÿ-œDÏ¿®ä<I})Ö³ĞŠàÿ2_Ä¸ÁÈ.¿ÕÍX`úƒ/<ÙTîñç™äÖ’Ÿ,¡fRÅôÌé&õëÍ€8„Fåuª}Ê@”“AM&ÆSw›V!{J„‘¨/-b‰Ìê%*á—¨n$.-nº-Üü“LÅáf³@MƒÊ»×a'†ÚUÛÃéR§s×§ôèÑ³…KÀÄ¤ëµªlZ¸k›¸Ækyö)†î	 )„Süù”BÌöDĞT»*É‡‘ãØc<<æ¸ãÑW	ö£;w‹(-#
Zy˜õBŒ¹_n5£>ß7ÿSwvpêäpìéå\~½FkNf81_»láËl•—¸ı˜ÜL~‰8Wµs…XN®¦¸”®«¥koi,ZÌßIb»Ô!âR‹œàÚ™+q©ÔZe+µ¹>.V Æu2w
Ä9'ËÜçyŒ@xáq¹ë˜+¤	®Ã83ÙòçÌõĞ±9éTî˜ Ÿg´4i<ÉpÍ:p:1¸¥™OòçäıÅünîáW‰K:T/¦tnÄAj­ˆ(ù6ÁåaÃ¥Tö]=§Âu5rµ±@½ZDª’T©•vÂ=‡V;€^´iİ‹á 1>ßğşö1€t‹ÍR	 ’¼ÒÜ,‰+U($½¦±y®8hˆÏ°,î7Ú©WÀ\­O…YÚÎù£>C’`ˆS@“Q­i1=ÛSF›+­Hfçv™!®ÕÖÕdËùéç†˜a‘+…˜hŸ«Q”~ßÉ_Ä¸@½Ptœz;ø[›‡šÒ¹úÜùPîæá&Íº|qÄJÏßn`9]Oœã÷SÆÅ{Q×7gl4käÙÈúœb™¯¤8Å”n,wêY[é¬Ğ2Äô£ÿ¿EÇI¦qî!ÏÇßdFq3!©¯ˆ¤Y®Úz”ŒTjüysûä¸¸jI_r%«²¸‡9ç1Y¨µ®-)ÄEşRØÁeBU9hÖ»Yš“”’ã¦hë0&Â“ªÉĞÄ-ªLVM´|K=éS”²Eeì<¯I‰ó(æÃJ6ÉúJñt.mv—³K}¹’g¥ß­lŒ+ü~úŸ¦cZš¥£ß]òÅUäk€ËN¯R"œ,¥ve±/Zpá:p§¾µæ„XTö"bI¯Ò[s¾I´XÚkŒš>—Ú~ÊJ1$j¸¼dÍ‰³çn¿b­D-dfûîÓ-´:©‡Ø,%úş"Á1há¡G»bÔSl#ŞõŞ(ÑÍQ-gŒCÊs­™'‹ìµåÛoÊJj-e¾ÙÙÅ3½D¡Û•;9´ıçÏur`–/ÂYiÖŞ k'9€ŞÒˆ¨vkuiùöë¸šFiË¦õÏr‹<˜¤ŸSÚNiä>ÈiF˜ËOæ.j_	-dX+Ö‰Uj‰Á+CÙ÷;y|—@,)¿ğ#Î~)ë@9k‘­àjJaã5 è¦…‡bI­<·‰R+Wdá¯±”+øëZÓ.-;-ğ×±¨|%åtúÑ‹Å™R.u×3ÜPÒ¼zv¸h˜‰•|çWîıİÏ6º×ÅàÇ•ºrœ;S’'ê­È5ˆğú.ÕA§Tbúçÿû²iQOv:*œ<ç&if½VÎÔ2Hvè)ÅôÿwCÊèd	·9ë¡4é.y¸Ù¯neî²úØÿ®¬ÆT¨¶’