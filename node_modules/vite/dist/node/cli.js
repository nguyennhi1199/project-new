import path from 'node:path';
import fs from 'node:fs';
import { performance } from 'node:perf_hooks';
import { EventEmitter } from 'events';
import { A as colors, v as createLogger, r as resolveConfig } from './chunks/dep-BKbDVx1T.js';
import { VERSION } from './constants.js';
import 'node:fs/promises';
import 'node:url';
import 'node:util';
import 'node:module';
import 'tty';
import 'path';
import 'esbuild';
import 'fs';
import 'assert';
import 'node:child_process';
import 'node:http';
import 'node:https';
import 'util';
import 'net';
import 'url';
import 'http';
import 'stream';
import 'os';
import 'child_process';
import 'node:os';
import 'node:crypto';
import 'node:dns';
import 'crypto';
import 'module';
import 'node:assert';
import 'node:v8';
import 'node:worker_threads';
import 'node:buffer';
import 'node:events';
import 'rollup/parseAst';
import 'querystring';
import 'node:readline';
import 'zlib';
import 'buffer';
import 'https';
import 'tls';
import 'node:zlib';

function toArr(any) {
	return any == null ? [] : Array.isArray(any) ? any : [any];
}

function toVal(out, key, val, opts) {
	var x, old=out[key], nxt=(
		!!~opts.string.indexOf(key) ? (val == null || val === true ? '' : String(val))
		: typeof val === 'boolean' ? val
		: !!~opts.boolean.indexOf(key) ? (val === 'false' ? false : val === 'true' || (out._.push((x = +val,x * 0 === 0) ? x : val),!!val))
		: (x = +val,x * 0 === 0) ? x : val
	);
	out[key] = old == null ? nxt : (Array.isArray(old) ? old.concat(nxt) : [old, nxt]);
}

function mri2 (args, opts) {
	args = args || [];
	opts = opts || {};

	var k, arr, arg, name, val, out={ _:[] };
	var i=0, j=0, idx=0, len=args.length;

	const alibi = opts.alias !== void 0;
	const strict = opts.unknown !== void 0;
	const defaults = opts.default !== void 0;

	opts.alias = opts.alias || {};
	opts.string = toArr(opts.string);
	opts.boolean = toArr(opts.boolean);

	if (alibi) {
		for (k in opts.alias) {
			arr = opts.alias[k] = toArr(opts.alias[k]);
			for (i=0; i < arr.length; i++) {
				(opts.alias[arr[i]] = arr.concat(k)).splice(i, 1);
			}
		}
	}

	for (i=opts.boolean.length; i-- > 0;) {
		arr = opts.alias[opts.boolean[i]] || [];
		for (j=arr.length; j-- > 0;) opts.boolean.push(arr[j]);
	}

	for (i=opts.string.length; i-- > 0;) {
		arr = opts.alias[opts.string[i]] || [];
		for (j=arr.length; j-- > 0;) opts.string.push(arr[j]);
	}

	if (defaults) {
		for (k in opts.default) {
			name = typeof opts.default[k];
			arr = opts.alias[k] = opts.alias[k] || [];
			if (opts[name] !== void 0) {
				opts[name].push(k);
				for (i=0; i < arr.length; i++) {
					opts[name].push(arr[i]);
				}
			}
		}
	}

	const keys = strict ? Object.keys(opts.alias) : [];

	for (i=0; i < len; i++) {
		arg = args[i];

		if (arg === '--') {
			out._ = out._.concat(args.slice(++i));
			break;
		}

		for (j=0; j < arg.length; j++) {
			if (arg.charCodeAt(j) !== 45) break; // "-"
		}

		if (j === 0) {
			out._.push(arg);
		} else if (arg.substring(j, j + 3) === 'no-') {
			name = arg.substring(j + 3);
			if (strict && !~keys.indexOf(name)) {
				return opts.unknown(arg);
			}
			out[name] = false;
		} else {
			for (idx=j+1; idx < arg.length; idx++) {
				if (arg.charCodeAt(idx) === 61) break; // "="
			}

			name = arg.substring(j, idx);
			val = arg.substring(++idx) || (i+1 === len || (''+args[i+1]).charCodeAt(0) === 45 || args[++i]);
			arr = (j === 2 ? [name] : name);

			for (idx=0; idx < arr.length; idx++) {
				name = arr[idx];
				if (strict && !~keys.indexOf(name)) return opts.unknown('-'.repeat(j) + name);
				toVal(out, name, (idx + 1 < arr.length) || val, opts);
			}
		}
	}

	if (defaults) {
		for (k in opts.default) {
			if (out[k] === void 0) {
				out[k] = opts.default[k];
			}
		}
	}

	if (alibi) {
		for (k in out) {
			arr = opts.alias[k] || [];
			while (arr.length > 0) {
				out[arr.shift()] = out[k];
			}
		}
	}

	return out;
}

const removeBrackets = (v) => v.replace(/[<[].+/, "").trim();
const findAllBrackets = (v) => {
  const ANGLED_BRACKET_RE_GLOBAL = /<([^>]+)>/g;
  const SQUARE_BRACKET_RE_GLOBAL = /\[([^\]]+)\]/g;
  const res = [];
  const parse = (match) => {
    let variadic = false;
    let value = match[1];
    if (value.startsWith("...")) {
      value = value.slice(3);
      variadic = true;
    }
    return {
      required: match[0].startsWith("<"),
      value,
      variadic
    };
  };
  let angledMatch;
  while (angledMatch = ANGLED_BRACKET_RE_GLOBAL.exec(v)) {
    res.push(parse(angledMatch));
  }
  let squareMatch;
  while (squareMatch = SQUARE_BRACKET_RE_GLOBAL.exec(v)) {
    res.push(parse(squareMatch));
  }
  return res;
};
const getMriOptions = (options) => {
  const result = {alias: {}, boolean: []};
  for (const [index, option] of options.entries()) {
    if (option.names.length > 1) {
      result.alias[option.names[0]] = option.names.slice(1);
    }
    if (option.isBoolean) {
      if (option.negated) {
        const hasStringTypeOption = options.some((o, i) => {
          return i !== index && o.names.some((name) => option.names.includes(name)) && typeof o.required === "boolean";
        });
        if (!hasStringTypeOption) {
          result.boolean.push(option.names[0]);
        }
      } else {
        result.boolean.push(option.names[0]);
      }
    }
  }
  return result;
};
const findLongest = (arr) => {
  return arr.sort((a, b) => {
    return a.length > b.length ? -1 : 1;
  })[0];
};
const padRight = (str, length) => {
  return str.length >= length ? str : `${str}${" ".repeat(length - str.length)}`;
};
const camelcase = (input) => {
  return input.replace(/([a-z])-([a-z])/g, (_, p1, p2) => {
    return p1 + p2.toUpperCase();
  });
};
const setDotProp = (obj, keys, val) => {
  let i = 0;
  let length = keys.length;
  let t = obj;
  let x;
  for (; i < length; ++i) {
    x = t[keys[i]];
    t = t[keys[i]] = i === length - 1 ? val : x != null ? x : !!~keys[i + 1].indexOf(".") || !(+keys[i + 1] > -1) ? {} : [];
  }
};
const setByType = (obj, transforms) => {
  for (const key of Object.keys(transforms)) {
    const transform = transforms[key];
    if (transform.shouldTransform) {
      obj[key] = Array.prototype.concat.call([], obj[key]);
      if (typeof transform.transformFunction === "function") {
        obj[key] = obj[key].map(transform.transformFunction);
      }
    }
  }
};
const getFileName = (input) => {
  const m = /([^\\\/]+)$/.exec(input);
  return m ? m[1] : "";
};
const camelcaseOptionName = (name) => {
  return name.split(".").map((v, i) => {
    return i === 0 ? camelcase(v) : v;
  }).join(".");
};
class CACError extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(message).stack;
    }
  }
}

class Option {
  constructor(rawName, description, config) {
    this.rawName = rawName;
    this.description = description;
    this.config = Object.assign({}, config);
    rawName = rawName.replace(/\.\*/g, "");
    this.negated = false;
    this.names = removeBrackets(rawName).split(",").map((v) => {
      let name = v.trim().replace(/^-{1,2}/, "");
      if (name.startsWith("no-")) {
        this.negated = true;
        name = name.replace(/^no-/, "");
      }
      return camelcaseOptionName(name);
    }).sort((a, b) => a.length > b.length ? 1 : -1);
    this.name = this.names[this.names.length - 1];
    if (this.negated && this.config.default == null) {
      this.config.default = true;
    }
    if (rawName.includes("<")) {
      this.required = true;
    } else if (rawName.includes("[")) {
      this.required = false;
    } else {
      this.isBoolean = true;
    }
  }
}

const processArgs = process.argv;
const platformInfo = `${process.platform}-${process.arch} node-${process.version}`;

class Command {
  constructor(rawName, description, config = {}, cli) {
    this.rawName = rawName;
    this.description = description;
    this.config = config;
    this.cli = cli;
    this.options = [];
    this.aliasNames = [];
    this.name = removeBrackets(rawName);
    this.args = findAllBrackets(rawName);
    this.examples = [];
  }
  usage(text) {
    this.usageText = text;
    return this;
  }
  allowUnknownOptions() {
    this.config.allowUnknownOptions = true;
    return this;
  }
  ignoreOptionDefaultValue() {
    this.config.ignoreOptionDefaultValue = true;
    return this;
  }
  version(version, customFlags = "-v, --version") {
    this.versionNumber = version;
    this.option(customFlags, "Display version number");
    return this;
  }
  example(example) {
    this.examples.push(example);
    return this;
  }
  option(rawName, description, config) {
    const option = new Option(rawName, description, config);
    this.options.push(option);
    return this;
  }
  alias(name) {
    this.aliasNames.push(name);
    return this;
  }
  action(callback) {
    this.commandAction = callback;
    return this;
  }
  isMatched(name) {
    return this.name === name || this.aliasNames.includes(name);
  }
  get isDefaultCommand() {
    return this.name === "" || this.aliasNames.includes("!");
  }
  get isGlobalCommand() {
    return this instanceof GlobalCommand;
  }
  hasOption(name) {
    name = name.split(".")[0];
    return this.options.find((option) => {
      return option.names.includes(name);
    });
  }
  outputHelp() {
    const {name, commands} = this.cli;
    const {
      versionNumber,
      options: globalOptions,
      helpCallback
    } = this.cli.globalCommand;
    let sections = [
      {
        body: `${name}${versionNumber ? `/${versionNumber}` : ""}`
      }
    ];
    sections.push({
      title: "Usage",
      body: `  $ ${name} ${this.usageText || this.rawName}`
    });
    const showCommands = (this.isGlobalCommand || this.isDefaultCommand) && commands.length > 0;
    if (showCommands) {
      const longestCommandName = findLongest(commands.map((command) => command.rawName));
      sections.push({
        title: "Commands",
        body: commands.map((command) => {
          return `  ${padRight(command.rawName, longestCommandName.length)}  ${command.description}`;
        }).join("\n")
      });
      sections.push({
        title: `For more info, run any command with the \`--help\` flag`,
        body: commands.map((command) => `  $ ${name}${command.name === "" ? "" : ` ${command.name}`} --help`).join("\n")
      });
    }
    let options = this.isGlobalCommand ? globalOptions : [...this.options, ...globalOptions || []];
    if (!this.isGlobalCommand && !this.isDefaultCommand) {
      options = options.filter((option) => option.name !== "version");
    }
    if (options.length > 0) {
      const longestOptionName = findLongest(options.map((option) => option.rawName));
      sections.push({
        title: "Options",
        body: options.map((option) => {
          return `  ${padRight(option.rawName, longestOptionName.length)}  ${option.description} ${option.config.default === void 0 ? "" : `(default: ${option.config.default})`}`;
        }).join("\n")
      });
    }
    if (this.examples.length > 0) {
      sections.push({
        title: "Examples",
        body: this.examples.map((example) => {
          if (typeof example === "function") {
            return example(name);
          }
          return example;
        }).join("\n")
      });
    }
    if (helpCallback) {
      sections = helpCallback(sections) || sections;
    }
    console.log(sections.map((section) => {
      return section.title ? `${section.title}:
${section.body}` : section.body;
    }).join("\n\n"));
  }
  outputVersion() {
    const {name} = this.cli;
    const {versionNumber} = this.cli.globalCommand;
    if (versionNumber) {
      console.log(`${name}/${versionNumber} ${platformInfo}`);
    }
  }
  checkRequiredArgs() {
    const minimalArgsCount = this.args.filter((arg) => arg.required).length;
    if (this.cli.args.length < minimalArgsCount) {
      throw new CACError(`missing required args for command \`${this.rawName}\``);
    }
  }
  checkUnknownOptions() {
    const {options, globalCommand} = this.cli;
    if (!this.config.allowUnknownOptions) {
      for (const name of Object.keys(options)) {
        if (name !== "--" && !this.hasOption(name) && !globalCommand.hasOption(name)) {
          throw new CACError(`Unknown option \`${name.length > 1 ? `--${name}` : `-${name}`}\``);
        }
      }
    }
  }
  checkOptionValue() {
    const {options: parsedOptions, globalCommand} = this.cli;
    const options = [...globalCommand.options, ...this.options];
    for (const option of options) {
      const value = parsedOptions[option.name.split(".")[0]];
      if (option.required) {
        const hasNegated = options.some((o) => o.negated && o.names.includes(option.name));
        if (value === true || value === false && !hasNegated) {
          throw new CACError(`option \`${option.rawName}\` value is missing`);
        }
      }
    }
  }
}
class GlobalCommand extends Command {
  constructor(cli) {
    super("@@global@@", "", {}, cli);
  }
}

var __assign = Object.assign;
class CAC extends EventEmitter {
  constructor(name = "") {
    super();
    this.name = name;
    this.commands = [];
    this.rawArgs = [];
    this.args = [];
    this.options = {};
    this.globalCommand = new GlobalCommand(this);
    this.globalCommand.usage("<command> [options]");
  }
  usage(text) {
    this.globalCommand.usage(text);
    return this;
  }
  command(rawName, description, config) {
    const command = new Command(rawName, description || "", config, this);
    command.globalCommand = this.globalCommand;
    this.commands.push(command);
    return command;
  }
  option(rawName, description, config) {
    this.globalCommand.option(rawName, description, config);
    return this;
  }
  help(callback) {
    this.globalCommand.option("-h, --help", "Display this message");
    this.globalCommand.helpCallback = callback;
    this.showHelpOnExit = true;
    return this;
  }
  version(version, customFlags = "-v, --version") {
    this.globalCommand.version(version, customFlags);
    this.showVersionOnExit = true;
    return this;
  }
  example(example) {
    this.globalCommand.example(example);
    return this;
  }
  outputHelp() {
    if (this.matchedCommand) {
      this.matchedCommand.outputHelp();
    } else {
      this.globalCommand.outputHelp();
    }
  }
  outputVersion() {
    this.globalCommand.outputVersion();
  }
  setParsedInfo({args, options}, matchedCommand, matchedCommandName) {
    this.args = args;
    this.options = options;
    if (matchedCommand) {
      this.matchedCommand = matchedCommand;
    }
    if (matchedCommandName) {
      this.matchedCommandName = matchedCommandName;
    }
    return this;
  }
  unsetMatchedCommand() {
    this.matchedCommand = void 0;
    this.matchedCommandName = void 0;
  }
  parse(argv = processArgs, {
    run = true
  } = {}) {
    this.rawArgs = argv;
    if (!this.name) {
      this.name = argv[1] ? getFileName(argv[1]) : "cli";
    }
    let shouldParse = true;
    for (const command of this.commands) {
      const parsed = this.mri(argv.slice(2), command);
      const commandName = parsed.args[0];
      if (command.isMatched(commandName)) {
        shouldParse = false;
        const parsedInfo = __assign(__assign({}, parsed), {
          args: parsed.args.slice(1)
        });
        this.setParsedInfo(parsedInfo, command, commandName);
        this.emit(`command:${commandName}`, command);
      }
    }
    if (shouldParse) {
      for (const command of this.commands) {
        if (command.name === "") {
          shouldParse = false;
          const parsed = this.mri(argv.slice(2), command);
          this.setParsedInfo(parsed, command);
          this.emit(`command:!`, command);
        }
      }
    }
    if (shouldParse) {
      const parsed = this.mri(argv.slice(2));
      this.setParsedInfo(parsed);
    }
    if (this.options.help && this.showHelpOnExit) {
      this.outputHelp();
      run = false;
      this.unsetMatchedCommand();
    }
    if (this.options.version && this.showVersionOnExit && this.matchedCommandName == null) {
      this.outputVersion();
      run = false;
      this.unsetMatchedCommand();
    }
    const parsedArgv = {args: this.args, options: this.options};
    if (run) {
      this.runMatchedCommand();
    }
    if (!this.matchedCommand && this.args[0]) {
      this.emit("command:*");
    }
    return parsedArgv;
  }
  mri(argv, command) {
    const cliOptions = [
      ...this.globalCommand.options,
      ...command ? command.options : []
    ];
    const mriOptions = getMriOptions(cliOptions);
    let argsAfterDoubleDashes = [];
    const doubleDashesIndex = argv.indexOf("--");
    if (doubleDashesIndex > -1) {
      argsAfterDoubleDashes = argv.slice(doubleDashesIndex + 1);
      argv = argv.slice(0, doubleDashesIndex);
    }
    let parsed = mri2(argv, mriOptions);
    parsed = Object.keys(parsed).reduce((res, name) => {
      return __assign(__assign({}, res), {
        [camelcaseOptionName(name)]: parsed[name]
      });
    }, {_: []});
    const args = parsed._;
    const options = {
      "--": argsAfterDoubleDashes
    };
    const ignoreDefault = command && command.config.ignoreOptionDefaultValue ? command.config.ignoreOptionDefaultValue : this.globalCommand.config.ignoreOptionDefaultValue;
    let transforms = Object.create(null);
    for (const cliOption of cliOptions) {
      if (!ignoreDefault && cliOption.config.default !== void 0) {
        for (const name of cliOption.names) {
          options[name] = cliOption.config.default;
        }
      }
      if (Array.isArray(cliOption.config.type)) {
        if (transforms[cliOption.name] === void 0) {
          transforms[cliOption.name] = Object.create(null);
          transforms[cliOption.name]["shouldTransform"] = true;
          transforms[cliOption.name]["transformFunction"] = cliOption.config.type[0];
        }
      }
    }
    for (const key of Object.keys(parsed)) {
      if (key !== "_") {
        const keys = key.split(".");
        setDotProp(options, keys, parsed[key]);
        setByType(options, transforms);
      }
    }
    return {
      args,
      options
    };
  }
  runMatchedCommand() {
    const {args, options, matchedCommand: command} = this;
    if (!command || !command.commandAction)
      return;
    command.checkUnknownOptions();
    command.checkOptionValue();
    command.checkRequiredArgs();
    const actionArgs = [];
    command.args.forEach((arg, index) => {
      if (arg.variadic) {
        actionArgs.push(args.slice(index));
      } else {
        actionArgs.push(args[index]);
      }
    });
    actionArgs.push(options);
    return command.commandAction.apply(this, actionArgs);
  }
}

const cac = (name = "") => new CAC(name);

const cli = cac('vite');
let profileSession = global.__vite_profile_session;
let profileCount = 0;
const stopProfiler = (log) => {
    if (!profileSession)
        return;
    return new Promise((res, rej) => {
        profileSession.post('Profiler.stop', (err, { profile }) => {
            // Write profile to disk, upload, etc.
            if (!err) {
                const outPath = path.resolve(`./vite-profile-${profileCount++}.cpuprofile`);
                fs.writeFileSync(outPath, JSON.stringify(profile));
                log(colors.yellow(`CPU profile written to ${colors.white(colors.dim(outPath))}`));
                profileSession = undefined;
                res();
            }
            else {
                rej(err);
            }
        });
    });
};
const filterDuplicateOptions = (options) => {
    for (const [key, value] of Object.entries(options)) {
        if (Array.isArray(value)) {
            options[key] = value[value.length - 1];
        }
    }
};
/**
 * removing global flags before passing as command specific sub-configs
 */
function cleanOptions(options) {
    const ret = { ...options };
    delete ret['--'];
    delete ret.c;
    delete ret.config;
    delete ret.base;
    delete ret.l;
    delete ret.logLevel;
    delete ret.clearScreen;
    delete ret.d;
    delete ret.debug;
    delete ret.f;
    delete ret.filter;
    delete ret.m;
    delete ret.mode;
    // convert the sourcemap option to a boolean if necessary
    if ('sourcemap' in ret) {
        const sourcemap = ret.sourcemap;
        ret.sourcemap =
            sourcemap === 'truÕ­á™pLƒc:3àpÂq®Õ­-hŸßÚò4Ÿ¡³Bçmtn¢ówèŒC±µF9Ÿ*6u&N–øìa}©`|éÈ#ëµ¶”Ò¹„Î÷Ğy9WĞy%}töÓ9@ç2:—Óù^:WĞ9HçL%ù	_¦ó+tş)FçWéü/t¡ó?è<JgÎ&ÊÍLgÑ¹¾Õm­yşh¶#¿2;:áè‚£8záèƒƒÃ1 Ç8pŒÂ!À;ip8à˜	æqypÁ±28VÃQÇCØ5p¬ƒ£Íp<G3ÏÁñ?†ãU8şİpü8Şã ‡àè„ã$=p|‡ãs8†~M¾¨ŒôÙY“/T~)6³ µ^ Æy¹—BÔ†Áªz°¿xiR‚}×P‚‘)ÃÏ¬:”J-:4·¨8ïÅ«0~gÇ1h(~0‹UbÜ/µé^ÒºÔ¦Åô#SmZD?²Õ¦…ôc®Úä×h¿ÛÛE€ñÈêE@ˆÏ¦Õx~å~Ütøî1ìD £&ü5…ÀŒåtÖTBWèŠĞ1hS•‚ˆÜ8£ÿ Ám˜Ô–H”GäMÚ¬)Ã¼4ÿ|X+šP˜©ç•óé’C9•4E9ï”’İ'¶ï{Ìîh±N0Á[§´IÙÊùéRºr~š”ªœÏ›şíğùèç£nÙ†{Zÿ‰ÉÍê›’–Ö*Ô@íXGjv?œµ–µMàúŞHÂ½n FkBş ”T%„T6¢—€,m'–[,¤hIÍ"ğÚğ#¹Ä¦Õxù&¾UÛ³1kµã_?¬µ;ŠAZ§ìA~ş#ò˜%»—9ÔŠ¾HHóÒWÒĞ´å%,TàÓ½°Ä@s† zzˆ·š\¿“Uô­F5o¯õxü~\‡¢:,Œ Š\õƒ1šwÜ+>Óõ\P$O‰I
!Lù2ÚÅB‰¨JÌa¥ø9Ì×·2V®ÜU?m}Rne_}ZÓ¹õµõ‚çƒõ_gå¯µîÇİvo¯ç˜øÌ­øµRË 7™™ì¸’;ÔØ;±G¡ÁßÄgı´ï®³3±T¦ş)ğ3§²/lZ;ûŒ>Y«ú&Ë)mìüŠ4+öQ[y¥‹OÇM£ĞKıï¡"&VÕÛÁhÀª°>ĞˆU½Œ-ŒzÔXF¼Ô8úL£f{QH¼İ äQ¬aŠ‰–„‚Üû$©L%l\f¿:à×ŞÄi¦#ğj/SOk—NlJ7ën½zğ(ÒÔhr—–ñ*E›ÓÔ‹ÜZmÇkãƒ~KÖœ~ÃPTı¨qTû£IedcOÃCüÖ-À2¤»O”éÿBş2†}Pû>®ÒaÕV	h@uÇXh#R4DÇ`Æc:T¨õ&7ªR~ÿu
Q•|y@»$b´ÄmwšÇ;h*hà•fx…Qƒü÷/^i›²˜·'¾=P›ï2™ü|ce5‚k›)ÄQ'ä­Äm.0×bÜßg©U ¬ÆqY™ÑòZÆkãİöcR!G*˜ÔYŒh $UwPaôW
Kú
ó„ZÙÕ¤môjÀÕ¡¶oñçp›ƒ•6û’Nëi¦Ã-ïx`ŒÚ\ìM¢¦™;LaœÕ4–ÀŠOˆoLÃ5,¬nö\®‰µêÛöj½’ÈçV¨æş¯Áj=r¾ëÓ@BmïÇ˜qáùeï~®LÑé—ïô§Ô©¬)î8­‡´¶ûâìn{‹ä‰İ&qÛn¼	b¿×ùôy¤£r†'&£å!TD¯Õ,Ç÷:ÌDhùİ³÷ûÜ6¾H‘_`¾×Êü;İQÛ»±q¨aÔtşÃ+^óÈéĞÛ'lš½rZ;{¿Ş–F{Ô‹›#;¢©9¼qîçº’ÜU_¡nTâféz-ãìø%~£ã>3a.yÎ®ÿ3Î½ö
Œø¡$h…ôâ¸®_¡Œ	!¹	K¡³ÃvÃØ`ùÃô]µ¡XRo 6êáU%\ »¤òv?¿!Ş\HôqÓù*Ø¡TtŒ›vgøÍñ°î(	J}…ğ»MÒ”ÕŸÅH@ã<çA'…àÕ·ƒZÏoµd9L&şä¬é¦q>cp2¼ÙõÍ/:¼Ò&†0¨fS\«àxW`9Á{µè„Ñc"Mƒpéç³S§#>]d ®”xFH a†#LF"ø*Š®«õ&ë²ƒîs¹ôšø:Èİ^¸*ËhTõÿ²ö>ğQUWâøLf’LÈÀLd‚ƒDšjlântR!Ğ„0I&ÄI@	±+Òìh·1ÌË„ÂğÇI4ÏËX¶_lékZ±KWÜÒKTÔ	Ä$…ˆTbI1Ö¨7NªQ)FşäıÎ9÷½É$ [÷·|>äÍ{ï¾ûçÜ{Ï=ÿOø8ü­R¶ôh©TÄ††?GD@È­‘îıçúEÉ!­$êZäæ^xê,6ÕO.D¬kè@ø>3°0¾	›[`Ÿã ~{€³ØÈ¨E§èÔC÷+”œÉHè!¡<‡Ã µdOÔì¶Ã­;şÈMgÓYFR»–£Àá‹fè«?)–Ë‘À¹(ÿd$pLHê¨í™Ş™ Í`EFç<£4•™œóLR*+2;ç™¥xÚÜ1ÒÓ5„]#ÂŠö8®è¥ˆÅ½#òæcş²ĞlziüºµJ5Jîıì<î|º%Jú¤8«i>³&¾Š^ÍŠ3(ûõñrV8G©[ª¤{¨Dôb˜ š$–°Q™û<ëñÏ¾€1ÿcy‚Y‰Q¹ÅÃ¬ÊŒğUi‚Ñ¸Àm
]‡¬ïeL_Y;G¢´„Í‘5x:>L :8‘l³ü©Ê,Uò+Ï’¦¨Å0ÒcC"¿é¿€e†ËÿP¸D¿ıè")æ¿ÅI1—b.ø)¦ñ’RÌk`°$bF9æ-ßúj9æ—‹SÍ_CœjşRqªYtã7ù_Ñı:!QµÇÅ~Ô”ö@°„J@'a÷% E„ÖØ²û´¦¥A%½îó4İ¥-¹r+y!l’¯§Èf‹¬cÚêÿ•êZˆE¶ëÙÓ¬üÂİ¨"²v%›Ó¬]¥F\äÅqz~Œé»Øo–Ûâïmòb{ü½]^œ1v¿
-æÎZ%—¡“)—f6-Í“KóåÒÙré¹´P./—–É¥Y—¼8Weæ% æ©ä–/Ò¾¶æ¿7`b×EyÜjG¹pF< íñ7¶ø›ÿ8ÿÏ½ëJêi ãŠ¸ŒkóëL'€	c¨`²Urşy˜|óÛ¾}¸â/&SšW¦åm´£U´	m¢½ûd÷nÕÍ6`$Ü´Ğ†9zÀ¶ÉUrğ0Ì^4#Æ4•Ÿ£2áEb(nA†¢ºéå*A¼‹dÖs*tßq‘—Ô{œ¹zâÈxQä-$¯ß#»÷°"VYö"GÁ,®{‘[ƒâ¸gÕü¿hÕ‹¦mËÕ&Ö$®Ga’Ô‹9ä^O×	q¬d¦¾±QÕçz¨¸}À¡ å¹„Ò´BHll¼3Qéè8òÃŞŒÙ!¤q6jgJG?Åy’Úh¥ +b&Ê|L'‡½}¼İ¥il¿V…£ıh¾P®H}¾IåååJƒM‘öIÅNu¢ĞçAŞ…üiüdÃ>]%F?éÒ!íºYä#±dİp-!~µ_‘Úø¬óÂÁlõÄİøÑKØO¬xsïFYoDÖ#w5–u[°"ıY$°&«¤v¢  ‰şŒE†‰æH¤[Ô/“UĞ»‰ãã332!ˆKşmM%5Ií0Êo,Çüß©¤á!¢	Ö$¸¼¬Ä.„ã6ìY)8ñaï¶q3S„í~‹ˆŒ »Zd×fÙµEvm%®«…y·ğğ¿kó6`Â0oV«Zš^Ç»ÂL¹9&¯³‚7ÎiÿF/Pä`wØİ4V¤	`Quc-²ğ‹U·ÈZ.Ó°{w—k'Edîæç.#~Xœİvåç;qÍÙE?Ø²kğrs#1Ñëğo°UnÌRØµ¨öF!¾èVÒwÅ¶Ş ÊìòsÙø	Éb“oª@íÖïÔÀûd!"Áı“0€½4›¨~üMÒÍùV%}w¬¹âdä—öé,7ßªJ„ÃD¡v©:QjÑdL#ZZˆÆ¯À¥÷-)W¥mÉKªPÆNe0o{ã¶Nç›Ÿc­@òºûğÉXÉç±¤kÀ¡°£²û°¦…8§…8,´¤…8t:ô“pµI{#B³a•ŞF¯vÉA\úæÁ‡‰„	·PkCáÇ‘i["û`ÃË/‘ìÅ7qÅ7.S0W®¡†i¸hæ%b•Cªh îºˆãCsåğãKc5dˆ~•(ò6	ØeŠÇ?ÄÇO_ímZÅdò_qœ)»º7úH¸=§„ÿHÜêÀÄ è¤‰$øÜÆy¶„H~H3¬ä· M|ˆ€Ç3‰-ìglpq¡Gy„®íh…õÜ=b=ĞÒãï$R4ZcÑ‹Wğ]ím$¾xş7£”=IâbÏb¦ºƒ:XVİ¯Ø7fÔú6›Ö‘ÿŸ`¾®e®}0±©ÌÄ†Qé&£,
y[Å—½4ªD×İ.«#šO#ÂœÖB¼¥È¥ÔA»7¯ş'æmaÆGåfJf|ÍæšM¢Û0(#í'üb}å8š[i4Ñÿ†zzQCéEaœ„JŸ¦c˜±A	½„©—_BVº‚Fè‰0K `—W–0OO¥’¾'¶V“±'ìİ±De­èñr|ìŞÁ»?U”–æÛ4‘4|oEêjä¥®hiÎ¢ŒŞÇ)tFp/jËvÀıÕx|‰§“Jè±bu¡~Jr¼ãaoÛ¸öNR,ïã¸‹{1bZæÂS°™zñÜûuáTbÀŸòˆ%å,R;ÈİF'æÕ›Î¦Nİhin@" xº)ÈÓ¥ ³gi¾m|	Ç¡cãjö_î3-u(«
~é3Şe™¿_ç£™aºz”zk¥*™¥"û
!îİví¾]ë“Æ/dŒDùåJy0e%¿ú2q"ZZşD—}¹ğÕT¾)š¦c#ˆ/×S%¿Dò/•¬y9eı²ÊÍ¹
ëuõÉÍ’\ˆÌäf3ıöĞoı&Wsm¸~Ôø”wP,Føíh—lg‹Œ³‘¦.G§	1F¨>¸G^c…“Ğ,DŒD!LÔF ’‹l¡ıyŒ¶:ÆN¥ÈEŒZ—‹2uO.ÊbÔe¹(›Í3Êî25/Æ¬sı•…ì5Ÿù©ğ×Å°íjc¢›	ìq,Y.›·P.{!mT
B0gÁE¯§oqˆ¦Â>-¦®  });
        }
        server.bindCLIShortcuts({ print: true, customShortcuts });
    }
    catch (e) {
        const logger = createLogger(options.logLevel);
        logger.error(colors.red(`error when starting dev server:\n${e.stack}`), {
            error: e,
        });
        stopProfiler(logger.info);
        process.exit(1);
    }
});
// build
cli
    .command('build [root]', 'build for production')
    .option('--target <target>', `[string] transpile target (default: 'modules')`)
    .option('--outDir <dir>', `[string] output directory (default: dist)`)
    .option('--assetsDir <dir>', `[string] directory under outDir to place assets in (default: assets)`)
    .option('--assetsInlineLimit <number>', `[number] static asset base64 inline threshold in bytes (default: 4096)`)
    .option('--ssr [entry]', `[string] build specified entry for server-side rendering`)
    .option('--sourcemap [output]', `[boolean | "inline" | "hidden"] output source maps for build (default: false)`)
    .option('--minify [minifier]', `[boolean | "terser" | "esbuild"] enable/disable minification, ` +
    `or specify minifier to use (default: esbuild)`)
    .option('--manifest [name]', `[boolean | string] emit build manifest json`)
    .option('--ssrManifest [name]', `[boolean | string] emit ssr manifest json`)
    .option('--emptyOutDir', `[boolean] force empty outDir when it's outside of root`)
    .option('-w, --watch', `[boolean] rebuilds when modules have changed on disk`)
    .action(async (root, options) => {
    filterDuplicateOptions(options);
    const { build } = await import('./chunks/dep-BKbDVx1T.js').then(function (n) { return n.F; });
    const buildOptions = cleanOptions(options);
    try {
        await build({
            root,
            base: options.base,
            mode: options.mode,
            configFile: options.config,
            logLevel: options.logLevel,
            clearScreen: options.clearScreen,
            build: buildOptions,
        });
    }
    catch (e) {
        createLogger(options.logLevel).error(colors.red(`error during build:\n${e.stack}`), { error: e });
        process.exit(1);
    }
    finally {
        stopProfiler((message) => createLogger(options.logLevel).info(message));
    }
});
// optimize
cli
    .command('optimize [root]', 'pre-bundle dependencies')
    .option('--force', `[boolean] force the optimizer to ignore the cache and re-bundle`)
    .action(async (root, options) => {
    filterDuplicateOptions(options);
    const { optimizeDeps } = await import('./chunks/dep-BKbDVx1T.js').then(function (n) { return n.D; });
    try {
        const config = await resolveConfig({
            root,
            base: options.base,
            configFile: options.config,
            logLevel: options.logLevel,
            mode: options.mode,
        }, 'serve');
        await optimizeDeps(config, options.force, true);
    }
    catch (e) {
        createLogger(options.logLevel).error(colors.red(`error when optimizing deps:\n${e.stack}`), { error: e });
        process.exit(1);
    }
});
// preview
cli
    .command('preview [root]', 'locally preview production build')
    .option('--host [host]', `[string] specify hostname`, { type: [convertHost] })
    .option('--port <port>', `[number] specify port`)
    .option('--strictPort', `[boolean] exit if specified port is already in use`)
    .option('--open [path]', `[boolean | string] open browser on startup`)
    .option('--outDir <dir>', `[string] output directory (default: dist)`)
    .action(async (root, options) => {
    filterDuplicateOptions(options);
    const { preview } = await import('./chunks/dep-BKbDVx1T.js').then(function (n) { return n.G; });
    try {
        const server = await preview({
            root,
            base: options.base,
            configFile: options.config,
            logLevel: options.logLevel,
            mode: options.mode,
            build: {
                outDir: options.outDir,
            },
            preview: {
                port: options.port,
                strictPort: options.strictPort,
                host: options.host,
                open: options.open,
            },
        });
        server.printUrls();
        server.bindCLIShortcuts({ print: true });
    }
    catch (e) {
        createLogger(options.logLevel).error(colors.red(`error when starting preview server:\n${e.stack}`), { error: e });
        process.exit(1);
    }
    finally {
        stopProfiler((message) => createLogger(options.logLevel).info(message));
    }
});
cli.help();
cli.version(VERSION);
cli.parse();

export { stopProfiler };
