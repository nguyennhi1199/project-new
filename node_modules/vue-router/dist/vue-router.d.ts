import { AllowedComponentProps } from 'vue';
import { App } from 'vue';
import { Component } from 'vue';
import { ComponentCustomProps } from 'vue';
import { ComponentPublicInstance } from 'vue';
import { ComputedRef } from 'vue';
import { DefineComponent } from 'vue';
import type { InjectionKey } from 'vue';
import { Ref } from 'vue';
import { UnwrapRef } from 'vue';
import { VNode } from 'vue';
import { VNodeProps } from 'vue';

declare type Awaitable<T> = T | Promise<T>;

/**
 * Creates an in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.
 * It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.
 *
 * @param base - Base applied to all urls, defaults to '/'
 * @returns a history object that can be passed to the router constructor
 */
export declare function createMemoryHistory(base?: string): RouterHistory;

/**
 * Creates a Router instance that can be used by a Vue app.
 *
 * @param options - {@link RouterOptions}
 */
export declare function createRouter(options: RouterOptions): Router;

/**
 * Creates a Router Matcher.
 *
 * @internal
 * @param routes - array of initial routes
 * @param globalOptions - global route options
 */
export declare function createRouterMatcher(routes: Readonly<RouteRecordRaw[]>, globalOptions: PathParserOptions): RouterMatcher;

/**
 * Creates a hash history. Useful for web applications with no host (e.g. `file://`) or when configuring a server to
 * handle any URL is not possible.
 *
 * @param base - optional base to provide. Defaults to `location.pathname + location.search` If there is a `<base>` tag
 * in the `head`, its value will be ignored in favor of this parameter **but note it affects all the history.pushState()
 * calls**, meaning that if you use a `<base>` tag, it's `href` value **has to match this parameter** (ignoring anything
 * after the `#`).
 *
 * @example
 * ```js
 * // at https://example.com/folder
 * createWebHashHistory() // gives a url of `https://example.com/folder#`
 * createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`
 * // if the `#` is provided in the base, it won't be added by `createWebHashHistory`
 * createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`
 * // you should avoid doing this because it changes the original url and breaks copying urls
 * createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`
 *
 * // at file:///usr/etc/folder/index.html
 * // for locations with no `host`, the base is ignored
 * createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`
 * ```
 */
export declare function createWebHashHistory(base?: string): RouterHistory;

/**
 * Creates an HTML5 history. Most common history for single page applications.
 *
 * @param base -
 */
export declare function createWebHistory(base?: string): RouterHistory;

/**
 * Internal type to define an ErrorHandler
 *
 * @param error - error thrown
 * @param to - location we were navigating to when the error happened
 * @param from - location we were navigating from when the error happened
 * @internal
 */
declare interface _ErrorListener {
    (error: any, to: RouteLocationNormalized, from: RouteLocationNormalizedLoaded): any;
}

/**
 * Flags so we can combine them when checking for multiple errors. This is the internal version of
 * {@link NavigationFailureType}.
 *
 * @internal
 */
export declare const enum ErrorTypes {
    MATCHER_NOT_FOUND = 1,
    NAVIGATION_GUARD_REDIRECT = 2,
    NAVIGATION_ABORTED = 4,
    NAVIGATION_CANCELLED = 8,
    NAVIGATION_DUPLICATED = 16
}

declare type HistoryLocation = string;

/**
 * Allowed HTML history.state
 */
export declare interface HistoryState {
    [x: number]: HistoryStateValue;
    [x: string]: HistoryStateValue;
}

/**
 * Allowed arrays for history.state.
 *
 * @internal
 */
declare interface HistoryStateArray extends Array<HistoryStateValue> {
}

/**
 * Allowed variables in HTML5 history state. Note that pushState clones the state
 * passed and does not accept everything: e.g.: it doesn't accept symbols, nor
 * functions as values. It also ignores Symbols as keys.
 *
 * @internal
 */
declare type HistoryStateValue = string | number | boolean | null | undefined | HistoryState | HistoryStateArray;

/**
 * Check if an object is a {@link NavigationFailure}.
 *
 * @param error - possible {@link NavigationFailure}
 * @param type - optional types to check for
 *
 * @example
 * ```js
 * import { isNavigationFailure, NavigationFailureType } from 'vue-router'
 *
 * router.afterEach((to, from, failure) => {
 *   // Any kind of navigation failure
 *   if (isNavigationFailure(failure)) {
 *     // ...
 *   }
 *   // Only duplicated navigations
 *   if (isNavigationFailure(failure, NavigationFailureType.duplicated)) {
 *     // ...
 *   }
 *   // Aborted or canceled navigations
 *   if (isNavigationFailure(failure, NavigationFailureType.aborted | NavigationFailureType.canceled)) {
 *     // ...
 *   }
 * })
 * ```
 */
export declare function isNavigationFailure(error: any, type?: ErrorTypes.NAVIGATION_GUARD_REDIRECT): error is NavigationRedirectError;

export declare function isNavigationFailure(error: any, type?: ErrorTypes | NavigationFailureType): error is NavigationFailure;

declare type Lazy<T> = () => Promise<T>;

/**
 * Ensures a route is loaded, so it can be passed as o prop to `<RouterView>`.
 *
 * @param route - resolved route to load
 */
export declare function loadRouteLocation(route: RouteLocationNormalized): Promise<RouteLocationNormalizedLoaded>;

/**
 * @internal
 */
export declare interface LocationAsRelativeRaw {
    name?: RouteRecordName;
    /**
     * Ignored path property since we are dealing with a relative location. Only `undefined` is allowed.
     */
    path?: undefined;
    params?: RouteParamsRaw;
}

/**
 * Normalized query object that appears in {@link RouteLocationNormalized}
 *
 * @public
 */
export declare type LocationQuery = Record<string, LocationQueryValue | LocationQueryValue[]>;

/**
 * Loose {@link LocationQuery} object that can be passed to functions like
 * {@link Router.push} and {@link Router.replace} or anywhere when creating a
 * {@link RouteLocationRaw}
 *
 * @public
 */
export declare type LocationQueryRaw = Record<string | number, LocationQueryValueRaw | LocationQueryValueRaw[]>;

/**
 * Possible values in normalized {@link LocationQuery}. `null` renders the query
 * param but without an `=`.
 *
 * @example
 * ```
 * ?isNull&isEmpty=&other=other
 * gives
 * `{ isNull: null, isEmpty: '', other: 'other' }`.
 * ```
 *
 * @internal
 */
export declare type LocationQueryValue = string | null;

/**
 * Possible values when defining a query.
 *
 * @internal
 */
export declare type LocationQueryValueRaw = LocationQueryValue | number | undefined;

/**
 * RouteRecord being rendered by the closest ancestor Router View. Used for
 * `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View
 * Location Matched
 *
 * @internal
 */
export declare const matchedRouteKey: InjectionKey<ComputedRef<RouteRecordNormalized | undefined>>;

/**
 * Normalized/resolved Route location that returned by the matcher.
 */
declare interface MatcherLocation {
    /**
     * Name of the matched record
     */
    name: RouteRecordName | null | undefined;
    /**
     * Percentage encoded pathname section of the URL.
     */
    path: string;
    /**
     * Object of decoded params extracted from the `path`.
     */
    params: RouteParams;
    /**
     * Merged `meta` properties from all the matched route records.
     */
    meta: RouteMeta;
    /**
     * Array of {@link RouteRecord} containing components as they were
     * passed when adding records. It can also contain redirect records. This
     * can't be used directly
     */
    matched: RouteRecord[];
}

/**
 * @internal
 */
declare interface MatcherLocationAsName {
    name: RouteRecordName;
    /**
     * Ignored path property since we are dealing with a relative location. Only `undefined` is allowed.
     */
    path?: undefined;
    params?: RouteParams;
}

/**
 * @internal
 */
export declare interface MatcherLocationAsPath {
    path: string;
}

/**
 * @internal
 */
declare interface MatcherLocationAsRelative {
    /**
     * Ignored path property since we are dealing with a relative location. Only `undefined` is allowed.
     */
    path?: undefined;
    params?: RouteParams;
}

/**
 * Route location that can be passed to the matcher.
 */
declare type MatcherLocationRaw = MatcherLocationAsPath | MatcherLocationAsName | MatcherLocationAsRelative;

declare interface NavigationCallback {
    (to: HistoryLocation, from: HistoryLocation, information: NavigationInformation): void;
}

declare enum NavigationDirection {
    back = "back",
    forward = "forward",
    unknown = ""
}

/**
 * Extended Error that contains extra information regarding a failed navigation.
 */
export declare interface NavigationFailure extends Error {
    /**
     * Type of the navigation. One of {@link NavigationFailureType}
     */
    type: ErrorTypes.NAVIGATION_CANCELLED | ErrorTypes.NAVIGATION_ABORTED | ErrorTypes.NAVIGATION_DUPLICATED;
    /**
     * Route location we were navigating from
     */
    from: RouteLocationNormalized;
    /**
     * Route location we were navigating to
     */
    to: RouteLocationNormalized;
}

/**
 * Enumeration with all possible types for navigation failures. Can be passed to
 * {@link isNavigationFailure} to check for specific failures.
 */
export declare enum NavigationFailureType {
    /**
     * An aborted navigation is a navigation that failed because a navigation
     * guard returned `false` or called `next(false)`
     */
    aborted = 4,
    /**
     * A cancelled navigation is a navigation that failed because a more recent
     * navigation finished started (not necessarily finished).
     */
    cancelled = 8,
    /**
     * A duplicated navigation is a navigation that failed because it was
     * initiated while already being at the exact same location.
     */
    duplicated = 16
}

/**
 * Navigation guard. See [Navigation
 * Guards](/guide/advanced/navigation-guards.md).
 */
export declare interface NavigationGuard {
    (to: RouteLocationNormalized, from: RouteLocationNormalized, next: NavigationGuardNext): NavigationGuardReturn | Promise<NavigationGuardReturn>;
}

export declare interface NavigationGuardNext {
    (): void;
    (error: Error): void;
    (location: RouteLocationRaw): void;
    (valid: boolean | undefined): void;
    (cb: NavigationGuardNextCallback): void;
}

declare type NavigationGuardNextCallback = (vm: ComponentPublicInstance) => unknown;

declare type NavigationGuardReturn = void | Error | RouteLocationRaw | boolean | NavigationGuardNextCallback;

/**
 * {@inheritDoc NavigationGuard}
 */
export declare interface NavigationGuardWithThis<T> {
    (this: T, to: RouteLocationNormalized, from: RouteLocationNormalized, next: NavigationGuardNext): NavigationGuardReturn | Promise<NavigationGuardReturn>;
}

export declare interface NavigationHookAfter {
    (to: RouteLocationNormalized, from: RouteLocationNormalized, failure?: NavigationFailure | void): any;
}

declare interface NavigationInformation {
    type: NavigationType;
    direction: NavigationDirection;
    delta: number;
}

/**
 * Internal error used to detect a redirection.
 *
 * @internal
 */
export declare interface NavigationRedirectError extends Omit<NavigationFailure, 'to' | 'type'> {
    type: ErrorTypes.NAVIGATION_GUARD_REDIRECT;
    to: RouteLocationRaw;
}

declare enum NavigationType {
    pop = "pop",
    push = "push"
}

/**
 * Add a navigation guard that triggers whenever the component for the current
 * location is about to be left. Similar to {@link beforeRouteLeave} but can be
 * used in any component. The guard is removed when the component is unmounted.
 *
 * @param leaveGuard - {@link NavigationGuard}
 */
export declare function onBeforeRouteLeave(leaveGuard: NavigationGuard): void;

/**
 * Add a navigation guard that triggers whenever the current location is about
 * to be updated. Similar to {@link beforeRouteUpdate} but can be used in any
 * component. The guard is removed when the component is unmounted.
 *
 * @param updateGuard - {@link NavigationGuard}
 */
export declare function onBeforeRouteUpdate(updateGuard: NavigationGuard): void;

/**
 * Transforms a queryString into a {@link LocationQuery} object. Accept both, a
 * version with the leading `?` and without Should work as URLSearchParams

 * @internal
 *
 * @param search - search string to parse
 * @returns a query object
 */
export declare function parseQuery(search: string): LocationQuery;

declare type PathParams = Record<string, string | string[]>;

declare interface PathParser {
    /**
     * The regexp used to match a url
     */
    re: RegExp;
    /**
     * The score of the parser
     */
    score: Array<number[]>;
    /**
     * Keys that appeared in the path
     */
    keys: PathParserParamKey[];
    /**
     * Parses a url and returns the matched params or null if it doesn't match. An
     * optional param that isn't preset will be an empty string. A repeatable
     * param will be an array if there is at least one value.
     *
     * @param path - url to parse
     * @returns a Params object, empty if there are no params. `null` if there is
     * no match
     */
    parse(path: string): PathParams | null;
    /**
     * Creates a string version of the url
     *
     * @param params - object of params
     * @returns a url
     */
    stringify(params: PathParams): string;
}

export declare type PathParserOptions = Pick<_PathParserOptions, 'end' | 'sensitive' | 'strict'>;

/**
 * @internal
 */
export declare interface _PathParserOptions {
    /**
     * Makes the RegExp case-sensitive.
     *
     * @defaultValue `false`
     */
    sensitive?: boolean;
    /**
     * Whether to disallow a trailing slash or not.
     *
     * @defaultValue `false`
     */
    strict?: boolean;
    /**
     * Should the RegExp match from the beginning by prepending a `^` to it.
     * @internal
     *
     * @defaultValue `true`
     */
    start?: boolean;
    /**
     * Should the RegExp match until the end by appending a `$` to it.
     *
     * @defaultValue `true`
     */
    end?: boolean;
}

/**
 * A param in a url like `/users/:id`
 */
declare interface PathParserParamKey {
    name: string;
    repeatable: boolean;
    optional: boolean;
}

/**
 * Allowed Component definitions in route records provided by the user
 */
declare type RawRouteComponent = RouteComponent | Lazy<RouteComponent>;

/**
 * Allowed Component in {@link RouteLocationMatched}
 */
export declare type RouteComponent = Component | DefineComponent;

/**
 * {@link RouteLocationRaw} resolved using the matcher
 */
export declare interface RouteLocation extends _RouteLocationBase {
    /**
     * Array of {@link RouteRecord} containing components as they were
     * passed when adding records. It can also contain redirect records. This
     * can't be used directly
     */
    matched: RouteRecord[];
}

/**
 * Base properties for a normalized route location.
 *
 * @internal
 */
export declare interface _RouteLocationBase extends Pick<MatcherLocation, 'name' | 'path' | 'params' | 'meta'> {
    /**
     * The whole location including the `search` and `hash`. This string is
     * percentage encoded.
     */
    fullPath: string;
    /**
     * Object representation of the `search` property of the current location.
     */
    query: LocationQuery;
    /**
     * Hash of the current location. If present, starts with a `#`.
     */
    hash: string;
    /**
     * Contains the location we were initially trying to access before ending up
     * on the current location.
     */
    redirectedFrom: RouteLocation | undefined;
}

/**
 * Allows overriding the current route returned by `useRoute` in tests. rl
 * stands for route location
 *
 * @internal
 */
export declare const routeLocationKey: InjectionKey<RouteLocationNormalizedLoaded>;

export declare interface RouteLocationMatched extends RouteRecordNormalized {
    components: Record<string, RouteComponent> | null | undefined;
}

/**
 * Route Location that can infer the necessary params based on the name.
 *
 * @internal
 */
export declare interface RouteLocationNamedRaw extends RouteQueryAndHash, LocationAsRelativeRaw, RouteLocationOptions {
}

/**
 * Similar to {@link RouteLocation} but its
 * {@link RouteLocationNormalized.matched} cannot contain redirect records
 */
export declare interface RouteLocationNormalized extends _RouteLocationBase {
    /**
     * Array of {@link RouteRecordNormalized}
     */
    matched: RouteRecordNormalized[];
}

/**
 * {@link RouteLocationRaw} with
 */
export declare interface RouteLocationNormalizedLoaded extends _RouteLocationBase {
    /**
     * Array of {@link RouteLocationMatched} containing only plain components (any
     * lazy-loaded components have been loaded and were replaced inside the
     * `components` object) so it can be directly used to display routes. It
     * cannot contain redirect records either
     */
    matched: RouteLocationMatched[];
}

/**
 * Common options for all navigation methods.
 */
export declare interface RouteLocationOptions {
    /**
     * Replace the entry in the history instead of pushing a new entry
     */
    replace?: boolean;
    /**
     * Triggers the navigation even if the location is the same as the current one.
     * Note this will also add a new entry to the history unless `replace: true`
     * is passed.
     */
    force?: boolean;
    /**
     * State to save using the History API. This cannot contain any reactive
     * values and some primitives like Symbols are forbidden. More info at
     * https://developer.mozilla.org/en-US/docs/Web/API/History/state
     */
    state?: HistoryState;
}

/**
 * Route Location that can infer the possible paths.
 *
 * @internal
 */
export declare interface RouteLocationPathRaw extends RouteQueryAndHash, MatcherLocationAsPath, RouteLocationOptions {
}

/**
 * User-level route location
 */
export declare type RouteLocationRaw = string | RouteLocationPathRaw | RouteLocationNamedRaw;

/**
 * Interface to type `meta` fields in route records.
 *
 * @example
 *
 * ```ts
 * // typings.d.ts or router.ts
 * import 'vue-router';
 *
 * declare module 'vue-router' {
 *   interface RouteMeta {
 *     requiresAuth?: boolean
 *   }
 *  }
 * ```
 */
export declare interface RouteMeta extends Record<string | number | symbol, unknown> {
}

export declare type RouteParams = Record<string, RouteParamValue | RouteParamValue[]>;

export declare type RouteParamsRaw = Record<string, RouteParamValueRaw | Exclude<RouteParamValueRaw, null | undefined>[]>;

/**
 * @internal
 */
export declare type RouteParamValue = string;

/**
 * @internal
 */
export declare type RouteParamValueRaw = RouteParamValue | number | null | undefined;

/**
 * @internal
 */
export declare interface RouteQueryAndHash {
    query?: LocationQueryRaw;
    hash?: string;
}

/**
 * Router instance.
 */
export declare interface Router {
    /**
     * @internal
     */
    /**
     * Current {@link RouteLocationNormalized}
     */
    readonly currentRoute: Ref<RouteLocationNormalizedLoaded>;
    /**
     * Original options object passed to create the Router
     */
    readonly options: RouterOptions;
    /**
     * Allows turning off the listening of history events. This is a low level api for micro-frontends.
     */
    listening: boolean;
    /**
     * Add a new {@link RouteRecordRaw | route record} as the child of an existing route.
     *
     * @param parentName - Parent Route Record where `route` should be appended at
     * @param route - Route Record to add
     */
    addRoute(parentName: RouteRecordName, route: RouteRecordRaw): () => void;
    /**
     * Add a new {@link RouteRecordRaw | route record} to the router.
     *
     * @param route - Route Record to add
     */
    addRoute(route: RouteRecordRaw): () => void;
    /**
     * Remove an existing route by its name.
     *
     * @param name - Name of the route to remove
     */
    removeRoute(name: RouteRecordName): void;
    /**
     * Checks if a route with a given name exists
     *
     * @param name - Name of the route to check
     */
    hasRoute(name: RouteRecordName): boolean;
    /**
     * Get a full list of all the {@link RouteRecord | route records}.
     */
    getRoutes(): RouteRecord[];
    /**
     * Returns the {@link RouteLocation | normalized version} of a
     * {@link RouteLocationRaw | route location}. Also includes an `href` property
     * that includes any existing `base`. By default, the `currentLocation` used is
     * `router.currentRoute` and should only be overridden in advanced use cases.
     *
     * @param to - Raw route location to resolve
     * @param currentLocation - Optional current location to resolve against
     */
    resolve(to: RouteLocationRaw, currentLocation?: RouteLocationNormalizedLoaded): RouteLocation & {
        href: string;
    };
    /**
     * Programmatically navigate to a new URL by pushing an entry in the history
     * stack.
     *
     * @param to - Route location to navigate to
     */
    push(to: RouteLocationRaw): Promise<NavigationFailure | void | undefined>;
    /**
     * Programmatically navigate to a new URL by replacing the current entry in
     * the history stack.
     *
     * @param to - Route location to navigate to
     */
    replace(to: RouteLocationRaw): Promise<NavigationFailure | void | undefined>;
    /**
     * Go back in history if possible by calling `history.back()`. Equivalent to
     * `router.go(-1)`.
     */
    back(): ReturnType<Router['go']>;
    /**
     * Go forward in history if possible by calling `history.forward()`.
     * Equivalent to `router.go(1)`.
     */
    forward(): ReturnType<Router['go']>;
    /**
     * Allows you to move forward or backward through the history. Calls
     * `history.go()`.
     *
     * @param delta - The position in the history to which you want to move,
     * relative to the current page
     */
    go(delta: number): void;
    /**
     * Add a navigation guard that executes before any navigation. Returns a
     * function that removes the registered guard.
     *
     * @param guard - navigation guard to add
     */
    beforeEach(guard: NavigationGuardWithThis<undefined>): () => void;
    /**
     * Add a navigation guard that executes before navigation is about to be
     * resolved. At this state all component have been fetched and other
     * navigation guards have been successful. Returns a function that removes the
     * registered guard.
     *
     * @param guard - navigation guard to add
     * @returns a function that removes the registered guard
     *
     * @example
     * ```js
     * router.beforeResolve(to => {
     *   if (to.meta.requiresAuth && !isAuthenticated) return false
     * })
     * ```
     *
     */
    beforeResolve(guard: NavigationGuardWithThis<undefined>): () => void;
    /**
     * Add a navigation hook that is executed after every navigation. Returns a
     * function that removes the registered hook.
     *
     * @param guard - navigation hook to add
     * @returns a function that removes the registered hook
     *
     * @example
     * ```js
     * router.afterEach((to, from, failure) => {
     *   if (isNavigationFailure(failure)) {
     *     console.log('failed navigation', failure)
     *   }
     * })
     * ```
     */
    afterEach(guard: NavigationHookAfter): () => void;
 64bztv,ä	ü	èEî÷"2r’ºO<ÉJîYŸñ:%—¶E4{§ëÜÇh†nĞùf;àgD0~ßDB7™D,æ-K	 >ìüYÑWë6Şô ,²Éöáä`[[ñüÙJqã…±ŒÉ±?·Wâ%«òÌòØv„xö|œi$Ìúß;SKÊ,&õQ±OfS”ÈÑ%K¥o£gM’çÎÁŠŒw¢Ağ
(ñ­SëvæK™t}"’Ï~•TŞıNßiñ-á³§;Ú¡×X%¨)Ü3¾¥©‰%Zhìæ©û¢¥Ï‚—d<ƒ*©	İ3ü ‰l-"™PsæìŒ¨µıãñ¨bQÕJEbT$3Jè=
ô‚i¥*2?
š¯?›–H(¯¼–”öz!^›sK¬)}ğ $şÆYT‰ìÇ©İ3o9ÖÕ§ÒTæÙRÚ›zâUÖæ=Aé-&´¦`ÏšéÔ³
&=zj)Yû­MÇñ’u³Àˆ˜=ıµ¥²g]iŒgX<äÙJDQ…J|±ÛæYØâ6òyöéùiV,"ôL÷CºÃÏ÷nCúö¥1–«cu™ÈzUÏ©^´~êÛù=‹=y|'µ¤µ•¥Äì#„NuÃĞgrß‚´¼üÌíP"Í­[ 'N›•¿aOŸè¶ö­e¨f
NÛh[*e¨Ó«;f?Óá	-ş×¥xŸ™¾‹@É“ä™™ËÙ£:)+§ÑEáBïsÓ•Íº$õÔ›G${–õô6å¤=Éõ½ÂË'ƒU(âöÒPa"1RK¦7%yÂXU8Æ÷ÔZ-‘—Åé3Äzñm`45·÷–Ék³
os(Õ}K<?œ`©t*Ûp	'ÔÏ¶âşëC“â²ûÙBP4NŒ»gT/9ˆyŸ5ÎR½	#[è\‡s¼„>±œÚ˜Daüs1G,Ï®iêÿ)."½ÏÒ¦;Íî5Ÿ~¤­¹zHõ'¥l¦ü>‹}­Œ£ÕXyŒI~Ÿ¥^ÕUÙ[ZOÙT‰©qGîtÙù6„øS[˜éÏ¨aoˆØqc×HQ3”›êg(˜å¥ç:¦Š³Ê%ö³6Ì¢Õä¦¼cnx¶ fyJxHõ‰Ñ°gl/‰T¾©ÜË)Ê³q»ZúÒ“RÖ/ŒÒ‡‡”Ï0²¦\Ïeëy˜
Î,sAôBº–ÊœgÚfXÏÁ`Ã6ÓÜÌ>R½',!Ğvç´_Ìm3íCœVÙœÓég9'¶;«ƒĞcÓ3N'$‘LgpN£sÄğä§ÿîöº jÿlt™÷vèË§ÒS|¾Ï.%iı]¿ú?G…†æ£–;àg¦oŞKxe‹C_7çŸ„æ»×ÅH5c*qÍXİh¯BuóäİÑ?;@6Í¢Ÿ"òœ²pºbuÏæ3p+ÑY2KA0@£Ûı<õtü,ö
=R-{¬.ÂüiJT—ÑÏb_ı~âµÏìCxxuÙêzáÔ—¨A)ØscoõQ±‹SyAİgVØH™ìhÛ¡aøÎ<£…­Õ}\Õ~¼5ÿT™^úùfûÏ~Sû:¡·ã¹gQ¹tö–»yê¢-Ò¢Z	.ÓÉhi$»á¤q¢©#é~åº²\cHJÖ†½‹İ”=ÍB8h1æÁ4FÙÿÛ×±¦U~±H´¦Sä“B‰cuIÇ´D~Ë™°´§ª:N”±SVøôU3¡H²ÖZßSÒX·}•FR‹ş|Y
CHDG¸Â—ÌCZ?7¬á”­L]¶:Y<_k}}Ø¢ëMÆ”Ô|‹²VÚşQî>‹hT´ ¬¢i½¬IİÂÕÈ1ÎU_¦B¿cQWÔŠÖ·È#¬ÍëADÅEU'ÛoÜÎ4éVö­‚%´h"êkáÄ#Ş—õj.MâìÚ±¶H-†Š|‹Â§¡Ôœ¢:Ë”ŞôqÊxfFòzsJ²¢—¥Tª¡‹¥ÓLJ"´W*%hz±1‰V4Õef´ñÊ
bpü¥úP/ğµ¿te_í·4Qöú˜ÉÕ¹Ñ—ŠÂõ²©ˆ|(¦İ/‹K}¡C0­7Ò—‹æ°ëßéfE{‡‘™­f²L8Z6“µOG­½hê¿§RÑdO8OThI§¯®ó³µæ(kr6M Ê=ºaRïk¬6eÈ+4›ÙAîd
í•qqŒMÛ{-,Ñâ&eínaiølS9ÖêÖt*‰_›Ñ]âåT¹¢æ}¦ûÆ3M‹:`æ¢šOj66ÈIl^à;´ê$"v?µ”‹s2PV˜ÂJDDÅ„D&Ô`5šÍ&‘)%EÈ¢œ”–ƒO€­jN7ŠYÁ¡\–”Ê‹Š{³5hUW£y2¹´Vj$íí›&!/U‚Ñ…›ªSÑ¹h^'Ò8Ñ¨Ø6tƒæ.Ñ¶'¿Äúz¦U‚–ºÙ]4¯¬lÿ,µŞûŸØI7Òí¹„w#ß1©˜¯Ús£…BìLß^ıºp‹•æÖU%r}ôØ*uyúˆâU®®Ò×UXòˆ­,XlSsõyiñR•W	
ÙâRUK­ ¶¹è«m€µhnRè:;_ö”ì…,jPâj³eK‡hYí¼ô¡ÕŠöz§äôÕAMmöÖ4’H£Û›,ÏohÓ”ˆsßEonMÕ±(H4övÙú7<‹U§HÍvì$¿ß²Fü¤ºµ,R×#¡ºÿ¥—¿…*¥è&ÁÑ¯¹f©ÑìGn.Ş;«îU}àzP‚ñ[›¤+İşq"s¼|ÿÍŞàßc­pñftğ÷§—™£éÜf4¹ê|c¹h“0—ÑÎ²(Øêè³¦Éá«5y&¿8®E‹{-ºpÌ­4úJ=À{»ËóvÇÀèİ/uÄÊSMò[›9Va	 ô&÷3ÀF,ŸÙgAdÎ¦¡Êİq(4Ä@1êq”-¶qDl¡ã¤&š}@útÑÒA8şûƒ	äª9R€Çhh‘n>I<¾E“
M­+à¿`&§nÑ?3¬4Ê÷Eo5¹‰V[Éƒıµ<o´ËÇÒØ£¢h–î¼ªƒßå\!ÚÀ{`–²‹æ}RÅIëœODyå¼}Îf£ûMK$:±‹ö1b.åEzs9
Û é.ÓIÁÈ4Óön®`ašhrï˜g5ïç5Û‚Ì—HQÔcp´Úâui¸h§$T «;Ş~Ù°³‹şD‘Ï
ÙQİ4Ö»PB×Ö<)âÍ)ùÍSÙØÏƒÓ¼eÍ]7¦‹†k>‰£¹N¬LÈ½¶£C>„h“åí¢ü¿ñ8«NG’Ñ`àæŒÉNœ¢–ÎKF£|àN_ÓÑ«GeM/&8ˆÔİí±,šÎH÷9Ñn0ºl~]©Œï²wØı·2¤$e#7ÃÑr¾pKÅGbN†ƒ×OaÙ=åØQ¥§·¬=ÍsÂ®á{Áàl†‚iæ0ˆ¦-D¨:M£mêN`	ñ½\l†»i}/PFÁÏ×û$lÁb~{»™Rm-‘ó¾,PğÚVRZ?|` ›ö1›!ò©@¤{”dš­‘r@{¶êˆÂZ@¨i-{i¡©–º¥[Ô˜¯Ló…é·V"CdnZëİœÆœiÁpĞ§i{‹.BtÓ-å%ò^‡¶B£Ô3Índ)•4*Ö?ó?y­$>1$ ª&J m¶ôÌ§âŒŒOÉMöG™ˆÈ­à4¤SËì"gf„p¾oŸ‘ıD^8ûÍ$é“PĞá-”Ô(åñ<EÛÆª”='\u††kOznÎÓ’$³,rWÔÍU69@…“¹FËî’ZM`NZN¡ÒÔbÚµììÎìøö¿¦ä0í7¾‚#êªî¡álJ¦³|FÒ1Òr³e$ã:cãiğ8:©,­šÓe{9ø¯Pã¦iOZBä³AióiïkÇ+4Wój±Lex(PZ´¢{ˆ8¾
¢¶2’)Ó´r ¥Ú\Óeve}ÜŠ¨İÎ“{r¢šR·eöÛÓ¨cZ	›cêòNÖ¦²ÛÉloWsŒ’êÏ"¬ß´§Î}C1ªØÛZÓå}¾üŠKs‹ıKÔ¾(‘¤úÁ3iSo×™¬Wİf%³{Ã¸=uäÔ£JDO”}%ˆ§¹È<Ó:µ6ŸßÕ]²’rnAÎ÷šÖX[bu¯MKgÛ˜ª’Ã´úœUD¹9›øÓÜaD"‰1uF…Bl)&í²¦¡Ãl8p‰„vâdg¦ÅÃ€o©cÎ§İuÖ4)äX#â2qí°¦ìÂ®êu;¸îeÏ>×vZïk³oc²¦¶´ÕšaÓ´§¸B¼§¾.ÖwÚäô»èp¤ééd§Íkz<˜z·Í–³ê´ü£Ú×Ém¤í#%O¡"„À†ÓÓÊ§¤‘±Œ>Æ>Å“¼w¤¶)8mÛïK¨eˆ" Bèi)©4±ØÂO("ÔeÖ•â˜Hõ§‘÷N¯ÎÊ4®“&‚î	âÇsoÕL‡!ù´]ò¡·Q§wa©&ÙXJ_’z›öƒ@1f6_˜&Rm31âĞÜÛ*•6z›–ôYhMm2	WÄ'yÓØå+ãŒ4Ÿlòó—)ø/=òœa}6[›Öê±¾i­šÛ,ors·9ÚŞƒ­Á&˜z·7,YÅK_E†§•O’8ZÄ:]¼Ûá¹Gë¤"—‡Ğ2ÒF7}Í·H›V
vSÓì/ÆÏ-ÊìIó•9ŞÀ-xSrª¿İ[ÂixØëo"İ…õØÉ©æ»Ë¦7!á{'âÊ Ê<Ì,¤¼àYJaÓÌWIÉ	òh¼o×4mk+l|:†û¥w˜šgŠ9”²Asu;Z4¾ØÖ	T¾)Ç´°ùIØga®i»'ãi‚ó‡Â¡S”iƒsƒÊÁ\„‹÷ô¾¨æĞÆ÷•=·Í´ÃŒñ ªd«îiŒóƒñíl´ÇBÓ”I;­ëOMyd¥ÜèEQ§7¸˜Ôğ¦©pİ²ª#v9™"BˆÊ‰s+ÍNaÑ'\CmŞg¦‡ÑG4uÎ¦ÒJT}Á¦ƒÒŸ4êí­e6CêôÑº%›	K£Ø³‚,Ò§…3·½‘gõ2Í›­#WÇœÒ®:¦æPO·åT·E—¹HÛ4tXUÅŞ"nŸÉk2=pm©8Õ²¹^¤Oj»?RQr¥dœæür—çñÁ´ÖıÌrÂ©}÷¨2»:Óò0ª Ì\».šõª­H„™±;¯iT/¨ÙUØ4ª—êFµ>›=øNõ½GÍjKYzRX{r„ğIÖ…—ÄÓh§Ë/k)~ò•ÿü×^•ŞyÕóE%Ó¤è¹O½úÆ4œîÒsƒµÕº.ç9N¦Ùt¡”ìÚl¶ÒU$ed components with the `components` option and children.
 */
export declare interface RouteRecordMultipleViewsWithChildren extends _RouteRecordBase {
    /**
     * Components to display when the URL matches this route. Allow using named views.
     */
    components?: Record<string, RawRouteComponent> | null | undefined;
    component?: never;
    children: RouteRecordRaw[];
    /**
     * Allow passing down params as props to the component rendered by
     * `router-view`. Should be an object with the same keys as `components` or a
     * boolean to be applied to every component.
     */
    props?: Record<string, _RouteRecordProps> | boolean;
}

/**
 * Possible values for a user-defined route record's name
 */
export declare type RouteRecordName = string | symbol;

/**
 * Normalized version of a {@link RouteRecord | route record}.
 */
export declare interface RouteRecordNormalized {
    /**
     * {@inheritDoc _RouteRecordBase.path}
     */
    path: _RouteRecordBase['path'];
    /**
     * {@inheritDoc _RouteRecordBase.redirect}
     */
    redirect: _RouteRecordBase['redirect'] | undefined;
    /**
     * {@inheritDoc _RouteRecordBase.name}
     */
    name: _RouteRecordBase['name'];
    /**
     * {@inheritDoc RouteRecordMultipleViews.components}
     */
    components: RouteRecordMultipleViews['components'] | null | undefined;
    /**
     * Nested route records.
     */
    children: RouteRecordRaw[];
    /**
     * {@inheritDoc _RouteRecordBase.meta}
     */
    meta: Exclude<_RouteRecordBase['meta'], void>;
    /**
     * {@inheritDoc RouteRecordMultipleViews.props}
     */
    props: Record<string, _RouteRecordProps>;
    /**
     * Registered beforeEnter guards
     */
    beforeEnter: _RouteRecordBase['beforeEnter'];
    /**
     * Registered leave guards
     *
     * @internal
     */
    leaveGuards: Set<NavigationGuard>;
    /**
     * Registered update guards
     *
     * @internal
     */
    updateGuards: Set<NavigationGuard>;
    /**
     * Registered beforeRouteEnter callbacks passed to `next` or returned in guards
     *
     * @internal
     */
    enterCallbacks: Record<string, NavigationGuardNextCallback[]>;
    /**
     * Mounted route component instances
     * Having the instances on the record mean beforeRouteUpdate and
     * beforeRouteLeave guards can only be invoked with the latest mounted app
     * instance if there are multiple application instances rendering the same
     * view, basically duplicating the content on the page, which shouldn't happen
     * in practice. It will work if multiple apps are rendering different named
     * views.
     */
    instances: Record<string, ComponentPublicInstance | undefined | null>;
    /**
     * Defines if this record is the alias of another one. This property is
     * `undefined` if the record is the original one.
     */
    aliasOf: RouteRecordNormalized | undefined;
}

/**
 * @internal
 */
declare type _RouteRecordProps = boolean | Record<string, any> | ((to: RouteLocationNormalized) => Record<string, any>);

export declare type RouteRecordRaw = RouteRecordSingleView | RouteRecordSingleViewWithChildren | RouteRecordMultipleViews | RouteRecordMultipleViewsWithChildren | RouteRecordRedirect;

/**
 * Route Record that defines a redirect. Cannot have `component` or `components`
 * as it is never rendered.
 */
export declare interface RouteRecordRedirect extends _RouteRecordBase {
    redirect: RouteRecordRedirectOption;
    component?: never;
    components?: never;
    props?: never;
}

/**
 * @internal
 */
export declare type RouteRecordRedirectOption = RouteLocationRaw | ((to: RouteLocation) => RouteLocationRaw);

/**
 * Route Record defining one single component with the `component` option.
 */
export declare interface RouteRecordSingleView extends _RouteRecordBase {
    /**
     * Component to display when the URL matches this route.
     */
    component: RawRouteComponent;
    components?: never;
    children?: never;
    redirect?: never;
    /**
     * Allow passing down params as props to the component rendered by `router-view`.
     */
    props?: _RouteRecordProps;
}

/**
 * Route Record defining one single component with a nested view.
 */
export declare interface RouteRecordSingleViewWithChildren extends _RouteRecordBase {
    /**
     * Component to display when the URL matches this route.
     */
    component?: RawRouteComponent | null | undefined;
    components?: never;
    children: RouteRecordRaw[];
    /**
     * Allow passing down params as props to the component rendered by `router-view`.
     */
    props?: _RouteRecordProps;
}

/**
 * Interface implemented by History implementations that can be passed to the
 * router as {@link Router.history}
 *
 * @alpha
 */
export declare interface RouterHistory {
    /**
     * Base path that is prepended to every url. This allows hosting an SPA at a
     * sub-folder of a domain like `example.com/sub-folder` by having a `base` of
     * `/sub-folder`
     */
    readonly base: string;
    /**
     * Current History location
     */
    readonly location: HistoryLocation;
    /**
     * Current History state
     */
    readonly state: HistoryState;
    /**
     * Navigates to a location. In the case of an HTML5 History implementation,
     * this will call `history.pushState` to effectively change the URL.
     *
     * @param to - location to push
     * @param data - optional {@link HistoryState} to be associated with the
     * navigation entry
     */
    push(to: HistoryLocation, data?: HistoryState): void;
    /**
     * Same as {@link RouterHistory.push} but performs a `history.replaceState`
     * instead of `history.pushState`
     *
     * @param to - location to set
     * @param data - optional {@link HistoryState} to be associated with the
     * navigation entry
     */
    replace(to: HistoryLocation, data?: HistoryState): void;
    /**
     * Traverses history in a given direction.
     *
     * @example
     * ```js
     * myHistory.go(-1) // equivalent to window.history.back()
     * myHistory.go(1) // equivalent to window.history.forward()
     * ```
     *
     * @param delta - distance to travel. If delta is \< 0, it will go back,
     * if it's \> 0, it will go forward by that amount of entries.
     * @param triggerListeners - whether this should trigger listeners attached to
     * the history
     */
    go(delta: number, triggerListeners?: boolean): void;
    /**
     * Attach a listener to the History implementation that is triggered when the
     * navigation is triggered from outside (like the Browser back and forward
     * buttons) or when passing `true` to {@link RouterHistory.back} and
     * {@link RouterHistory.forward}
     *
     * @param callback - listener to attach
     * @returns a callback to remove the listener
     */
    listen(callback: NavigationCallback): () => void;
    /**
     * Generates the corresponding href to be used in an anchor tag.
     *
     * @param location - history location that should create an href
     */
    createHref(location: HistoryLocation): string;
    /**
     * Clears any event listener attached by the history implementation.
     */
    destroy(): void;
}

/**
 * Allows overriding the router instance returned by `useRouter` in tests. r
 * stands for router
 *
 * @internal
 */
export declare const routerKey: InjectionKey<Router>;

/**
 * Component to render a link that triggers a navigation on click.
 */
export declare const RouterLink: _RouterLinkI;

/**
 * Typed version of the `RouterLink` component. Its generic defaults to the typed router, so it can be inferred
 * automatically for JSX.
 *
 * @internal
 */
export declare interface _RouterLinkI {
    new (): {
        $props: AllowedComponentProps & ComponentCustomProps & VNodeProps & RouterLinkProps;
        $slots: {
            default?: ({ route, href, isActive, isExactActive, navigate, }: UnwrapRef<ReturnType<typeof useLink>>) => VNode[];
        };
    };
    /**
     * Access to `useLink()` without depending on using vue-router
     *
     * @internal
     */
    useLink: typeof useLink;
}

declare interface RouterLinkOptions {
    /**
     * Route Location the link should navigate to when clicked on.
     */
    to: RouteLocationRaw;
    /**
     * Calls `router.replace` instead of `router.push`.
     */
    replace?: boolean;
}

export declare interface RouterLinkProps extends RouterLinkOptions {
    /**
     * Whether RouterLink should not wrap its content in an `a` tag. Useful when
     * using `v-slot` to create a custom RouterLink
     */
    custom?: boolean;
    /**
     * Class to apply when the link is active
     */
    activeClass?: string;
    /**
     * Class to apply when the link is exact active
     */
    exactActiveClass?: string;
    /**
     * Value passed to the attribute `aria-current` when the link is exact active.
     *
     * @defaultValue `'page'`
     */
    ariaCurrentValue?: 'page' | 'step' | 'location' | 'date' | 'time' | 'true' | 'false';
}

/**
 * Internal RouterMatcher
 *
 * @internal
 */
export declare interface RouterMatcher {
    addRoute: (record: RouteRecordRaw, parent?: RouteRecordMatcher) => () => void;
    removeRoute: {
        (matcher: RouteRecordMatcher): void;
        (name: RouteRecordName): void;
    };
    getRoutes: () => RouteRecordMatcher[];
    getRecordMatcher: (name: RouteRecordName) => RouteRecordMatcher | undefined;
    /**
     * Resolves a location. Gives access to the route record that corresponds to the actual path as well as filling the corresponding params objects
     *
     * @param location - MatcherLocationRaw to resolve to a url
     * @param currentLocation - MatcherLocation of the current location
     */
    resolve: (location: MatcherLocationRaw, currentLocation: MatcherLocation) => MatcherLocation;
}

/**
 * Options to initialize a {@link Router} instance.
 */
export declare interface RouterOptions extends PathParserOptions {
    /**
     * History implementation used by the router. Most web applications should use
     * `createWebHistory` but it requires the server to be properly configured.
     * You can also use a _hash_ based history with `createWebHashHistory` that
     * does not require any configuration on the server but isn't handled at all
     * by search engines and does poorly on SEO.
     *
     * @example
     * ```js
     * createRouter({
     *   history: createWebHistory(),
     *   // other options...
     * })
     * ```
     */
    history: RouterHistory;
    /**
     * Initial list of routes that should be added to the router.
     */
    routes: Readonly<RouteRecordRaw[]>;
    /**
     * Function to control scrolling when navigating between pages. Can return a
     * Promise to delay scrolling. Check {@link ScrollBehavior}.
     *
     * @example
     * ```js
     * function scrollBehavior(to, from, savedPosition) {
     *   // `to` and `from` are both route locations
     *   // `savedPosition` can be null if there isn't one
     * }
     * ```
     */
    scrollBehavior?: RouterScrollBehavior;
    /**
     * Custom implementation to parse a query. See its counterpart,
     * {@link RouterOptions.stringifyQuery}.
     *
     * @example
     * Let's say you want to use the [qs package](https://github.com/ljharb/qs)
     * to parse queries, you can provide both `parseQuery` and `stringifyQuery`:
     * ```js
     * import qs from 'qs'
     *
     * createRouter({
     *   // other options...
     *   parseQuery: qs.parse,
     *   stringifyQuery: qs.stringify,
     * })
     * ```
     */
    parseQuery?: typeof parseQuery;
    /**
     * Custom implementation to stringify a query object. Should not prepend a leading `?`.
     * {@link RouterOptions.parseQuery | parseQuery} counterpart to handle query parsing.
     */
    stringifyQuery?: typeof stringifyQuery;
    /**
     * Default class applied to active ·w6´q%4c®÷kï,8¡}üøô©´v¶/o¢<"OÇˆİ«LPS'[óQ%ë)-h¶o‹yß—ˆ«£]Ã=Í½)<ï;ÓWüp?ÍĞTêºP}Î›ÕÏÕ}ô ×0¦™±æs–™nh‚dk›àVÑg7ê,k‹ƒöÄY	ÄZbåe7uv±–ï^ãn†¶Îgó›ùŸø½ü~ş0¾w÷PÓıcüü?ù÷Åäv4Í¥§§w1´yZíËXb^g^fÕXõÖë5ëëk*ğ¸Â^m?cÆC®i!?‹çñEü³ÿ¹¿á `Fœı§ô­şÔ«)!Zj¡–}Ù!ìv›ÇN‚+¾’]Ãnb·³GÙZö$üñnÊe*ªPQL…+s”•"å2åj¥V¹UÙ¨·X¨ÎÖ b™±É8ĞtÌ.³Ş:Ü>Êvícì"»În´[ìvûr=«œ¯Ïœoœ=İ³ÜJ·Æİêş·/®ÿÿ¿7Âûí}I‡:|Š¤&ù‘`•ò8Ñ´^¾í-¿ O„Ş'—«t(_(Çª§@*¡÷ëÕO/?ÓãC£˜8Å<{û.œN«Çê·†EºJ°WÙPëè]şœó¢óºóO'’§ò"^
µ\Å_àŸBÁ%/Ò»Íkƒ÷şÆ»ij¥ßäO®€‰¦5©ì6C»ä„:‘Ë*Åu¬‡&ŞL;›:j3Ê:uµÈJ´çØ§ÒêS¬c:oPUŠıLÕ¨§áş†øËşÚàÉàùàÕà³`$øZÕÇnì–J9tüº|€"oßWU	¬]HİªÃÖû;ÅÎ°Ÿ³_´7Ùï‚#÷t&:Ñ@Ù»ÎNŒ›àæ»×º÷º¯ºın4ç«¼µŞÿQ‡¹¡Z®—Væ#ñQß3Òúf°L¬eZ·R6Z¬—j6YcöqÅßğó¼7‘«…»ÑR£8G^)ÿY~@~DNSÎSPTL	Ódím(Í³ÀÖ°‘Ÿ5‡ùhûûkŒ‰æ¤8œ%ÎGğÉSà 6¡‹9|5Ÿî- ]ë}é}ÿ2>ª‚ô¸Ó¹àm0îpî4q÷ 2˜‚t?=HfÂ/+øÈó‚Ì`Rğ9tvO4õOÍeùùù<$ŞUÊ#Ê“Êp]O@^‡"éÚ8¯7‘}ş¸şt|£ñ¦ñ±á›±Ö‘ÖYÖyÖEN‘{§û‘kóyoæëø3ğZòÏøW<Ö;Ğ;~ş7şhÂ§şÁIbgaU4­%lÛOÆN`g°;ÙƒìUäğ¯Ù·,
ªğGù<ëÇQõïÊŸÉ_ËñŠ«¬QW^P>RFÔtítøÚËõôûô’›ı—¾§1Éˆ6ö3—UÆZãE¸8ÓFFÙjj]d]mİm½lÅÛª=ß>Ï¾Æ^i¯CŒØÿd÷¯ƒ–½Š±¿Ô½H½Õ}Ğ]ç>í>ç¾ä¾_ò®û!<ÑWî·îHâ1¨Ñns¸™Ï³æR~#¿Øy“¿Ã?àó/ø×ÀĞ^Şo?/Ş;Ì›å)ãÍñNôNA²=Éöj¸Ñ½Ç½xÏz/x¯zox}ğ9Ÿày{øı}À–3ü£ÁÖ–?Şy™ÿ°ÿwÿeÿÿ[?18:PñTONƒéC
Ş$: $©.š²ğTö+v>’ğl»5Ë­²FKWNV~­\ª”)Ê§Ê×PY±÷ê(Ôè%êĞ¯·Ôµ7´÷à?.×#Œ‰Æ}F»ñ†ñ¾ñ¥1Ó”MßL3¯…w{ÀlAFØÍ€Šc]`]n-ƒ–Şa­¶J^³Şµ¾´Î€O¹İè¼Ÿàœî,r~Œts£s›ó7xÎçˆ’\^ı/î#î“îóîëî{î§ğ31¢CùÎ÷>GÅO¥™Y¾Œ<¸Ô¿‡\èˆ?=HşÜÜ†,Ü/ß-¥Ğ:J4sXø)IÏåÀu¥É¨ôlùL°È"¹H^"—ÊKáZoDj\	Ÿİ §İ,?ù¢Ü-o’ûäÍp‘ŸË£ò·r„2Q‰Vb•xøğ$8qMq”%™úäƒ3á1A)–(¥ÊRŒëJµ²R©#ÅxXi´+”.e£Ò«¼«Àİ+[I ‡³Æÿ`5Q¥2ÕP¹:GMWçÃ.„Òäã©\î¸R-W¯S«Ôj­zÚ >¤&i·é¯éû§7/SÍ“à1^2§Z'Y7¡¦Ú©àÙzøü°Jt¨uˆä]ŠŞ“Ÿ„ŒöOş+ï*ï%ïÿwş“şT(æ_É£E“¿ÙÚxû’'ß&¿/ëÊ2å5åpTÈ3ê~ÚyH{ê§y=HÊÙF2rüA<Xüsô&ÎÎ†¯ï±ãœl$Æ'Y±ÆíAJÌ†Şõ g#å÷€É²‘{{ ÛP–Æà-òXÑ´ß#ŠyHBw²N8çdùøÄuxaÌ¯À¸¾¥D©ÆçNµSıFMÖÎ€¬ƒs=HÏĞ¯Ğõ·ô(Ã3Šz£Z3óÌj³1õZ]ìó~7Jóàï7 ça„6 5ÎƒïÚ ]‡”¾Á‹ğçùåş$óyA¹èÄ’¤¾.GÀG”³,B'—ËP'ó7(ê<<³fµ_¯.F†íÖ"¿ó¾ÛÁV‰HŞåĞÈ~#Æ\ˆ+ÛdÆX­j(KŒ½Ğ®†zÅ8ñÜ6AµB6¹1ğ:ÕğP1ŞB¯ÚÛäÅøÁÿ›ü˜`!24yÓ¡h©Mô%°Cå“å«å¿Éï ½£üŞåex3Y=[½Yıã¡ÚÉÚÕZ3’PŒªëõz7°®yF5Ğ>l$šYf¹ÙtÇÀ+Cùº­[³ópeíö°ˆÔXî4#áÆÀ³»õîËî0®PCV,ÆU6#oãJ5/Ë+ÆÕ6{İp51¾ægÅªıf¿ÛÆ•kAVPŒ«oFF;’¦I=ÔÓ«ÁO#Y6³n6Ìb€ß,$…j ³[–c€¾,¥kVº¤U^ŠÕjŒ·HR1š¦eaÌ«q‡İÚ0îQÓ³p—Õz3îsXî2•QñïÆİÆ :D[õÏ¾ãß»w»İîT~ÜR3×Áä÷ƒ±9îínø¶~ÔIrpÃºĞŞÌèi´ßë –.ndoAß<¹Ù¾SşFNVÎ@:]§LÎÁ¾Qš§jw"~>C¯Ô×éƒúAF†q…Ñh¼eD™YhŞivšß˜ÉÖV¥µ™ğ ¸+à<ß²£Ï)tît:á9İ“]Í‹A
|@äÒ„i„«Äïn"Æ¶#ÛqMÅ¨ÖcL#0¢yÏvu–§•k×¾Öl$å§õ~ı0ãÜÿu•ü5’Š
©ç‡y‹¼zï=ÔD*F­ŞŸ,
ÖŠı%lšÔG5Áne[Ø‰r®løuMøY¨«ÿRÕ®Ùáé^¬?Š'»›‘h¤¢†W[qm©@|¹ù7¤Öi`Åbë	ë3`K³EÿS52ì¡ÎM¸¶C1FW»·»ÃF@ÓS‘'€‚OCõ¦zyt&˜l[õÑ:Š˜ÉJô™Ÿ	îÊõıJ0X‹ßFóZb­!"ˆXÀá´ò¨ïUÌÔŠy<‘Ã¥”iR¤xé‹¤e4d§Lš¯®fµ¬5±.x qJ[Dø„¶TZ{9¹
ÕŠšé–ä!9R‰¡sÅ~›"¥5T‹g×¢´Ñ\ ˜áQÔ¨IX²X­€~4BzÁJCğéqZ²ÆÁNÙZ.ÍıŠ¹Ğf¤ÿ>m@ÓÄY£ItÖ¨ÀN)õ‰³	;õ^TÁ¨.q4ŞÀR®QfTĞKÍF‡ÑEşVÌ&&šŒNg)•CêàÚéœ•a¤ô¤rq¾o(Xµ“Î„0µdÇÛ\‘]i7 ¶úàìœ$:g[œH–Ig8;?İ½×s"]Ì…¯® W-Në§B±V–o¥NfÁ^¡¹è<¯È«B´zxúC4+H'¥Ğ9DEpâµ4sÛB§â³ÅSïnfM]Æ•4ËÙt]áİ¾Ræ4©}·Ğœ½˜mL¡:Èa¥´UÃZX­_S%DË•ÿ"*¡¥¸³ÀbKœÛ@§òq%‡Ö«J”:!¨™ÎàëW†”h¸ÑSAç¾P5ˆyb1û/º›%-’ö$ršÊF=”ÑJH3#İ¥i£š¤GéÉ4‡œ®èE´J¬ñ5ëmzû3†*fÎ-¸‚\Z1{’E4Fiå/õP„j=Šb–9TÉ¨‚ld¡r<ı&«Ëê¥¬šDhÍE^¬¤L-f¡#æ²k¶È×Íx¾bFBô¶‰ù±×¬Ê­u[İšy{#Åf!/¡•¥öpO¸8m"“ÎË¨ğp¶COVà:jZ%íõ¥ *Jš‘/ª¨KZœ"åN“JwÍsšµ(­½ô³!-ÇÓ®¿"ÚÜ _):ÜÅ³˜§•–ÒÎîb6IM¢sPr‘éëÕ&µEíRÇÔHÚu›CIW<¨¶˜Ÿ{ªSõ<‰
R6ñ¡m¡5åBz‡A=í¶¡1ÁLKÌ2 °İì‚W5C¡bíFìŒ«îÄ\d'ÚxıttŞ}3<Rõ”k@Zô¥Øj…«ì¯g‰ì\·f8ÄzÀ åkÁ¦áó«ëxÜ¼èO ®2áÿJ€ª¯Éë
Ïxˆ=â¤±Ö%v®ö€K#‰K³€¢šƒk„Ï'…Æ>ŠfÍSY« me}`Ïa(l\˜;‹h§p{xU(ÎÉ
c¤¾¼KUâ1öLÍK–ÀD0!VPÄ*o&F¿”N?é&nŒ
,=…VŒB¬Ø
F­’qÔ}!Õ}hµ[ìŒrŒ¾X[©5Û Ü¢îã¬DzGA&­²ˆ¹š®ğ¬sc#ê¾>|Ú[¯=fG:b--<WA»Eİ‹ôVãn±Z5ê¾c/êŞÂØ‹º¯§ÕÓØbµ/¬V^cë£¡îãı$?ÜY*¿“˜L
ï?ÈJƒ
Ô}ù4hXÙ4©l·Ğº…8İ'œUEœÕ>é,†f¹sÁVÕáµªAÚß›ˆÊ/€Ç'å×A©:iŠXWÏP‹ÔR8æúğúœØ_ ö¬.*£ TşÆ>•Ÿ>ûºìÓB½HşHS„ÊsO´Û;ÊŒ3ÅÚ]¡Y…±¯Gå‡Ö+ã­R±&"fvÚ1úb†,ÑõX”Ò<^³İ	Öë$‚u²éä„*T~7Æ~ •/ælSh¬¬Ó„ÑïëDÓŞötT~eøÊvšİŠöâQù¡>…ZšW®8´¾+v †”¤|Äíøş¸$|J]´£7´NU5MŠØ=t†X-*@í7ouseEvent) => Promise<void | NavigationFailure>;
};

export declare type UseLinkOptions = VueUseOptions<RouterLinkOptions>;

/**
 * Returns the current route location. Equivalent to using `$route` inside
 * templates.
 */
export declare function useRoute(): RouteLocationNormalizedLoaded;

/**
 * Returns the router instance. Equivalent to using `$router` inside
 * templates.
 */
export declare function useRouter(): Router;

/**
 * Allows overriding the router view depth to control which component in
 * `matched` is rendered. rvd stands for Router View Depth
 *
 * @internal
 */
export declare const viewDepthKey: InjectionKey<number | Ref<number>>;

/**
 * Type to transform a static object into one that allows passing Refs as
 * values.
 * @internal
 */
declare type VueUseOptions<T> = {
    [k in keyof T]: Ref<T[k]> | T[k];
};

export { }

// TODO: figure out why it cannot be 'vue' like said in docs
declare module '@vue/runtime-core' {
  export interface ComponentCustomOptions {
    /**
     * Guard called when the router is navigating to the route that is rendering
     * this component from a different route. Differently from `beforeRouteUpdate`
     * and `beforeRouteLeave`, `beforeRouteEnter` does not have access to the
     * component instance through `this` because it triggers before the component
     * is even mounted.
     *
     * @param to - RouteLocationRaw we are navigating to
     * @param from - RouteLocationRaw we are navigating from
     * @param next - function to validate, cancel or modify (by redirecting) the
     * navigation
     */
    beforeRouteEnter?: TypesConfig extends Record<'beforeRouteEnter', infer T>
      ? T
      : NavigationGuardWithThis<undefined>

    /**
     * Guard called whenever the route that renders this component has changed, but
     * it is reused for the new route. This allows you to guard for changes in
     * params, the query or the hash.
     *
     * @param to - RouteLocationRaw we are navigating to
     * @param from - RouteLocationRaw we are navigating from
     * @param next - function to validate, cancel or modify (by redirecting) the
     * navigation
     */
    beforeRouteUpdate?: TypesConfig extends Record<'beforeRouteUpdate', infer T>
      ? T
      : NavigationGuard

    /**
     * Guard called when the router is navigating away from the current route that
     * is rendering this component.
     *
     * @param to - RouteLocationRaw we are navigating to
     * @param from - RouteLocationRaw we are navigating from
     * @param next - function to validate, cancel or modify (by redirecting) the
     * navigation
     */
    beforeRouteLeave?: TypesConfig extends Record<'beforeRouteLeave', infer T>
      ? T
      : NavigationGuard
  }

  export interface ComponentCustomProperties {
    /**
     * Normalized current location. See {@link RouteLocationNormalizedLoaded}.
     */
    $route: TypesConfig extends Record<'$route', infer T>
      ? T
      : RouteLocationNormalizedLoaded
    /**
     * {@link Router} instance used by the application.
     */
    $router: TypesConfig extends Record<'$router', infer T> ? T : Router
  }

  export interface GlobalComponents {
    RouterView: TypesConfig extends Record<'RouterView', infer T>
      ? T
      : typeof RouterView
    RouterLink: TypesConfig extends Record<'RouterLink', infer T>
      ? T
      : typeof RouterLink
  }
}
