import htmlDecodeTree from "./generated/decode-data-html.js";
import xmlDecodeTree from "./generated/decode-data-xml.js";
import decodeCodePoint, { replaceCodePoint, fromCodePoint, } from "./decode_codepoint.js";
// Re-export for use by eg. htmlparser2
export { htmlDecodeTree, xmlDecodeTree, decodeCodePoint };
export { replaceCodePoint, fromCodePoint } from "./decode_codepoint.js";
var CharCodes;
(function (CharCodes) {
    CharCodes[CharCodes["NUM"] = 35] = "NUM";
    CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
    CharCodes[CharCodes["EQUALS"] = 61] = "EQUALS";
    CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
    CharCodes[CharCodes["NINE"] = 57] = "NINE";
    CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
    CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
    CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
    CharCodes[CharCodes["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes[CharCodes["UPPER_A"] = 65] = "UPPER_A";
    CharCodes[CharCodes["UPPER_F"] = 70] = "UPPER_F";
    CharCodes[CharCodes["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
/** Bit that needs to be set to convert an upper case ASCII character to lower case */
const TO_LOWER_BIT = 0b100000;
export var BinTrieFlags;
(function (BinTrieFlags) {
    BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code) {
    return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||
        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F));
}
function isAsciiAlphaNumeric(code) {
    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||
        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||
        isNumber(code));
}
/**
 * Checks if the given character is a valid end character for an entity in an attribute.
 *
 * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
 * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
 */
function isEntityInAttributeInvalidEnd(code) {
    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function (EntityDecoderState) {
    EntityDecoderState[EntityDecoderState["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState[EntityDecoderState["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState[EntityDecoderState["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState[EntityDecoderState["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState[EntityDecoderState["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
export var DecodingMode;
(function (DecodingMode) {
    /** Entities in text nodes that can end with any character. */
    DecodingMode[DecodingMode["Legacy"] = 0] = "Legacy";
    /** Only allow entities terminated with a semicolon. */
    DecodingMode[DecodingMode["Strict"] = 1] = "Strict";
    /** Entities in attributes have limitations on ending characters. */
    DecodingMode[DecodingMode["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
/**
 * Token decoder with support of writing partial entities.
 */
export class EntityDecoder {
    constructor(
    /** The tree used to decode entities. */
    decodeTree, 
    /**
     * The function that is called when a codepoint is decoded.
     *
     * For multi-byte named entities, this will be called multiple times,
     * with the second codepoint, and the same `consumed` value.
     *
     * @param codepoint The decoded codepoint.
     * @param consumed The number of bytes consumed by the decoder.
     */
    emitCodePoint, 
    /** An object that is used to produce errors. */
    errors) {
        this.decodeTree = decodeTree;
        this.emitCodePoint = emitCodePoint;
        this.errors = errors;
        /** The current state of the decoder. */
        this.state = EntityDecoderState.EntityStart;
        /** Characters that were consumed while parsing an entity. */
        this.consumed = 1;
        /**
         * The result of the entity.
         *
         * Either the result index of a numeric entity, or the codepoint of a
         * numeric entity.
         */
        this.result = 0;
        /** The current index in the decode tree. */
        this.treeIndex = 0;
        /** The number of characters that were consumed in excess. */
        this.excess = 1;
        /** The mode in which the decoder is operating. */
        this.decodeMode = DecodingMode.Strict;
    }
    /** Resets the instance to make it reusable. */
    startEntity(decodeMode) {
        this.decodeMode = decodeMode;
        this.state = EntityDecoderState.EntityStart;
        this.result = 0;
        this.treeIndex = 0;
        this.excess = 1;
        this.consumed = 1;
    }
    /**
     * Write an entity to the decoder. This can be called multiple times with partial entities.
     * If the entity is incomplete, the decoder will return -1.
     *
     * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
     * entity is incomplete, and resume when the next string is written.
     *
     * @param string The string containing the entity (or a continuation of the entity).
     * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    write(str, offset) {
        switch (this.state) {
            case EntityDecoderState.EntityStart: {
                if (str.charCodeAt(offset) === CharCodes.NUM) {
                    this.state = EntityDecoderState.NumericStart;
                    this.consumed += 1;
                    return this.stateNumericStart(str, offset + 1);
                }
                this.state = EntityDecoderState.NamedEntity;
                return this.stateNamedEntity(str, offset);
            }
            case EntityDecoderState.NumericStart: {
                return this.stateNumericStart(str, offset);
            }
            case EntityDecoderState.NumericDecimal: {
                return this.stateNumericDecimal(str, offset);
            }
            case EntityDecoderState.NumericHex: {
                return this.stateNumericHex(str, offset);
            }
            case EntityDecoderState.NamedEntity: {
                return this.stateNamedEntity(str, offset);
            }
        }
    }
    /**
     * Switches between the numeric decimal and hexadecimal states.
     *
     * Equivalent to the `Numeric character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericStart(str, offset) {
        if (offset >= str.length) {
            return -1;
        }
        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
            this.state = EntityDecoderState.NumericHex;
            this.consumed += 1;
            return this.stateNumericHex(str, offset + 1);
        }
        this.state = EntityDecoderState.NumericDecimal;
        return this.stateNumericDecimal(str, offset);
    }
    addToNumericResult(str, start, end, base) {
        if (start !== end) {
            const digitCount = end - start;
            this.result =
                this.result * Math.pow(base, digitCount) +
                    parseInt(str.substr(start, digitCount), base);
            this.consumed += digitCount;
        }
    }
    /**
     * Parses a hexadecimal numeric entity.
     *
     * Equivalent to the `Hexademical character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericHex(str, offset) {
        const startIdx = offset;
        while (offset < str.length) {
            const char = str.charCodeAt(offset);
            if (isNumber(char) || isHexadecimalCharacter(char)) {
                offset += 1;
            }
            else {
                this.addToNumericResult(str, startIdx, offset, 16);
                return this.emitNumericEntity(char, 3);
            }
        }
        this.addToNumericResult(str, startIdx, offset, 16);
        return -1;
    }
    /**
     * Parses a decimal numeric entity.
     *
     * Equivalent to the `Decimal character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNumericDecimal(str, offset) {
        const startIdx = offset;
        while (offset < str.length) {
            const char = str.charCodeAt(offset);
            if (isNumber(char)) {
                offset += 1;
            }
            else {
                this.addToNumericResult(str, startIdx, offset, 10);
                return this.emitNumericEntity(char, 2);
            }
        }
        this.addToNumericResult(str, startIdx, offset, 10);
        return -1;
    }
    /**
     * Validate and emit a numeric entity.
     *
     * Implements the logic from the `Hexademical character reference start
     * state` and `Numeric character reference end state` in the HTML spec.
     *
     * @param lastCp The last code point of the entity. Used to see if the
     *               entity was terminated with a semicolon.
     * @param expectedLength The minimum number of characters that should be
     *                       consumed. Used to validate that at least one digit
     *                       was consumed.
     * @returns The number of characters that were consumed.
     */
    emitNumericEntity(lastCp, expectedLength) {
        var _a;
        // Ensure we consumed at least one digit.
        if (this.consumed <= expectedLength) {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
        }
        // Figure out if this is a legit end of the entity
        if (lastCp === CharCodes.SEMI) {
            this.consumed += 1;
        }
        else if (this.decodeMode === DecodingMode.Strict) {
            return 0;
        }
        this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
        if (this.errors) {
            if (lastCp !== CharCodes.SEMI) {
                this.errors.missingSemicolonAfterCharacterReference();
            }
            this.errors.validateNumericCharacterReference(this.result);
        }
        return this.consumed;
    }
    /**
     * Parses a named entity.
     *
     * Equivalent to the `Named character reference state` in the HTML spec.
     *
     * @param str The string containing the entity (or a continuation of the entity).
     * @param offset The current offset.
     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
     */
    stateNamedEntity(str, offset) {
        const { decodeTree } = this;
        let current = decodeTree[this.treeIndex];
        // The mask is the number of bytes of the value, including the current byte.
        let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
        for (; offset < str.length; offset++, this.excess++) {
            const char = str.charCodeAt(offset);
            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
            if (this.treeIndex < 0) {
                return this.result === 0 ||
                    // If we are parsing an attribute
                    (this.decodeMode === DecodingMode.Attribute &&
                        // We shouldn't have consumed any characters after the entity,
                        (valueLength === 0 ||
                            // And there should be no invalid characters.
                            isEntityInAttributeInvalidEnd(char)))
                    ? 0
                    : this.emitNotTerminatedNamedEntity();
            }
            current = decodeTree[this.treeIndex];
            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            // If the branch is a value, store it and continue
            if (valueLength !== 0) {
                // If the entity is terminated by a semicolon, we are done.
                if (char === CharCodes.SEMI) {
                    return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
                }
                // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.
                if (this.decodeMode !== DecodingMode.Strict) {
                    this.result = this.treeIndex;
                    this.consumed += this.excess;
                    this.excess = 0;
                }
            }
        }
        return -1;
    }
    /**
     * Emit a named entity that was not terminated with a semicolon.
     *
     * @returns The number of characters consumed.
     */
    emitNotTerminatedNamedEntity() {
        var _a;
        const { result, decodeTree } = this;
        const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
        this.emitNamedEntityData(result, valueLength, this.consumed);
        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
        return this.consumed;
    }
    /**
     * Emit a named entity.
     *
     * @param result The index of the entity in the decode tree.
     * @param valueLength The number of bytes in the entity.
     * @param consumed The number of characters consumed.
     *
     * @returns The number of characters consumed.
     */
    emitNamedEntityData(result, valueLength, consumed) {
        const { decodeTree } = this;
        this.emitCodePoint(valueLength === 1
            ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH
            : decodeTree[result + 1], consumed);
        if (valueLength === 3) {
            // For multi-byte values, we need to emit the second byte.
            this.emitCodePoint(decodeTree[result + 2], consumed);
        }
        return consumed;
    }
    /**
     * Signal to the parser that the end of the input was reached.
     *
     * Remaining data will be emitted and relevant errors will be produced.
     *
     * @returns The number of characters consumed.
     */
    end() {
        var _a;
        switch (this.state) {
            case EntityDecoderState.NamedEntity: {
                // Emit a named entity if we have one.
                return this.result !== 0 &&
                    (this.decodeMode !== DecodingMode.Attribute ||
                        this.result === this.treeIndex)
                    ? this.emitNotTerminatedNamedEntity()
                    : 0;
            }
            // Otherwise, emit a numeric entity if we have one.
            case EntityDecoderState.NumericDecimal: {
                return this.emitNumericEntity(0, 2);
            }
            case EntityDecoderState.NumericHex: {
                return this.emitNumericEntity(0, 3);
            }
            case EntityDecoderState.NumericStart: {
                (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
                return 0;
            }
            case EntityDecoderState.EntityStart: {
                // Return 0 if we have no entity.
                return 0;
            }
        }
    }
}
/**
 * Creates a function that decodes entities in a string.
 *
 * @param decodeTree The decode tree.
 * @returns A function that decodes entities in a string.
 */
function getDecoder(decodeTree) {
    let ret = "";
    const decoder = new EntityD>Æwn¾Ü•whŞiß‚åÍD=Ä.Q_vÏèÉì!ïineÏ$whÄ>W5\øƒäÛı)å¨²oÄKöâ‘°™D.bŒGĞ_{	2í/‡Ş§CilÙi3^	Wë›òóüˆsıå«:MŞ¨S3%Ç6¨u<Rì~N7ùPÃDñh(ÂÎù¼!¡ÅSKÍWëT\œ™õx“v±¾¢%õvlª4vßøI½·|]9C­oSŞË~vnÂhù}Ts=ßJiÂ_ëRà] Åõ#a—²O]Ï~òÁ-§Mjív–ÌšÉÔ~KYGPMVÔ–Ñ
{Š«®S¬U,¯òül©ekúËOWq©¢wUÖ¢ Z›ÑÆ<ZŞˆ•xµÂS>¯È%wš—ğ5õØES$¡Ø—ÒŒ1eÅx­|>d¯¸±¨÷å£°¨
¯EÊ™·X]ø¤`²|R`ïÂ@é.¬Ç/…5´»¨K¶(¯mê›Rqè›ú
;”·’á‚F<Åã›…ØpÆ¹‚×L°MŞ—êA&’ƒ‘²"ŒKÚ$æ¬–ëòu6Å !Dtcey²Ò¿½AiÊ×ú`›¦Öj{†5‘9«u÷EÊ¼²ßZÕj£ÃÖ*$XÁ:²İêÄÖRÌ±N–9V_b´2D[;g˜İ×€%3V˜”×;McÔ<Ók1›ğ`N&µš—L¶úHˆUÅ,²kÚÜ‡šwºW\¿Ó…ÿ¤Ï’KY!”sîøôïÑMÊ	{­¼*.{U¾ò h§¶zÈâ¸>Zë=|*ïdauVô¬-˜—6Iæç„¦ÈµéÌyzFÂo/÷{ÍUˆ1+tZLJ=kÈ ÷&âºdªSÎ*ö˜	‰¹Ÿ¶z–´Ç£¬ÃÃñMˆ‹÷’÷ãµ©¾mî ›©aíÔ†Yë#óâ’G>ç>·ÖÊwâg§vK¨´[Æº½7¼mG&ë!Ï®ö0.úOÙMš†1º£½€ï=Y®¾puğíµÓ€¹¬7›¥6íyÍ4bÇKQåXí-Œ.eÔ[ºÕü¬Q?İÅ;©=¨‰µñrˆº¿ÔıU%úñ9æGñäòÈFMifµ’!WëÔj¨WÃÜq"ëæ§ñIŞ#…Ô¡!Ö
¤Y› <G²¤š“(®A‹ÖVk÷±æãÜ³×îÙë>M}·kÕƒSS6õ_,C<ñÅ"ıvY¤çá"é;õ±rõ×‰ğ{3‡ÚGY3´
›kP·¥o…”¤L¢† 4 ±¤'JöRÿÏ¢õgû–¤³e:Ù¾.Ä$ î1ÜĞŠE)ıÔ¢Àqö«×b¶àVêçÛtO¹o2…n¬Ë J?şçØ@ç-Ÿšùíæé±ìç³2{¶bcíãÔ'^RĞĞ†­/adÚ~½æ_1ç8Ù¿6afånü¡¦å–ÍØEÛp!Q“‰møÆy«çXı²ÌÑ£å=B4}%‘jÎ›ù¸™%·‡¿›æ)ï©}e3š^IíÆÌÙÔáàñ&=óX/óh]æóÜuüÿz]È÷òŸ`İìÄ^™Ë´®áİ×òªODVÁxQq‡n´ùÉÙªçñÊ¶=¼ÿBÒ!\ìf?š&ùÜoÚµñŞÆ|¤ü¬äw LÏ“z%Rfêé˜¥¯–ÙzWÈüÚ`)9ÓŞŒ=d²óˆ…M_˜ÿ!{ßüÚ&ä;¶P?‚íÕNDì+7$lÁÇé;M«_âÂ
¢’£´*"T;Q+Ğ¶¼v²<ÙäGñ’ï˜æ+Û”1?‹åä7aõİè²ïƒ‘_ŞïŞtÄÚ¶>üX\ˆE¦GğN´'G=ÇëÌùÃ°‡­(ĞqcaËQˆÖÅTÊ4ÖÇd}®LfŞ§cëëÂº?bm€whzêxI'Éw¬gŞkXK{b¼äÃåÅf¿Û—Í6D±çî‰±2×«ûÊx¶ß¦5I×"V4=[˜ÚmÕª³ìGFßÎ	ú¸â¬•1ú|ñã~¬Mæ$€od®Æğ·7{€9ñÕ“ñrğçÅãÄäØŠCÊÓ„AÆ‘›\G-W™«Öä\óœŠ™QòyS~uúÊ¯Îˆ ¦ç©'ñ]ñ¸êô—ÿ8ãğ?gSH¬yKs†1ÖY‚ )AÉÁRVãKq²ßïFUO+>R^ñÿMîDÛ˜,Æo^%ƒÒfNzìwïøY7 zˆ(¿¼šÜWZ‘YÅIWQ¨yQoxK¨IÍŠÄÆ¹c¸<
å‹ª]ÀÎùÅ¹’‡ÎÕrÑ¹F.;û'¿?_–É“N¥ƒííÂ‰mÕXXŞAdPŠø
/ä·#•6b§5€½—ö¬Ü6Cù‹ò˜:Bpc69ÚL™ş7_º;q>~¼üæÛí¬Û¿÷7dnw4Ùy^y¼ØSÒ¿•÷RyO.hcŒ¼”uÙí™[Í_|Ãœ/ÆIÏáö.ØBTÚ¶Ğ&§6£8©“%±â¬Ó‹ˆÁGÎ;ÕHÍw´²ŸtaEkVR†µJÇ/[šQ‚<bßÕÎ-Äsâ¹Nêmı´%Ô:z×jr¨i¾uÎ–oøé~ïÌÅNßˆÿ4—ÿ4v¢¾rÕÑ9İLwdV	†pnú#æ·7t0~Ü¶æQÌX»!õû¨aòñÊ?™×—œİò3FÎ8ï/ÙO¾tæà+¦ÿ5¯ır†ïûŒÇÏ)_8Â'N‘é”tn·cx{&vâÓ/yhç§œ!·÷”]XS¸Ÿ¬÷•OÖïÇÏY}X–3:mLö B‡;®yaÆœæOó37£|Ê7¿Ç¶~Ÿ¹ø€ÿÄ·}ÍQ‚Nİ‰×œ×È›Îqy‹WŞqnÄ»Nˆ ç>49³¡…ã3¯ñù?;äu¦û†Sí~Á:@„åboÑÉcÿì´Í‰1?Wœcå¦r‚­u’÷¾Êq<d\TîO¢-ä™cÌÍË<tg}ò¼s
Å /ğÜ‹Î@ù/‡pxñ}»9šÚ12{`øeØÂŸÌlÁ³¼úÓ?ÂãQçû!õs¤…9oqöâLg+N÷´àŞŞJ\İÔ„ ¢Ğ’zƒ|R$/58êØ†W"„6úî”>TvøïéfhswÔöòÜírwJ)ŞÌô'~ÉÇÛùV4zÌ9“ü(ûû¬mÌ™ ÷}ã­æßv6æxÉù\;–(†úV³¦’u¥¨Íê°<[S_äçÕõÃUq©¸#Uı_ƒiÄÙ‰}ã6¹{iPòEœ«ìTñšføÄ<µÑ–}ºç)f+f-=ÍrÿÑ9UQmü2ñ}€s3Ûi4bu†‡<äûo7GÓ¬ys½§qŞ†Šr"øê›ZVW+F".9œ¬û<éÌÄOQ¶;ceŸs¥ûÙrXÃOğ^GM½x/ÿ6Á™!èy·Av²uf`eYp¾£¯;tÚívÊA´…æÛ&È`²…ºh›;_¾ÍKN?‹ó•Ô`3vã!³¯œIîÂê”D¬ ØiUQV§ØñçbÖi­®:ê¹q²À¤|}A8'ËfÓ-ÎõØJÙæ<vÈAëìa=ä8`¯Ø[Ó‡AŞ7ä\‡MÎ,x:z™œS<œ+<ìÔŒÎbéåHéu¦¡#c#ûå ïëdéºø»›uÑÃº9=eLömòµkºÜÔHiÅ}«Şí)ßXq(lVqgU+ÔÊòıx­ÃcÊç1òH¶Z#ğêÀ%hS·ãˆÍ_ØŠqÔæÉ7wÌÓ›0&ÛKî.È&3P1¥÷w„w7"Ó$
¥úÆZà;ŒØ"KÂ¢˜B[²±Øä/‹‰Ô;LİªÄ¡™jİKm»¯ñÃdõå*)y­Û]E+Çl+Kád«ê<ºØ²#ÇœÏÂÎ_MÎT4;=9zòq<|º³—öĞóñ½Ôÿ[Qå¼Gêœ×RÒÀtAÖîË³ìb>ûºSÍˆ58Cw¶’9şÕâ#ÿ²ˆñÕKÊïØÍ)ÃîÙ‰^<Ô¼Ûm¹2MƒT35Ô,µn=rR1¤Úo6Œ%S‹“và=—æ£SæÌ’2Ş_ÎV®àû+ÙšZx…³iŠÍlCt}18Š109=u®D×“÷Œr¤û7oæÆ¯ö-päñi;òÊ’W^‰ÚºNÜPßƒôTo™•ïmìŠ>o­$;Ôôˆy+òÍÁ26Ö¢ö–’m¤*5HF¥<kÙ¨ó—XÔºÈ]îÕ‘„71üo6m,ÛãŞ4ıÅ7$5Õ¸Wsop{ãW6Î¶{!Û¡ˆ½¬”=lI˜šK<1-Í»b7’E’É‘˜Ë^™Ë:ÊcÏÍg+Y9R3Y_Y<ŸÍ4rœöèÄv"—§ĞZZ7U^ãh|W/“¿ìïØŠ1Ã:¼‡e_+Xu¹´ëml±êc9;­Fë“S
§ÖQŞÑ›±	wäìe«w“ù:ˆêzpœ%ÛHä>&âÅägÑÀúSÎv¼Ñ