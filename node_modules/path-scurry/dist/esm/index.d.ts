/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { LRUCache } from 'lru-cache';
import { posix, win32 } from 'node:path';
import { Minipass } from 'minipass';
import type { Dirent, Stats } from 'node:fs';
/**
 * An object that will be used to override the default `fs`
 * methods.  Any methods that are not overridden will use Node's
 * built-in implementations.
 *
 * - lstatSync
 * - readdir (callback `withFileTypes` Dirent variant, used for
 *   readdirCB and most walks)
 * - readdirSync
 * - readlinkSync
 * - realpathSync
 * - promises: Object containing the following async methods:
 *   - lstat
 *   - readdir (Dirent variant only)
 *   - readlink
 *   - realpath
 */
export interface FSOption {
    lstatSync?: (path: string) => Stats;
    readdir?: (path: string, options: {
        withFileTypes: true;
    }, cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any) => void;
    readdirSync?: (path: string, options: {
        withFileTypes: true;
    }) => Dirent[];
    readlinkSync?: (path: string) => string;
    realpathSync?: (path: string) => string;
    promises?: {
        lstat?: (path: string) => Promise<Stats>;
        readdir?: (path: string, options: {
            withFileTypes: true;
        }) => Promise<Dirent[]>;
        readlink?: (path: string) => Promise<string>;
        realpath?: (path: string) => Promise<string>;
        [k: string]: any;
    };
    [k: string]: any;
}
interface FSValue {
    lstatSync: (path: string) => Stats;
    readdir: (path: string, options: {
        withFileTypes: true;
    }, cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any) => void;
    readdirSync: (path: string, options: {
        withFileTypes: true;
    }) => Dirent[];
    readlinkSync: (path: string) => string;
    realpathSync: (path: string) => string;
    promises: {
        lstat: (path: string) => Promise<Stats>;
        readdir: (path: string, options: {
            withFileTypes: true;
        }) => Promise<Dirent[]>;
        readlink: (path: string) => Promise<string>;
        realpath: (path: string) => Promise<string>;
        [k: string]: any;
    };
    [k: string]: any;
}
export type Type = 'Unknown' | 'FIFO' | 'CharacterDevice' | 'Directory' | 'BlockDevice' | 'File' | 'SymbolicLink' | 'Socket';
/**
 * Options that may be provided to the Path constructor
 */
export interface PathOpts {
    fullpath?: string;
    relative?: string;
    relativePosix?: string;
    parent?: PathBase;
    /**
     * See {@link FSOption}
     */
    fs?: FSOption;
}
/**
 * An LRUCache for storing resolved path strings or Path objects.
 * @internal
 */
export declare class ResolveCache extends LRUCache<string, string> {
    constructor();
}
/**
 * an LRUCache for storing child entries.
 * @internal
 */
export declare class ChildrenCache extends LRUCache<PathBase, Children> {
    constructor(maxSize?: number);
}
/**
 * Array of Path objects, plus a marker indicating the first provisional entry
 *
 * @internal
 */
export type Children = PathBase[] & {
    provisional: number;
};
declare const setAsCwd: unique symbol;
/**
 * Path objects are sort of like a super-powered
 * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}
 *
 * Each one represents a single filesystem entry on disk, which may or may not
 * exist. It includes methods for reading various types of information via
 * lstat, readlink, and readdir, and caches all information to the greatest
 * degree possible.
 *
 * Note that fs operations that would normally throw will instead return an
 * "empty" value. This is in order to prevent excessive overhead from error
 * stack traces.
 */
export declare abstract class PathBase implements Dirent {
    #private;
    /**
     * the basename of this path
     *
     * **Important**: *always* test the path name against any test string
     * usingthe {@link isNamed} method, and not by directly comparing this
     * string. Otherwise, unicode path strings that the system sees as identical
     * will not be properly treated as the same path, leading to incorrect
     * behavior and possible security issues.
     */
    name: string;
    /**
     * the Path entry corresponding to the path root.
     *
     * @internal
     */
    root: PathBase;
    /**
     * All roots found within the current PathScurry family
     *
     * @internal
     */
    roots: {
        [k: string]: PathBase;
    };
    /**
     * a reference to the parent path, or undefined in the case of root entries
     *
     * @internal
     */
    parent?: PathBase;
    /**
     * boolean indicating whether paths are compared case-insensitively
     * @internal
     */
    nocase: boolean;
    /**
     * boolean indicating that this path is the current working directory
     * of the PathScurry collection that contains it.
     */
    isCWD: boolean;
    /**
     * the string or regexp used to split paths. On posix, it is `'/'`, and on
     * windows it is a RegExp matching either `'/'` or `'\\'`
     */
    abstract splitSep: string | RegExp;
    /**
     * The path separator string to use when joining paths
     */
    abstract sep: string;
    get dev(): number | undefined;
    get mode(): number | undefined;
    get nlink(): number | undefined;
    get uid(): number | undefined;
    get gid(): number | undefined;
    get rdev(): number | undefined;
    get blksize(): number | undefined;
    get ino(): number | undefined;
    get size(): number | undefined;
    get blocks(): number | undefined;
    get atimeMs(): number | undefined;
    get mtimeMs(): number | undefined;
    get ctimeMs(): number | undefined;
    get birthtimeMs(): number | undefined;
    get atime(): Date | undefined;
    get mtime(): Date | undefined;
    get ctime(): Date | undefined;
    get birthtime(): Date | undefined;
    /**
     * This property is for compatibility with the Dirent class as of
     * Node v20, where Dirent['parentPath'] refers to the path of the
     * directory that was passed to readdir. For root entries, it's the path
     * to the entry itself.
     */
    get parentPath(): string;
    /**
     * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
     * this property refers to the *parent* path, not the path object itself.
     */
    get path(): string;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name: string, type: number | undefined, root: PathBase | undefined, roots: {
        [k: string]: PathBase;
    }, nocase: boolean, children: ChildrenCache, opts: PathOpts);
    /**
     * Returns the depth of the Path object from its root.
     *
     * For example, a path at `/foo/bar` would have a depth of 2.
     */
    depth(): number;
    /**
     * @internal
     */
    abstract getRootString(path: string): string;
    /**
     * @internal
     */
    abstract getRoot(rootPath: string): PathBase;
    /**
     * @internal
     */
    abstract newChild(name: string, type?: number, opts?: PathOpts): PathBase;
    /**
     * @internal
     */
    childrenCache(): ChildrenCache;
    /**
     * Get the Path object referenced by the string path, resolved from this Path
     */
    resolve(path?: string): PathBase;
    /**
     * Returns the cached children Path objects, if still available.  If they
     * have fallen out of the cache, then returns an empty array, and resets the
     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
     * lookup.
     *
     * @internal
     */
    children(): Children;
    /**
     * Resolves a path portion and returns or creates the child Path.
     *
     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
     * `'..'`.
     *
     * This should not be called directly.  If `pathPart` contains any path
     * separators, it will lead to unsafe undefined behavior.
     *
     * Use `Path.resolve()` instead.
     *
     * @internal
     */
    child(pathPart: string, opts?: PathOpts): PathBase;
    /**
     * The relative path from the cwd. If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpath()
     */
    relative(): string;
    /**
     * The relative path from the cwd, using / as the path separator.
     * If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpathPosix()
     * On posix systems, this is identical to relative().
     */
    relativePosix(): string;
    /**
     * The fully resolved path string for this Path entry
     */
    fullpath(): string;
    /**
     * On platforms other than windows, this is identical to fullpath.
     *
     * On windows, this is overridden to return the forward-slash form of the
     * full UNC path.
     */
    fullpathPosix(): string;
    /**
     * Is the Path of an unknown type?
     *
     * Note that we might know *something* about it if there has been a previous
     * filesystem operation, for example that it does not exist, or is not a
     * link, or whether it has child entries.
     */
    isUnknown(): boolean;
    isType(type: Type): boolean;
    getType(): Type;
    /**
     * Is the Path a regular file?
     */
    isFile(): boolean;
    /**
     * Is the Path a directory?
     */
    isDirectory(): boolean;
    /**
     * Is the path a character device?
     */
    isCharacterDevice(): boolean;
    /**
     * Is the path a block device?
     */
    isBlockDevice(): boolean;
    /**
     * Is the path a FIFO pipe?
     */
    isFIFO(): boolean;
    /**
     * Is the path a socket?
     */
    isSocket(): boolean;
    /**
     * Is the path a symbolic link?
     */
    isSymbolicLink(): boolean;
    /**
     * Return the entry if it has been subject of a successful lstat, or
     * undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* simply
     * mean that we haven't called lstat on it.
     */
    lstatCached(): PathBase | undefined;
    /**
     * Return the cached link target if the entry has been the subject of a
     * successful readlink, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readlink() has been called at some point.
     */
    readlinkCached(): PathBase | undefined;
    /**
     * Returns the cached realpath target if the entry has been the subject
     * of a successful realpath, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * realpath() has been called at some point.
     */
    realpathCached(): PathBase | undefined;
    /**
     * Returns the cached child Path entries array if the entry has been the
     * subject of a successful readdir(), or [] otherwise.
     *
     * Does not read the filesystem, so an empty array *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readdir() has been called recently enough to still be valid.
     */
    readdirCached(): PathBase[];
    /**
     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
     * any indication that readlink will definitely fail.
     *
     * Returns false if the path is known to not be a symlink, if a previous
     * readlink failed, or if the entry does not exist.
     */
    canReadlink(): boolean;
    /**
     * Return true if readdir has previously been successfully called on this
     * path, indicating that cachedReaddir() is likely valid.
     */
    calledReaddir(): boolean;
    /**
     * Returns true if the path is known to not exist. That is, a previous lstat
     * or readdir failed to verify its existence when that would have been
     * expected, or a parent entry was marked either enoent or enotdir.
     */
    isENOENT(): boolean;
    /**
     * Return true if the path is a match for the given path name.  This handles
     * case sensitivity and unicode normalization.
     *
     * Note: even on case-sensitive systems, it is **not** safe to test the
     * equality of the `.name` property to determine whether a given pathname
     * matches, due to unicode normalization mismatches.
     *
     * Always use this method instead of testing the `path.name` property
     * directly.
     */
    isNamed(n: string): boolean;
    /**
     * Return the Path object corresponding to the target of a symbolic link.
     *
     * If the Path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     */
    readlink(): Promise<PathBase | undefined>;
    /**
     * Synchronous {@link PathBase.readlink}
     */
    readlinkSync(): PathBase | undefined;
    /**
     * Call lstat() on this Path, and update all known information that can be
     * determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    lstat(): Promise<PathBase | undefined>;
    /**
     * synchronous {@link PathBase.lstat}
     */
    lstatSync(): PathBase | undefined;
    /**
     * Standard node-style callback interface to get list of directory entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * @param cb The callback called with (er, entries).  Note that the `er`
     * param is somewhat extraneous, as all readdir() errors are handled and
     * simply result in an empty set of entries being returned.
     * @param allowZalgo Boolean indicating that immediately known results should
     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
     * zalgo at your peril, the dark pony lord is devious and unforgiving.
     */
    readdirCB(cb: (er: NodeJS.ErrnoException | null, entries: PathBase[]) => any, allowZalgo?: boolean): void;
    /**
     * Return an array of known child entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    readdir(): Promise<PathBase[]>;
    /**
     * synchronous {@link PathBase.readdir}
     */
    readdirSync(): PathBase[];
    canReaddir(): boolean;
    shouldWalk(dirs: Set<PathBase | undefined>, walkFilter?: (e: PathBase) => boolean): boolean;
    /**
     * Return the Path object corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     * On success, returns a Path object.
     */
    realpath(): Promise<PathBase | undefined>;
    /**
     * Synchronous {@link realpath}
     */
    realpathSync(): PathBase | undefined;
    /**
     * Internal method to mark this Path object as the scurry cwd,
     * called by {@link PathScurry#chdir}
     *
     * @internal
     */
    [setAsCwd](oldCwd: PathBase): void;
}
/**
 * Path class used on win32 systems
 *
 * Uses `'\\'` as the path separator for returned paths, either `'\\'` or `'/'`
 * as the path separator for parsing paths.
 */
export declare class PathWin32 extends PathBase {
    /**
     * Separator for generating path strings.
     */
    sep: '\\';
    /**
     * Separator for parsing path strings.
     */
    splitSep: RegExp;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name: string, type: number | undefined, root: PathBase | undefined, roots: {
        [k: string]: PathBase;
    }, nocase: boolean, children: ChildrenCache, opts: PathOpts);
    /**
     * @internal
     */
    newChild(name: string, type?: number, opts?: PathOpts): PathWin32;
    /**
     * @internal
     */
    getRootString(path: string): string;
    /**
     * @internal
     */
    getRoot(rootPath: string): PathBase;
    /**
     * @internal
     */
    sameRoot(rootPath: string, compare?: string): boolean;
}
/**
 * Path class used on all posix systems.
 *
 * Uses `'/'` as the path separator.
 */
export declare class PathPosix extends PathBase {
    /**
     * separator for parsing path strings
     */
    splitSep: '/';
    /**
     * separator for generating path strings
     */
    sep: '/';
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name: string, type: number | undefined, root: PathBase | undefined, roots: {
        [k: string]: PathBase;
    }, nocase: boolean, children: ChildrenCache, opts: PathOpts);
    /**
     * @internal
     */
    getRootString(path: string): string;
    /**
     * @internal
     */
    getRoot(_rootPath: string): PathBase;
    /**
     * @internal
     */
    newChild(name: string, type?: number, opts?: PathOpts): PathPosix;
}
/**
 * Options that may be provided to the PathScurry constructor
 */
export interface PathScurryOpts {
    /**
     * perform case-insensitive path matching. Default based on platform
     * subclass.
     */
    nocase?: boolean;
    /**
     * Number of Path entries to keep in the cache of Path child references.
     *
     * Setting this higher than 65536 will dramatically increase the data
     * consumption and construction time overhead of each PathScurry.
     *
     * Setting this value to 256 or lower will significantly reduce the data
     * consumption and construction time overhead, but may also reduce resolve()
     * and readdir() performance on large filesystems.
     *
     * Default `16384`.
     */
    childrenCacheSize?: number;
    /**
     * An object that overrides the built-in functions from the fs and
     * fs/promises modules.
     *
     * See {@link FSOption}
     */
    fs?: FSOption;
}
/**
 * The base class for all PathScurry classes, providing the interface for path
 * resolution and filesystem operations.
 *
 * Typically, you should *not* instantiate this class directly, but rather one
 * of the platform-specific classes, or the exported {@link PathScurry} which
 * defaults to the current platform.
 */
export declare abstract class PathScurryBase {
    #private;
    /**
     * The root Path entry for the current working directory of this Scurry
     */
    root: PathBase;
    /**
     * The string path for the root of this Scurry's current working directory
     */
    rootPath: string;
    /**
     * A collection of all roots encountered, referenced by rootPath
     */
    roots: {
        [k: string]: PathBase;
    };
    /**
     * The Path entry corresponding to this PathScurry's current working directory.
     */
    cwd: PathBase;
    /**
     * Perform path comparisons case-insensitively.
     *
     * Defaults true on Darwin and Windows systems, false elsewhere.
     */
    nocase: boolean;
    /**
     * The path separator used for parsing paths
     *
     * `'/'` on Posix systems, either `'/'` or `'\\'` on Windows
     */
    abstract sep: string | RegExp;
    /**
     * This class should not be instantiated directly.
     *
     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
     *
     * @internal
     */
    constructor(cwd: string | URL | undefined, pathImpl: typeof win32 | typeof posix, sep: string | RegExp, { nocase, childrenCacheSize, fs, }?: PathScurryOpts);
    /**
     * Get the depth of a provided path, string, or the cwd
     */
    depth(path?: Path | string): number;
    /**
     * Parse the root portion of a path string
     *
     * @internal
     */
    abstract parseRootPath(dir: string): string;
    /**
     * create a new Path to use as root during construction.
     *
     * @internal
     */
    abstract newRoot(fs: FSValue): PathBase;
    /**
     * Determine whether a given path string is absolute
     */
    abstract isAbsolute(p: string): boolean;
    /**
     * Return the cache of child entries.  Exposed so subclasses can create
     * child Path objects in a platform-specific way.
     *
     * @internal
     */
    childrenCache(): ChildrenCache;
    /**
     * Resolve one or more path strings to a resolved string
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolve(...paths: string[]): string;
    /**
     * Resolve one or more path strings to a resolved string, returning
     * the posix path.  Identical to .resolve() on posix systems, but on
     * windows will return a forward-slash separated UNC path.
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolvePosix(...paths: string[]): string;
    /**
     * find the relative path from the cwd to the supplied path string or entry
     */
    relative(entry?: PathBase | string): string;
    /**
     * find the relative path from the cwd to the supplied path string or
     * entry, using / as the path delimiter, even on Windows.
     */
    relativePosix(entry?: PathBase | string): string;
    /**
     * Return the basename for the provided string or Path object
     */
    basename(entry?: PathBase | string): string;
    /**
     * Return the dirname for the provided string or Path object
     */
    dirname(entry?: PathBase | string): string;
    /**
     * Return an array of known child entries.
     *
     * First argument may be either a string, or a Path object.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * Unlike `fs.readdir()`, the `withFileTypes` option defaults to `true`. Set
     * `{ withFileTypes: false }` to return strings.
     */
    readdir(): Promise<PathBase[]>;
    readdir(opts: {
        withFileTypes: true;
    }): Promise<PathBase[]>;
    readdir(opts: {
        withFileTypes: false;
    }): Promise<string[]>;
    readdir(opts: {
        withFileTypes: boolean;
    }): Promise<PathBase[] | string[]>;
    readdir(entry: PathBase | string): Promise<PathBase[]>;
    readdir(entry: PathBase | string, opts: {
        withFileTypes: true;
    }): Promise<PathBase[]>;
    readdir(entry: PathBase | string, opts: {
        withFileTypes: false;
    }): Promise<string[]>;
    readdir(entry: PathBase | string, opts: {
        withFileTypes: boolean;
    }): Promise<PathBase[] | string[]>;
    /**
     * synchronous {@link PathScurryBase.readdir}
     */
    readdirSync(): PathBase[];
    readdirSync(opts: {
        withFileTypes: true;
    }): PathBase[];
    readdirSync(opts: {
        withFileTypes: false;
    }): string[];
    readdirSync(opts: {
        withFileTypes: boolean;
    }): PathBase[] | string[];
    readdirSync(entry: PathBase | string): PathBase[];
    readdirSync(entry: PathBase | string, opts: {
        withFileTypes: true;
    }): PathBase[];
    readdirSync(entry: PathBase | string, opts: {
        withFileTypes: false;
    }): string[];
    readdirSync(entry: PathBase | string, opts: {
        withFileTypes: boolean;
    }): PathBase[] | string[];
    /**
     * Call lstat() on the string or Path object, and update all known
     * information that can be determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    lstat(entry?: string | PathBase): Promise<PathBase | undefined>;
    /**
     * synchronous {@link PathScurryBase.lstat}
     */
    lstatSync(entry?: string | PathBase): PathBase | undefined;
    /**
     * Return the Path object or string path corresponding to the target of a
     * symbolic link.
     *
     * If the path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     *
     * `{withFileTypes}` option defaults to `false`.
     *
     * On success, returns a Path object if `withFileTypes` option is true,
     * otherwise a string.
     */
    readlink(): Promise<string | undefined>;
    readlink(opt: {
        withFileTypes: false;
    }): Promise<string | undefined>;
    readlink(opt: {
        withFileTypes: true;
    }): Promise<PathBase | undefined>;
    readlink(opt: {
        withFileTypes: boolean;
    }): Promise<PathBase | string | undefined>;
    readlink(entry: string | PathBase, opt?: {
        withFileTypes: false;
    }): Promise<string | undefined>;
    readlink(entry: string | PathBase, opt: {
        withFileTypes: true;
    }): Promise<PathBase | undefined>;
    readlink(entry: string | PathBase, opt: {
        withFileTypes: boolean;
    }): Promise<string | PathBase | undefined>;
    /**
     * synchronous {@link PathScurryBase.readlink}
     */
    readlinkSync(): string | undefined;
    readlinkSync(opt: {
        withFileTypes: false;
    }): string | undefined;
    readlinkSync(opt: {
        withFileTypes: true;
    }): PathBase | undefined;
    readlinkSync(opt: {
        withFileTypes: boolean;
    }): PathBase | string | undefined;
    readlinkSync(entry: string | PathBase, opt?: {
        withFileTypes: false;
    }): string | undefined;
    readlinkSync(entry: string | PathBase, opt: {
        withFileTypes: true;
    }): PathBase | undefined;
    readlinkSync(entry: string | PathBase, opt: {
        withFileTypes: boolean;
    }): string | PathBase | undefined;
    /**
     * Return the Path object or string path corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     *
     * `{withFileTypes}` option defaults to `false`.
     *
     * On success, returns a Path object if `withFileTypes` option is true,
     * otherwise a string.
     */
    realpath(): Promise<string | undefined>;
    realpath(opt: {
        withFileTypes: false;
    }): Promise<string | undefined>;
    realpath(opt: {
        withFileTypes: true;
    }): Promise<PathBase | undefined>;
    realpath(opt: {
        withFileTypes: boolean;
    }): Promise<PathBase | string | undefined>;
    realpath(entry: string | PathBase, opt?: {
        withFileTypes: false;
    }): Promise<string | undefined>;
    realpath(entry: string | PathBase, opt: {
        withFileTypes: true;
    }): Promise<PathBase | undefined>;
    realpath(entry: string | PathBase, opt: {
        withFileTypes: boolean;
    }): Promise<string | PathBase | undefined>;
    realpathSync(): string | undefined;
    realpathSync(opt: {
        withFileTypes: false;
    }): string | undefined;
    realpathSync(opt: {
        withFileTypes: true;
    }): PathBase | undefined;
    realpathSync(opt: {
        withFileTypes: boolean;
    }): PathBase | string | undefined;
    realpathSync(entry: string | PathBase, opt?: {
        withFileTypes: false;
    }): string | undefined;
    realpathSync(entry: string | PathBase, opt: {
        withFileTypes: true;
    }): PathBase | undefined;
    realpathSync(entry: string | PathBase, opt: {
        withFileTypes: boolean;
    }): string | PathBase | undefined;
    /**
     * Asynchronously walk the directory tree, returning an array of
     * all path strings or Path objects found.
     *
     * Note that this will be extremely memory-hungry on large filesystems.
     * In such cases, it may be better to use the stream or async iterator
     * walk implementation.
     */
    walk(): Promise<PathBase[]>;
    walk(opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset): Promise<PathBase[]>;
    walk(opts: WalkOptionsWithFileTypesFalse): Promise<string[]>;
    walk(opts: WalkOptions): Promise<string[] | PathBase[]>;
    walk(entry: string | PathBase): Promise<PathBase[]>;
    walk(entry: string | PathBase, opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset): Promise<PathBase[]>;
    walk(entry: string | PathBase, opts: WalkOptionsWithFileTypesFalse): Promise<string[]>;
    walk(entry: string | PathBase, opts: WalkOptions): Promise<PathBase[] | string[]>;
    /**
     * Synchronously walk the directory tree, returning an array of
     * all path strings or Path objects found.
     *
     * Note that this will be extremely memory-hungry on large filesystems.
     * In such cases, it may be better to use the stream or async iterator
     * walk implementation.
     */
    walkSync(): PathBase[];
    walkSync(opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset): PathBase[];
    walkSync(opts: WalkOptionsWithFileTypesFalse): string[];
    walkSync(opts: WalkOptions): string[] | PathBase[];
    walkSync(entry: string | PathBase): PathBase[];
    walkSync(entry: string | PathBase, opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue): PathBase[];
    walkSync(entry: string | PathBase, opts: WalkOptionsWithFileTypesFalse): string[];
    walkSync(entry: string | PathBase, opts: WalkOptions): PathBase[] | string[];
    /**
     * Support for `for await`
     *
     * Alias for {@link PathScurryBase.iterate}
     *
     * Note: As of Node 19, this is very slow, compared to other methods of
     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
     */
    [Symbol.asyncIterator](): AsyncGenerator<PathBase, void, void>;
    /**
     * Async generator form of {@link PathScurryBase.walk}
     *
     * Note: As of Node 19, this is very slow, compared to other methods of
     * walking, especially if most/all of the directory tree has been previously
     * walked.  Consider using {@link PathScurryBase.stream} if memory overhead
     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
     */
    iterate(): AsyncGenerator<PathBase, void, void>;
    iterate(opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset): AsyncGenerator<PathBase, void, void>;
    iterate(opts: WalkOptionsWithFileTypesFalse): AsyncGenerator<string, void, void>;
    iterate(opts: WalkOptions): AsyncGenerator<string | PathBase, void, void>;
    iterate(entry: string | PathBase): AsyncGenerator<PathBase, void, void>;
    iterate(entry: string | PathBase, opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset): AsyncGenerator<PathBase, void, void>;
    iterate(entry: string | PathBase, opts: WalkOptionsWithFileTypesFalse): AsyncGenerator<string, void, void>;
    iterate(entry: string | PathBase, opts: WalkOptions): AsyncGenerator<PathBase | string, void, void>;
    /**
     * Iterating over a PathScurry performs a synchronous walk.
     *
     * Alias for {@link PathScurryBase.iterateSync}
     */
    [Symbol.iterator](): Generator<PathBase, void, void>;
    iterateSync(): Generator<PathBase, void, void>;
    iterateSync(opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset): Generator<PathBase,Ë–ıN=öØß²gj©•„&dMOÊÑ›¡<ªHÍÕ¹ò4¡êZD¶cú@¥AÑ9=]Ñ2=¥ARŒZ©m©l‘SŸ*Ã,¯³!G™¯ËÉU8›Òb_ @®€¹«õ †u&Ô`1Gvızºb±—ÌGü-#P[­"Zì°Å$ÍP“Ç0±ÚXM‚FCÃ jB|ı¿5A/íG|;uáÑg_^ÊÖˆû†&oıÂçÇOÃº.ÙRogså é®ßªöŸnÀ=U_=¬o4ñvÿKÓøÃîÜ~X¶âËk{Ã#Ò%†?ÿ”;Mü,òFbç¶wÍ¯µ®‡ÇĞ’vÇ³³LŠŸ†=ßĞ3|E&÷É°ÖÅg›ù«B
·d<©ñpî õÁ+zÕ÷ûúôGø®*kÿA×¹º«ƒNùWö§tŞ4ìî|aùÑG¢û¨sĞ*¢Õ––Ë¢[ªo<'z×dÁÅ±%íkáïÿşŞÉü9sn“‚~»V&'X}®ÛÙş%Ûöå¿ŞåÃ-â#úÌÖ¿›ò|Rš{œĞº°:·±wˆ9}tƒ+¬÷¥=gæ-Üİ7b¡ğRÅÙsÜ[\Ùßê«o=6^îûGÑÔ÷»Ä÷r¹;yE×Ûé£öZ¶yœb7O¹R²± É´~s§õ¼8¸`U;İê˜ìñFg–µ¯#íşyò»… ÆxıœõW¥«z~®ş-pôĞ_£¸ê!CR*?;Ü";vÃ‡Á÷×}T 	‹M\ÉùzkÄùUû>îybïìoOfˆ¿ÈÛ¹%èÉÉaMŸhrC2÷ÑCÕ®œ¾†IŸÿ0'#Ü';øE›&Úè¬öò«İ–¤	^² ÕcmçY¿9±t÷ïÅ£'^ù½ğ\Æ©gs¾(OŞ¿èÚÊôÂ©<·úĞ)›ÆÄ7xØ:cùîŞûçäózR¢}2¤ƒ-‚¼nAç¸†@uÍÒ‹·,ßz]ê8ÅF_²Ò»7èÓ¿÷¸G?Ô¯Lõ¿mV÷%äñîê®êÎ¥i¥'¤TóØ‰H¨¥U[—0ü÷,üíÚ0M8Ê³By?uu/†PŞ±Ú'PÕ«Íş0ÊŸı¡o"µ}äçŠ)A°=‡jŒ#±ùû=73âBsC½j;´ÙUO8ZÖş÷®s&,êt:Üçiçî·ØË–®ß`ä®E:ï9kzÎşàñªÎGgnÕDó?ÕtgÕŠ‘ï.>?ÕÒÏçat‰×ğ6^#Û—|¾òWŸRO<”†ÿ-¥É•ãJ»]ûÀ{|ÄêÄ‹ïÕŞ»³¯m­¸'kKXãËwI÷F<fÿ¸H[úÌ}ÄŠ_¦ö>=¦ó/5:ØlwQt«`aÛê-GŞÉz’qqü‡½ò>1£ÖMj-¨8úUä½Ûû÷ÂˆÕÙKóKÍgê›g]Ÿu­pgòè?Ú.øxT‡ûËÎ—Nñé:ÙëÙùs¦oİ5·Gë»ì±s×f¹‘§·gšnkÄºzß®=¶·ğÌ¨Ğ2ıêêŞ¬! äî‡ó?oaÉ¿~¾:yÓõ_—§Ï™´nŞôä^—ùµÙ«m‚òˆúëóGNOØ«hø/uÜ?ªÕÉ¯«OvŸ­ÓîÇw—ñ-~p¹kı™²UÃo,=¬¿xoÅÂìñ¡-ÛLúşø‰y·ıq:sË×z»>¾ÍÆ¬;mè¨ICÃ,}–·ÛP>àÒåõ„ukŞéúıú_Íò^.áÎ»\M7g^»îßvÏ“°IOWœ¾sãJq«§>èP0ãÎòs'"¸5İ+Ï,ÜôŞïÑº/²€aË{×w~ßsğ(·éM®Ö…ùöšá-‰ŸÔP^áºiÉã¯S·ùY yä;V	¼ı<x1{ar	>½òşÏ^S£NˆVkâµZm,d˜Ñjâk4úú/³ó—1¸›×V´ÿy‹¹†pøÇÇÎª†ïŸ.>U~wŸrUvJÁ×Gc»=aÎn{õú®/šøö‹¶ôJıjÀsÒ‡ô¸>ªmŠÏã²Şk¥m";^¨İ+õ»Õoä ´q-¶¯˜Új0ßëá¡¡'t¼´¯Å×CzuÒÔ/u‹7N¹sVr®vúˆ»èàêr³a}ğšµOâvÇÖÎ¼0¿á€w£?ÓsÔ‡Ò Ò*¶İê_ëÒ ÉñŞ*¦¦?óÛ{];Ü»¼sÊ²3¦mJˆè´èv®Áıh\dîTÍ×±a»nl™¨:põÈ´Q[;O»ôÜ¥Ëüœ´ÚugÙº¢ğúkı:®åÏ­ŒGµ§÷NP÷J¸ŞÓ·_\Ÿ2éæÜµ¬¶_î²Ê·gV¿+OgÎ	n\®872iA«‚oö¹ì9ùLùrÅÈQ/Î/nùÃ6s½‹#ûÙqqõ¨¸ßâÚ?©küÔ³Ó­=.œOÊòVt¨Ÿ?;(¦Xr_ú`{k¿;+o•ŒhÚşâú>û>—×¸yÊ¾è„öSÙ;›Œ’ş2¾S«ëe»ùõĞ±òf}ÜçlØPöõh?óÙ•ŠûûŸ{ºÍ0‰Äe~Ğ³tÅ¸½ûªógÌ}î‹Ï„“uãx±~ã[_¼XV¾éû CƒŸôJëÔÛób­ë;ºeò6ß›ò,íà{¾³ö6ò¾Pÿ+Wo¿¦ÃÖ´Üö8dbŸÓû˜‡×½»}{“A×£>£ÜeÈàÎ«=™gW.8ÊQô36b}uV¦Ud\°»xF£V±áÇ¥–zÜ»Îèñõ"ÎrˆKu34n$T““^í(§:ÊIÓçšòù&óp|”##nlÙÎ9U;ı¤ë±i·>îÕ`YãÙÓ{ınßAuW‚‹§ª;¨Û•&—¶¦ïv^ñTxA‘5.R™wóF7ÂmÌ»É+¨Ù–ïˆé~Ôeä‹:Ÿ]‹g±4ª×›Û½Xeú¥—×¶&)­3‡mäÍš×X½5áìş!qM/df8Qó¥Dssÿ´?³Ë–Îö«y÷ö€¬é.Ïß±-dØ¹¸¨E«Š»Î—İ“o®îÜ}÷‡A¦İáÇŒçš¶)`÷»’S,zœ£ì|sXzªÛ——<œÚøğÃ?èŸ,ëºú9ÛÂº„PíJ,İã¿ÍÓÓ£wãĞ«‰sã×şñ,|ò¾:¿×lóÑâü'ÿ|_8hìş±şÍüÓ
ŞÛ|@—1ø]cÓÁ0¯Û36­êùCò'ù¢¿Ís²ñOm›h˜úå„çÚ€ósM{2ƒõä»ÃùåOÚ›MÒ5êC1ŠÎu¬pë~9±ÑWs>ÊÈo±1¥uä>/î=™ÏT»órNìÚÌê–Ü9ó|ŞÙÑ!=[°¦öğŸ1Ø}É²°KYşaªñíÿ¬Ñyğ –­Wı¾}İ×·&÷Iıèä‰öC·vë,Øh`µ5b©.;¯ÂíËß’46”Û—”<jÔ¬İÇ6¼¹İ{Ï–ïš,×t¿s{_ñÇïú{O’[ñóÖa“…Óâ.ìhÿl¡ÅívÌSUlVİ«îŸÿôaÉ™k5¹Ú¬q­Ù?åç÷T¶¸ÉQ¥šè‘;İ~wO|n‹²é¿½¦Áû\û>Ÿ›‘ŞaÊİâœå.Ò}Cxƒ¤[‚»Dwß¼4wÀƒ¥ÅœÄâ³ªgKÿªß+İ`ßø<—ºb;€ã­Ï=İj:¯Ù´ìö[ùÃ¤;»ĞöyéØqê±c–ú—ù´íe»€Û¦¨kúI¨M´6F›Ğƒ~PŸ| ÎW7°ÎpYšuµY º}€d°Ùµ¾$?Èî©A­ÜQjã]6:Z¤øĞY»ÔMíŠ^ãğ—*–RŸYJ+HM®Ú»¥ô›kéõÅ‰ÉAsåÁ !~u_LêİYİøÛO>h4Æ+{SËæ›ıúuëÏ}Ø±ßŠ<ÓoæØ¼ÒŠKIaÛ=V¹.~ûb‡-’ıÑƒ‡µ|Ñ3íòÕÿlŸå—b.5èsìyëÇW´koŸş.«n‡…½>é“}zÓ´ˆ·6jvÑ•—ÜÒßéæ7ÇÔ<¼½Ë´¼E¾7NX._I\¹z^Ò.y™¡lö”Õo\-ùAuúêŸŸ]º¾)|“ûÙÅšBGo½™ÿşÓj].=»`D»®ÃÏ¥·[ß´Í½©ë™w&)36õ¸tmág·Fwş¾éÀŒÛFöıñÅû£ZÏÜæû¯î…ş1NSÌuWsxCÍúw×“Óƒ&æÑo1«­:€yöënsXéx7«Ëûë.±¶-¿~óÖ¦wû×¸ş¢FØĞâŸnşr´æüØ‡ê±Ï°ëiÆş¢û³zìMõØ]\Å™cÜ»;ÕDê·2¾Yû)óò?<Ğ|Ç1uoìlÚû“U/Ôcçÿ6¢ãƒOÜ¼~ÔıïVr½°Ì'ãÜÔó?M>¤=?èÔÑK@ùÛÆ>Wìv·˜’ºûl”øqü×ÕµwÊ?–9eÅ–øĞq.×gzÄİ_ùÙç¥²wn›?´‰±æÑ/Ãœş8aÈÒü¡ÇÿmtÉø;!ÏWfOYóç…'ÅgÜjV—^»İ}Ôíà÷ï,Ù¹o­µ;B—}™œØúæãş÷½ön>wyÊäË—Õ~”ToøŒwœh±âŒÎ3sì”O>NÚ~7¡]—Û$%®ó—å®R|ã7xõ¯)7Ï]ãuûc¨zÑY©æÙ×™Çwöà—”¸?3k¯½ë>óÛ!k:w­×hK oşæ¾?ê’Æ?Ì>vï§ÇÛwëRºu¸zfÒÜ\õ§ÊÙ5ã]Û{o¶ûs3šø<(ˆäß!›òÇú‚ö»şò®¬ÖÊ[/~\“œ2(tü'ó‡Ş»—wºmÄâãS–rFõüuÒğ÷æ¬ò_rêYy—w×4M}³§÷óßä¿Ôc{vÎ©ÃãÎ<¸˜ü$ó¾v_ƒ:Ïß+®3_®M8wãì¼SÏ¸n1«¹û[\nà­³qê§y^wøg?[ü~“–©ß|)ÚÕ«GÉ•Óq[zŠ¼ÚŞ¸òÑé…±ºØ¾	[-èv³~²XÚhİ¥ğU~Ú}û~Ínó«ìú#M³;·Şµ”¶Ø¾şá™Ú1ı–Ïk¸väÚçı´<kJÂÊgç™ßÇÇuU«%A;º=än±K>÷É³¡Y±wÅõšv[½ûfoøÿ PKÖR¯«    PK   ãv†W            D   pt-BR/Microsoft.TeamFoundation.TestManagement.Controls.resources.dllì]@IĞ‹HUQ#"""""6ª•&`/¸À‘4“Ğ¬XÏ~ö®gogï]ì½—³÷Ş»ˆüov³d’ğ<ñ~#kvwŞûæÍ›7ofvg^Â;Cú!8òóÚ‚èO *ú“GÙª•ELWÛÂ	;^-6…'åŠ%¢d	!à&B¡HÆ'¹’4!—'ä†DÆp¢DÒÃÂÂÌYŠPGµü &Ü›H¯š9Ç!Ì„¾×ÔÎ¹X0}Z:|®GËâeëS÷W]Õ‡rEÈŠúS||QŸ»ú¨¢q3Y	úˆë
ß=ôQtQèÃ-ú˜ÀuKÖµ‡ŒÌ”Áwˆµ¼\6´Ü*=<$RIœS²á²Á·¾] üyHH¾)Y{È±
ÑÓ‹¦Á²é!C”R[õ…¼LåéQ Ä43}ôĞMŸªï¢>ó}:qäÅNœ‡ƒ“%•‘hR*J“$Ò‚³h’H$%î\4A$áóâİ¹íI‰”'6ññğÄÿÜ¹Ái|Yš„l"$Ód‚ïÎJ‹çóÚY±¢TRØ$¾A¢~B}_¯†õ|HO¿†Õg–&”ñ$s#†”a½D!ºr’åô!"ƒ'Löˆáõ&›»s•ï–D.ÏzIõ“$yy%Ö÷$ê½åˆxÂDQ†Ô£¹H"z¦ÉD8Çph™*‘ü*IRSÄ¯„Â„‘$F–Å'¥ß­„ª•%â	eß¡ˆij‹E$&Røß©t9j³%âùd‘%J“MË@‚ï§àµ„ˆR©šınùF%üNf;NOÊ^ÜùıàæM>ğ¼à8ÆÄ®ç˜ëŞcæ$ÇNºOvš4R4cÚ9‡å3\2¶Í:³"fé§uË½Ï×\9Ëkİš»×6¬9¿ñéšC9Fë_vÚ¶aI‡£.İ´©Ò½­›¬knØ¶ÍòúvtÿØŞm«íòØé|À*Íóüì¹‹ÿ6«İîÊ»÷ñWî?;u]á{£{ûw:^_rçMè­GİŸîzj“Õğ™Ù=Ï‡mÖÿôìV×O§ÏÌ_äh€z7Xbp×y¿‘g‹yOÙ\÷¾dS#£º­^{cû¤ÚUCÇVwJÎ«ëâyµ£Ë¡¨Î.7[/pqN°ôjèéåıâU_›ÙGüî/Ûpáy#ÿ#íÒüâ‚V¿
âsPÕ6o‚—”úêØËÖë<ÜbZLê85ªY·{¡ºÙæ[v}»O÷~7'‹ìÉºš¦ÉfB§h‡[Y„š™!ô {àÿú€ËıHc„ê@g¸\a
t_àh€û	èzÛƒœÇ@¸ö‚ï48ÊÂQú†p ÿ>ÀÆ@K„ÚXÀØÎ¯Ày ä1#Àö š\È¤[C§²Ò7Àõ>à¿ ù8 İFÈ÷tcàú:Èû pîC^àŞJ8¦íeÈsğ¿†#h†Á·A¾.ğıàôÚz@Û‹_uÀeŞ4W±Ûg IZcä±îõyÆCöÆt4ŸàÛµBŞÎH†RI‘
Dip%B1(ˆH)øB:Rğ7ş8ªgã¡Ş@¼œµ„Ãy"|/Á4›02åQÙÉ
ˆcAZ;6Q,ÜÌ„ë`ß5EìÄ\NOMb,ÊBbHô„DœO	&£
œB(8	2(p©›vÒ(¸’È…^W42#Ä±¢‘;£H@Æš’  0´*ªä‘¨KÖP qROÂ–1R3#O3[¦àã)¡cAÕ2ÊtrİÖ—+E=[¶çÚùÌ´"²eÌÒL*BéÔœYeB”l ³…ÁYPáGQÕ l	ƒ¨å· ±Ë9÷[¥b4±ä[¥bëª&8‹¦LV[$JÕĞ^Ü "¨dlı„”\F3DÉ%aëä–¡ÜÔdr· ™jíü®¡¼Ek&e—ñuÑÈLY,ŠDfË<È]4»•@ê<R$hFÖFªì¹}¡ñÖœqô~ÆZs	ƒ{¸Ç‘Éû˜{ÆZå§”˜L™ø@èã\µûæDøG·†vĞ‘:i&f¤®e¦UZºMµ‚;‰Tm7ÓŠÊtWg€¬JaÊ®Œ«ªH‰²VG˜«È§ŒQş(sµ¨ªJ÷+£V>¶²Ï	W}ç¢PòR™8&b¤ê[V­4ªJåZªEa”Y’]Ô;U5ÔÒLªª‚Ú@ê¤”­†ƒ@VE=“éL+™ª–´™µF4¦´!@RRÏ6° jYr eÅæXÔ?Æk€F”4îñá®€j„8ûÙå60¤.)$û~Ü“QÆ‚y¥hµÍ7hSÕöìË}C³­sC¹o*îe°t7¼<L—J
ÆÔí˜òß ‘jsñ‚IKPñ»ôBÀ´şv˜‚àZN½ÁŞ0ÿâƒ…P•Š{DñÙµYú$û)]ÕÆ§8À¨®ø0lëö®T"ITíÚÈ±D*fªİÜ±DR¨Úòj€qÑ<¤c{î@ê¦™TUÓDe­Èlæ©“fR¦È§«h@µhiUñóxü”<>ùÓó2øétÛüÑ¥!Æ·S÷°çg˜ÁK”¥¥¼äBææôkˆİĞ}šëqÕ‹Ùá;=ö£„­VäsLeœNğÓÈ¸8dÂ¼91úWuj«F§jTjBÉ—“±ŒœJÁ!á†Ê1!å‹bB"ãñSˆDBÊ©,!	“BHÈÄ)!e!<‚/JæHÔjÿ_ÔCXï’Ö§L|šL&Â’Ï±—)<GB’™*O‘©•-ˆbş~Òq¼8&´€‘mJŸp3>Oòcy2>É©$J'%„$!,%VERT­„a˜û»
¨U(CgY
OÊé_Ô+Šú»Š©¹jµà‡KîÍ)ƒ_ô‰2u°õo˜bişïÙ†‚K‡g½1,ìáñËíŸ­C
ù¡<õ2çÇÉäd1Q[F¶Ğ HGm¯Qñ"ƒ8‚Ï7ˆ“‰Ä†q|2If'Á½¨q\¼Üµ€“cbbR bÄ^åğ_)“™ü(íƒš6pTÀ2šp¨2Ğ^™ür)ÿW.å¿ÖüØnå¿R¦ŸÏ¥PeĞ‹l£ÇùeòÿŠÉÿæQ…y˜Äæ¬”¥ñEş?KCÉş“õ8ÔYó ±«®«ß0±U)á|(JbŒLw9X>#ìÇ—ë7n–)àsÓåR9yyx:qIa‚7˜&Ni²¤:^¾NÍš6Vƒİ´q°H(“ˆøŠ3n! ›8)f÷NÜhQF'Oê;FLà,œ¸Á"~š@Hİ¦ORêªB±§‰ÚÁ¼t Ó0[–{é$¥7\—]vœ(åÒ–İÄ‰1wO÷(R’@
eî^À«¥SœÒàê´]Ç7eäÇÀÙ3r+:0êv)öø=8ô~ÚãÿŒ®³Å¸Šöe»…ÅÅ[(Ìf'Ÿ£÷]œ<ó|ù›]<ûIz	\¼OÌ¸ßú
O\_#VIûi¼ï>8*ÿ7¼oÁÆÄô(Ôƒ“Rì}g!f:†¯~–Q6¥ÚRhÊ®L¿ğó›ráD)¶b?¼J¾ ¹ù—ù	v©Yâ² o—Ú¿´UìGm'ú·ö‰iØ
—ÙR$•Õ‘²ï¸c*0$*ğÈ¥Ö“ñ(¼ó‰ëwã°KÆƒÃ.—.Ì±}[;NöÚÿâæÙÌ¢»â±Í»<ŸÜïÚıĞ]ºì®+¢wM„Æ‘×à·çûp¯#¾ßàX=³¼û]£ï–)rŞ1£vK+–=.Ùê™%ãs!Ñ'fP«|©PRIx¥.¢¨ÍYÔ¢<¦”ÔWw6özvW½båÈZ·x9²×¹/ VİØ˜Åq‹ÅG7–P¼J¾Â+EÁÜW7FÕÅXÑº³Fc&˜…Œb'©ı0:–±¥Î†:ç¦ºhë«áO²hKÃ¹4tÄVPc>zxTıö<iÉ‰"	7‘äóybŸ´ÏY™HŠğY	‘Nä,ÉY@]Å’|‚S%&AB’Âh:d<niÏZÌÚGf’