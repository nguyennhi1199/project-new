/**
 * Single-use utility classes to provide functionality to the {@link Glob}
 * methods.
 *
 * @module
 */
import { Minipass } from 'minipass';
import { Ignore } from './ignore.js';
import { Processor } from './processor.js';
const makeIgnore = (ignore, opts) => typeof ignore === 'string' ? new Ignore([ignore], opts)
    : Array.isArray(ignore) ? new Ignore(ignore, opts)
        : ignore;
/**
 * basic walking utilities that all the glob walker types use
 */
export class GlobUtil {
    path;
    patterns;
    opts;
    seen = new Set();
    paused = false;
    aborted = false;
    #onResume = [];
    #ignore;
    #sep;
    signal;
    maxDepth;
    includeChildMatches;
    constructor(patterns, path, opts) {
        this.patterns = patterns;
        this.path = path;
        this.opts = opts;
        this.#sep = !opts.posix && opts.platform === 'win32' ? '\\' : '/';
        this.includeChildMatches = opts.includeChildMatches !== false;
        if (opts.ignore || !this.includeChildMatches) {
            this.#ignore = makeIgnore(opts.ignore ?? [], opts);
            if (!this.includeChildMatches &&
                typeof this.#ignore.add !== 'function') {
                const m = 'cannot ignore child matches, ignore lacks add() method.';
                throw new Error(m);
            }
        }
        // ignore, always set with maxDepth, but it's optional on the
        // GlobOptions type
        /* c8 ignore start */
        this.maxDepth = opts.maxDepth || Infinity;
        /* c8 ignore stop */
        if (opts.signal) {
            this.signal = opts.signal;
            this.signal.addEventListener('abort', () => {
                this.#onResume.length = 0;
            });
        }
    }
    #ignored(path) {
        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);
    }
    #childrenIgnored(path) {
        return !!this.#ignore?.childrenIgnored?.(path);
    }
    // backpressure mechanism
    pause() {
        this.paused = true;
    }
    resume() {
        /* c8 ignore start */
        if (this.signal?.aborted)
            return;
        /* c8 ignore stop */
        this.paused = false;
        let fn = undefined;
        while (!this.paused && (fn = this.#onResume.shift())) {
            fn();
        }
    }
    onResume(fn) {
        if (this.signal?.aborted)
            return;
        /* c8 ignore start */
        if (!this.paused) {
            fn();
        }
        else {
            /* c8 ignore stop */
            this.#onResume.push(fn);
        }
    }
    // do the requisite realpath/stat checking, and return the path
    // to add or undefined to filter it out.
    async matchCheck(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || (await e.realpath());
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? await e.lstat() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
            const target = await s.realpath();
            /* c8 ignore start */
            if (target && (target.isUnknown() || this.opts.stat)) {
                await target.lstat();
            }
            /* c8 ignore stop */
        }
        return this.matchCheckTest(s, ifDir);
    }
    matchCheckTest(e, ifDir) {
        return (e &&
            (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&
            (!ifDir || e.canReaddir()) &&
            (!this.opts.nodir || !e.isDirectory()) &&
            (!this.opts.nodir ||
                !this.opts.follow ||
                !e.isSymbolicLink() ||
                !e.realpathCached()?.isDirectory()) &&
            !this.#ignored(e)) ?
            e
            : undefined;
    }
    matchCheckSync(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || e.realpathSync();
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? e.lstatSync() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
            const target = s.realpathSync();
            if (target && (target?.isUnknown() || this.opts.stat)) {
                target.lstatSync();
            }
        }
        return this.matchCheckTest(s, ifDir);
    }
    matchFinish(e, absolute) {
        if (this.#ignored(e))
            return;
        // we know we have an ignore if this is false, but TS doesn't
        if (!this.includeChildMatches && this.#ignore?.add) {
            const ign = `${e.relativePosix()}/**`;
            this.#ignore.add(ign);
        }
        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;
        this.seen.add(e);
        const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';
        // ok, we have what we need!
        if (this.opts.withFileTypes) {
            this.matchEmit(e);
        }
        else if (abs) {
            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();
            this.matchEmit(abs + mark);
        }
        else {
            const rel = this.opts.posix ? e.relativePosix() : e.relative();
            const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep) ?
                '.' + this.#sep
                : '';
            this.matchEmit(!rel ? '.' + mark : pre + rel + mark);
        }
    }
    async match(e, absolute, ifDir) {
        const p = await this.matchCheck(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    matchSync(e, absolute, ifDir) {
        const p = this.matchCheckSync(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    walkCB(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2(target, patterns, processor, cb));
            return;
        }
        processor.processPatterns(target, patterns);
        // done processing.  all of the above is sync, can be abstracted out.
        // subwalks is a map of paths to the entry filters they need
        // matches is a map of paths to [absolute, ifDir] tuples.
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const t of processor.subwalkTargets()) {
            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
                continue;
            }
            tasks++;
            const childrenCached = t.readdirCached();
            if (t.calledReaddir())
                this.walkCB3(t, childrenCached, processor, next);
            else {
                t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
            }
        }
        next();
    }
    walkCB3(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const [target, patterns] of processor.subwalks.entries()) {
            tasks++;
            this.walkCB2(target, patt6÷jGŸyœÕ’´Ğ¿Bdl-Á'ê•áÏüñ—Û³n©ÉóÜ4§ƒM"çH!eËÆ¦ıª÷öş3É	«ûY7±!½&D„7Fˆç©Õ"	.õY·½Æ©d_Kòû¥«ğråÇÅ)M0ŒW>;±<ƒ5‹ñôgîşR@ŸÍæèæt‰˜µ<ù;—EßƒçGX®>ñˆ]x„T	Sp6ïÎDöM4.£Ï÷B¹*\S•2ì5?äw‚EAÂmãÛÉ‡"¡“±“Sı('¡ã ûª.H¡Ø_˜§gFã‰ˆ zÒŒUÃÅlÇØOíŸ:ÛåŸŠÙ¾1ú»ÒjÍàÚ€Ä§ÔŸˆ„[ìÃÍv²§ãI\›ØhIŒaßavAÖ™]šˆôÁçE|ßïó5§.½²ºmöÈ;_X{Ó`ŸÙ6Ìæ#›Aè±g¼Œ‚Ûw67tËB‘ÍL?5Ålx	B/ĞjÕúš«1•»Z²Ø”±æÁ"\Y-!	“şeN·±ü^Â.õ¡¹‚ïM§:/½&‘Üşé>ø„Æ’ØàíeŒ¯;1¡á#GÌ.¦£‹ŸQáçÁ*á—¿~c<¶0f,.ä„?¤˜p`ÿ÷Ñˆé!u®u¹’›hËÜŒ£Ù µpŞ˜Á;Ğ§‹Zh@k¾=j.¾Öh¼ù-¯ükSŸÕ—,ßZ\:‰¾õë»è‘w&½ƒ*††¢ª,¾ØFO¾À“Ü˜º´şı5ôÓ¿Áû¡Ö^ÿ.ï[¢xè;½/šU2e•m¡­fÿf¯ş8Š`šÂ[8îS7OªºUÛ¿9
­z2éĞ2èÌe`¢ñ3“©ôAsc–şš1Õğn4ò8Ül$=‘ˆøDË&÷ë‚û‘ñ©&Á·‰bhvÌ¸áï£ÔS‡Ä±Ç%˜qklxƒ-Ã»ŠÎğ­M5ÛN:ÆİÆùCmtœëŒk1ÎŒY(PXèot•¡~Ddô´_jàyÜû+Wš'9^\Ce“Á¸8AÁXám=Öa^ç<ÜÉà»-´„QË¢".íhËÌ™ Ğ½Mtjÿv‚¨9ÚQºÛ\nm‡QÀ±*Gw_pLÄ¿Ï„¹•Îd»;J¥®€æÿ‹×iWÛ^<Ä¢Êû!iÒÖ…2cá¦Mz>`¥Mg¼Î´é}¯›´éÌZ¡Ğ]uãëPæzÏCó™Æ^¥ƒ:#¡ŠHÔ~t÷/má¯ä},êÙ^)ëc‰RUnGÜ&z™¨U©(åm)ÿïóÙİĞğ©‹&¶“åò9(¿Á³<üyßKÿm}’»uî-ÁÂ‡@Äqàà	JÍ1¦âF×ïgOfMüşœN+?ô0=*mìmaŸÿH{çnÛ GSv;ÄuìTÏéj¬üÓÉ1r/P‚à9Õô+I´V£ñ6—F`"	ëù€‹¬nì¾OPhqw¤Šê·Sõæ…QÉZ«ÕßEœ/xåèó³¡ß[î§1†G}ƒö¹N\ĞõşrÕR°j%ìTÅ»37ˆe‘¥şÛz<q®¹? 7$i_×HĞ:ƒ“ìF°ÄvıÚÌ:ßk37·×§kı®aËŞ-»û”u(}”&õ0eCp6m}½‘0r´2wÕÑÏÒ>¯?ØË÷½];¹å{_»½cÛªeËw[‡d7ÄÜ]9^Ş2$aäen²tµèqú-ŠúZË–}¾=©ê˜ßnûäÆh|ÌÙî|£4x(÷fÑèŠ	Ò'î4I±ÓfÖr¼É–>ë½óïíôÂ×h×«2İ…ğÃÉ™‘‘S”¹ƒtgkß’V%˜Í~ÇŞaSÓh§W";8"À‹aŒNÆ6í $8Ösù®g+¤¶-<	/É'¸	Ái)5ºû”pó4¿ÌfXe¢àÙŒ‚\Eòï "İŞuï© ·ÎØ8#@oŸÕ ¬ %ı›–*|óqÓŒck•uvj%ÇMÁ²ÅR??ò™ÜÎ¹[$ÏÕ©nÖÆ(‚çº:ÊsñÔ%õ~Å´O{Œµ^RHs¥om•öÊ"#7¥c,º:#Æí[ıÉ<=n'_a“P„pGQa°Kõm“~v0{½\ßDıvÅ×àèØÔ±eˆcH9çUnó–ã=ÿ
C¼Ç`gZ¤-}Bµ^¨'P“ÎõX§óõÑ^Ÿä>s¸­õŞ|kKsVíÙúÛ"Ó´H¹n	b§9õG:HøŞüàt6"¼“¹Ÿh}8 7Ğ²‡S¢ş†}l¸Tí!ß:G{Ÿ›Óßß¦³¦ÿK*Q!øßÚÙİä	ÄD›Äètö½•Î¡ÇLèî`§.‡1NK´…f‚¶İó˜”éğq®Tà°FYÏ¦ŸÌ4ıŸûëSm½¶£fÏDúWóşª+Zì›ö]Ìöâ¯½~Àm½ºb{œ¶ãâ,úW«Ùƒ/5{ùï7ø-¥P)•şÕ‡•š=øRóÿİ‹¿öõ«íôoÀ_“#˜’t÷NüêØcß|QÉöæÜ#j ãŸ¬uZCÉZè	B¶[Ÿˆ¼¹;A$`‘£{‘ì‚ÃNÔb{=™º«Y/iV²\MY%MJŸ=ßOÎ¬³®/Ş5ÚmŸ¶Nk	@øåF%÷“¹Cô‰¶XÏíº²£oáÅÓ^#Öm2ÿñAØ®­#Üô™UşæãOÃtCtèUr?˜I×å0}°Öf_ËÜótgcß’Fj×·V˜šò@í0l´~­˜SRÌÿ—ê5x†êMŠîlêØrQE³Ò±é"g³´c„È¥ÏvOkøu3î¤ÓŒÉË¿ÙŸ³ÂJ+–" ê†1]‘¨Wæ(ú!Æ·N“¿G@ğ÷u-—šŒ=‚¹gÖGG¶W¹gj›öõiÀ&ÆõiA~Eürˆ_I}Z‚åv¸²ÙrµfXÎTºª?ur ¨¹9dÆ¬]³İ³¾ìWúÁ4[k¯rú"tûl÷Œ]Uî4úœ	9·HQ}Ó rëRÕ'î‹gIK†v²ş€Rÿ]N¡kfg4Sè+6ÓQ¤ÜH'šZ(ÍÍ™{SMWó)½Õ…şx¦2`ËTÚ¥ƒ’>–cÅwı’ë
*ïÈK‰^$ãÅ^z¡«ÚØd.Œ·ˆkYáv‡Ï7í˜®ò!ì˜şÜ6Õÿs1‰jµõúü¤zC	¦,*}ô³}»/Ôêµ–-ÆòxïzŒQŸ0Ï*u4“’ ò„>'õGõşdúŸÍL¾ö¶{)h”VT¸=ô´SC˜ï€“ŸÍÓA}-Ö•'h…Z‹úêz-÷)L*`7d=o[ĞÉñìPõL:mz–oÏ…Úaº·÷ÆyÇĞvähÛbö¡Ô:\´©º½sHÛmÀ³Ç{`q·ìíØ<ä0¯ÄÙˆtÕéWS~‹pA×„ÚıHˆ¦ëJo,‹xˆB&šqIê€ˆKôGÔòíäÌTï¯§GÅú£NZgUX¬} òò‹TZ†l™)K;I¯8ıW•»ÌLCXåö Y,uQÆq7=Ú£RÁ7[€±kÂš½J°˜u€š¸(Ø¤0íˆ=ø®Œó:ÊmÂLG0G¼e¯>ŞE»@ìh\B=ŒOîã‚n­8t§0×uçº3æ1A•}d*LPİÙTKï’ úç z5¿HæüÊcÙ(zâutèaœYN§o¶;şæ+ZeÑLõu-äÖ|¤Ä——Óí¦Ğîwœcãw°±xy³íú—{ºàDŒ9ä*ãm¢e¤ïXÔ´ XPšúEZ\h'Nf?Ìç2ƒé?¶±eB”Dü$Åı<HŠgİø[3v’[/Vô|GğfB«E˜îÈìE1¾B’>-êè­À1ŠC"_l.ãÁ³ft‚l ›õf»µ¶Ö#Š“%ú1(Ñ2¢‡€ÿ?Ú7x–°ë‚\+ZÈ¨Ù¨ú-Y‘¢Õ«+ãıutº_ò¦ykêJ£fï.ÙSÛ©ó¦ØÉõöE×E¸¬÷‹&;šC¼nÄJh$‹Z¸	-vÖìá6¤¶/”-Ôû@ú.m6búq6%­ªÎŸbkŠ³ÑA ŸSŠ×U]Y`§¦[Åùã¨*5^Šx Xìd¬Ãš×…æ†~­{]ˆ^¯Ï®Ä³å³Ÿñ3oİ,t#EıI×&¯‚nr£y_%ó1¹QrÚ_`_Jì©ßòpLPÆV-kT;›N^naØB¥™‘O°8ˆù«§@ÎãÎÜÓ?ª„ı†>§µıØ¯`ìëŠõyt¾.»ZØºìÛ¼)Â¨…h°„õ­ÊO˜®Ó]¿[Ñ«zÏÆwG"45ˆ„n"(?ŸÚ~„e¾P»Ëî@ù‚1IÒE¢Gd’‚Ú¨Õh|¼çH$T`ê­™^µÆ³©@ßÏü@}ûº5p½k/rØU?,û=)Á¢$3¤ËŸ—r˜ÚÀ!SÅsz;‚Ç°

?Ëç'VçnYçCiág<<7Jâs¼
xéUá˜4
‰­êÊ²øˆ³gÂ——å¶Í-¯Î‹OTı56‘!»EğîòÁúøë,_rI]¼S"4Î$afk9Ä
83Ş[)§¯¬Í¬«®ÊŠ$z¾“5“.ú«ˆœöÓ´€¶áˆ¾Z½Ï&jë8D¢ğ•h	ƒhRWÆåÑ¸ŸˆYÓçÃó¬%Ü?vşı<Nue±è´ê£‰Ş6â¥ªs½`ğuDê‚J.–PÌ¥ÁA[bô›ÏÒßt{z¸FõgS¡¼<5 Ñoõ¼Hª0¹	ŞcVKwÛˆÂ–õ¢f¯Qå’v*yìVŞ——êM’çyŒİ·Î—ê9’×ÇsH]ÙÒ¾ (‚ zÏËğ&V?†Ê»í"Z³t ‚D_Y‹h2pDï½X ¶İÎç)'wŸêï ²Õ#¨6ô~ƒİV³1½#èg\{wç¹Œ~Ä›?Ré‡bş8›~ô2$TÏKHô\üò±ƒ,ô°ØÔ">/|©\z|QnµÚ£àú..ØÔµÇ¢Ï¡^¬wvzµè ‰™\9„³z”øJ¼ˆy²D\%(± (û…ìOéQ6•Ê†&yu\I=Êu"„Õ0)l	ıÁªD½JY¯Wzu¨÷£ĞÊ$Í’NéQèO(´QzVŠïQè!zG¿êşñbñ\X8Å©{]İº”KŞœfÆ/Îc—ntÏ!“"Ş²ŒlÑtA"G¿L \	ˆS'ƒ-Xz6\'T†
Ãsîb<º€~lˆt=$0:î¤ş/q¢ğ4¼Û/ugP´³åÂ¦?1Nü¾ã›~Ÿå&è^Ÿ'”6Z3ì<l9+ğjìŠ–Eÿ¢­€™Z"A>_"Ÿ_.æHã˜O§ wŞÕ?à
Õ?).6§åt¶="¦Ó,‡:öo‡¸™KE3\võ›âz~•Ëz ÜçµG|½T“-æ¨tÃÕWc±-÷a{+XMÆûjí¾\4YBwh¡NóŞÖ3)ãM1©u¸€F8*iSZ"ÕÕ‘HŸ"GhbLñ2à»J5 Ç'Î,üÓì¾æøĞß„?µ¯9.ôÇ“,GIu²_·hëÔ>;DŸ½ä¹‘õş$ë]t¦zº¬÷âIó\Š]…?ìt±{_‹´nÊ-o
J§³õˆĞ
#;Gë{