// parse a single path portion
import { parseClass } from './brace-expressions.js';
import { unescape } from './unescape.js';
const types = new Set(['!', '?', '+', '*', '@']);
const isExtglobType = (c) => types.has(c);
// Patterns that get prepended to bind to the start of either the
// entire string, or just a single path portion, to prevent dots
// and/or traversal patterns, when needed.
// Exts don't need the ^ or / bit, because the root binds that already.
const startNoTraversal = '(?!(?:^|/)\\.\\.?(?:$|/))';
const startNoDot = '(?!\\.)';
// characters that indicate a start of pattern needs the "no dots" bit,
// because a dot *might* be matched. ( is not in the list, because in
// the case of a child extglob, it will handle the prevention itself.
const addPatternStart = new Set(['[', '.']);
// cases where traversal is A-OK, no dot prevention needed
const justDots = new Set(['..', '.']);
const reSpecials = new Set('().*{}+?[]^$\\!');
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// any single thing other than /
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// use + when we need to ensure that *something* matches, because the * is
// the only thing in the path portion.
const starNoEmpty = qmark + '+?';
// remove the \ chars that we added if we end up doing a nonmagic compare
// const deslash = (s: string) => s.replace(/\\(.)/g, '$1')
export class AST {
    type;
    #root;
    #hasMagic;
    #uflag = false;
    #parts = [];
    #parent;
    #parentIndex;
    #negs;
    #filledNegs = false;
    #options;
    #toString;
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    #emptyExt = false;
    constructor(type, parent, options = {}) {
        this.type = type;
        // extglobs are inherently magical
        if (type)
            this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === '!' && !this.#root.#filledNegs)
            this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
    }
    get hasMagic() {
        /* c8 ignore start */
        if (this.#hasMagic !== undefined)
            return this.#hasMagic;
        /* c8 ignore stop */
        for (const p of this.#parts) {
            if (typeof p === 'string')
                continue;
            if (p.type || p.hasMagic)
                return (this.#hasMagic = true);
        }
        // note: will be undefined until we generate the regexp src and find out
        return this.#hasMagic;
    }
    // reconstructs the pattern
    toString() {
        if (this.#toString !== undefined)
            return this.#toString;
        if (!this.type) {
            return (this.#toString = this.#parts.map(p => String(p)).join(''));
        }
        else {
            return (this.#toString =
                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');
        }
    }
    #fillNegs() {
        /* c8 ignore start */
        if (this !== this.#root)
            throw new Error('should only call on root');
        if (this.#filledNegs)
            return this;
        /* c8 ignore stop */
        // call toString() once to fill this out
        this.toString();
        this.#filledNegs = true;
        let n;
        while ((n = this.#negs.pop())) {
            if (n.type !== '!')
                continue;
            // walk up the tree, appending everthing that comes AFTER parentIndex
            let p = n;
            let pp = p.#parent;
            while (pp) {
                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
                    for (const part of n.#parts) {
                        /* c8 ignore start */
                        if (typeof part === 'string') {
                            throw new Error('string part in extglob AST??');
                        }
                        /* c8 ignore stop */
                        part.copyIn(pp.#parts[i]);
                    }
                }
                p = pp;
                pp = p.#parent;
            }
        }
        return this;
    }
    push(...parts) {
        for (const p of parts) {
            if (p === '')
                continue;
            /* c8 ignore start */
            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {
                throw new Error('invalid part: ' + p);
            }
            /* c8 ignore stop */
            this.#parts.push(p);
        }
    }
    toJSON() {
        const ret = this.type === null
            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))
            : [this.type, ...this.#parts.map(p => p.toJSON())];
        if (this.isStart() && !this.type)
            ret.unshift([]);
        if (this.isEnd() &&
            (this === this.#root ||
                (this.#root.#filledNegs && this.#parent?.type === '!'))) {
            ret.push({});
        }
        return ret;
    }
    isStart() {
        if (this.#root === this)
            return true;
        // if (this.type) return !!this.#parent?.isStart()
        if (!this.#parent?.isStart())
            return false;
        if (this.#parentIndex === 0)
            return true;
        // if everything AHEAD of this is a negation, then it's still the "start"
        const p = this.#parent;
        for (let i = 0; i < this.#parentIndex; i++) {
            const pp = p.#parts[i];
            if (!(pp instanceof AST && pp.type === '!')) {
                return false;
            }
        }
        return true;
    }
    isEnd() {
        if (this.#root === this)
            return true;
        if (this.#parent?.type === '!')
            return true;
        if (!this.#parent?.isEnd())
            return false;
        if (!this.type)
            return this.#parent?.isEnd();
        // if not root, it'll always have a parent
        /* c8 ignore start */
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        /* c8 ignore stop */
        return this.#parentIndex === pl - 1;
    }
    copyIn(part) {
        if (typeof part === 'string')
            this.push(part);
        else
            this.push(part.clone(this));
    }
    clone(parent) {
        const c = new AST(this.type, parent);
        for (const p of this.#parts) {
            c.copyIn(p);
        }
        return c;
    }
    static #parseAST(str, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
            // outside of a extglob, append until we find a start
            let i = pos;
            let acc = '';
            while (i < str.length) {
                const c = str.charAt(i++);
                // still accumulate escapes at this point, but we do ignore
                // starts that are escaped
                if (escaping || c === '\\') {
                    escaping = !escaping;
                    acc += c;
                    continue;
                }
                if (inBrace) {
                    if (i === braceStart + 1) {
                        if (c === '^' || c === '!') {
                            braceNeg = true;
                        }
                    }
                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                        inBrace = false;
                    }
                    acc += c;
                    continue;
                }
                else if (c === '[') {
                    inBrace = true;
                    braceStart = i;
                    braceNeg = false;
                    acc += c;
                    continue;
                }
                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {
                    ast.push(acc);
                    acc = '';
                    const ext = new AST(c, ast);
                    i = AST.#parseAST(str, ext, i, opt);
                    ast.push(ext);
                    continue;
                }
                acc += c;
            }
            ast.push(acc);
            return i;
        }
        // some kind of extglob, pos is at the (
        // find the next | or )
        let i = pos + 1;
        let part = new AST(null, ast);
        const parts = [];
        let acc = '';
        while (i < str.length) {
            const c = str.charAt(i++);
            // still accumulate escapes at this point, but we do ignore
            // starts that are escaped
            if (escaping || c === '\\') {
                escaping = !escaping;
                acc += c;
                continue;
            }
            if (inBrace) {
                if (i === braceStart + 1) {
                    if (c === '^' || c === '!') {
                        braceNeg = true;
                    }
                }
                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                    inBrace = false;
                }
                acc += c;
                continue;
            }
            else if (c === '[') {
                inBrace = true;
                braceStart = i;
                braceNeg = false;
                acc += c;
                continue;
            }
            if (isExtglobType(c) && str.charAt(i) === '(') {
                part.push(acc);
                acc = '';
                const ext = new AST(c, part);
                part.push(ext);
                i = AST.#parseAST(str, ext, i, opt);
                continue;
            }
            if (c === '|') {
                part.push(acc);
                acc = '';
                parts.push(part);
                part = new AST(null, ast);
                continue;
            }
            if (c === ')') {
                if (acc === '' && ast.#parts.length === 0) {
                    ast.#emptyExt = true;
                }
                part.push(acc);
                acc = '';
                ast.push(...parts, part);
                return i;
            }
            acc += c;
        }
        // unfinished extglob
        // if we got here, it was a malformed extglob! not an extglob, but
        // maybe something else in there.
        ast.type = null;
        ast.#hasMagic = undefined;
        ast.#parts = [str.substring(pos - 1)];
        return i;
    }
    static fromGlob(pattern, options = {}) {
        const ast = new AST(null, undefined, options);
        AST.#parseAST(pattern, ast, 0, options);
        return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
        // should only be called on root
        /* c8 ignore start */
        if (this !== this.#root)
            return this.#root.toMMPattern();
        /* c8 ignore stop */
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        // if we're in nocase mode, and not nocaseMagicOnly, then we do
        // still need a regular expression if we have to case-insensitively
        // match capital/lowercase characters.
        const anyMagic = hasMagic ||
            this.#hasMagic ||
            (this.#options.nocase &&
                !this.#options.nocaseMagicOnly &&
                glob.toUpperCase() !== glob.toLowerCase());
        if (!anyMagic) {
            return body;
        }
        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');
        return Object.assign(new RegExp(`^${re}$`, flags), {
            _src: re,
            _glob: glob,
        });
    }
    get options() {
        return this.#options;
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODY of the regexp, along with the start/end portioí’g<KÖ;rYïÂw³Ş“{Èz¾—µ[î!ë#‰œ¬Oä²öHäd}&-%kŸÜIÖ~¹ÈÜ2ë+øyÖRöAFğ¬ƒøï!ãxÖwğ·¬CÒ²„=³–hÏşUâ<ûwy–lËÅh˜'fÇÃã³;ÁIÙ]àälœ™í†³³=pn¶.ÈNu1>BzËìt| Ò[fgâAÛ,ÎÎÆWCÚKv7üH{Éî_
mS›}$>mS—İ¿²ÒÌîƒAb;»/¾ÛÙıñMĞ6«²ÂÓ³Á3²Ã3³‡À³²sáãÙ>¸'»€ü{!e•]ˆÿ²
Ë.†?gKÊ/ÙNöH˜Óu4)C #H×|.¤7èZŠ÷AÚ`×qøHKì:_Aº–á‹!‘Ğõ¸®ëdWgs®™Ø½³Y£¿•¾@}¡ş&ú2ıôúÛç«ô—Î×è¯›oÔß2ß¤¿_¾Y³|‡yš¿‰qgÚÅ&)îl˜w®=Ò\W×ÇÕÛM¿«à€§Û³ÍÑg™Ùæ˜sL¥™ÛyYjêRßs©é×¥¡g­©ïRajMC—¹GÕšå]N„+ºœtTy¢ËÄîuæ/ì­3Ouñ›æîÕğŸî3à[î³àÛîs¸¿ä¤óaJÒZX•t\˜´Îl2I—ÃåIWÂIWÃÓ’®…«’®‡§'m„7$5Á“òØdnJoN*‚·&­&ıö¤3àIgÁ;“6Á»“Î÷&m¦D^âØ-æBÏ÷s±çBx‰çb¸Şs	¼Ì³Şì¹Ê}‡Ùë¹~î¹~©)_“óó9ï0ß’óó“ç˜—<‹òÍOcî2µÉwºï2uÉwÃúä{á™ÉMæó÷äûİ›?{Ï7›'¼káKŞ‹à+Şufó®Yæß¦&}ùØü'½¾çÇæƒô†{ÌÍWôÙknÏ¼Ëì5wdŞïÏ¼>˜ù€ùÚ,Èš{Ô×¦*ëD¸0ë¤£¾1Oe=d¾¡¯x¾”õügÖãğ­¬mğí¬'á¿²¶Ãgí€f=?Í¿Éz~›µ•ı¼ùŞÜšı¢ùÉèZÕÿ'st×…ğ˜®‹aN×SáĞ®50¯k-ÌïZ‡u}ªßOÄğ³px×§áˆ®…ã»Ö³wb×x|×åpR×pJ×ÓúÿlÎì:Ï¸¬#˜g2-Ó½Éiİ}—)²nêÑdŠ­ápëŸ=fön½Õc6|»Çø¯Uğß=ÂozÔÃo{4ôo-ïYß¼µ¢g\Ó³
^Ğs!¼°çbxqÏSá%=Ÿî7ŞZßó¯ğ²5¤\Ñ³^Õ³^Óó)Ò¯ëù,¼±çrRnê¹ŞÜó´ş­z>èh™^C»×£îË¬sûÍ=ê2kM¿áıN:êkxÿú×X£ú7ô¼Öš¿Öš‹ßd}Úÿªş›¬½ı¯?ô¿sĞ&ë§şwÃ_úßë/ì0`{;8vp&Lp6Lp.L°&¸ ¦¸¦¸f¸fX»¸¬ÿMÖòsºÉZ1àDxÚ€“Úl½0à³ÙziÀ@øö€ûo¶>àZ›­¹Öfëc®µÙú”km¶ör­ÍÖç\k³õ×Úl}Éµ6[_s­ÍÖ7\k³õ-×Úl}Ïµ±>4Õ~ÆúxĞXøé Ipï )ö¿¬)5ÿ²n:fœÙm%.…‰ƒÇ™Ÿ­‡ñ?[â=vFÎ˜•³‘„=r–Á9!Ø;§•Ód²íäÌ¶«È™m/Î¹JÎl»†œ]í:övµëÙÛÕ^s\ÁŞ®öiìímßŸS
Ìg³³†–Â®CÇ™qö0ü8»?Í¾?Í¾?İ¾?İ¾?Ã¾?Ã¾?ßş?ßş_a'ä.‰¹KaJî«0-wÌÈÁ¬Ü×a×Ü&Ó`¿û†i´?À¯°¿å¨ö÷µÂş!÷MøG­°á¨óìayK`QŞR8"ïU8*o<.OöÉ{Ík2kì‰ä\cOÎ5öTr®±§“s=“œkìÙä\cÏ%çZ{19×Ú§’s­]›÷.¬#çZ»œkí†¼÷àrr^l_LÎ‹íKÈy±½œÛ—‘óbû
r®³o Ï%öÍä¹Ä¾•<—Øwäİï$Ï%öİä¹Í>ÕW
k|ãÌív-şv»½}ş-;¹`	L)X
3
nYË`×‚™iŒ9Yşt†ü3èt/z=Gÿ@òÏæ|!ÿBúÉNİÑ`T€F¡	h*š‡ SÑ
$ÿœ±üãb¯¡wĞ‡hêhãFi¨êFyh8ƒN@3ÑÉh!
¢è,t!ºİŒîBß¡ä8c²Qo4å£‘h<*GĞ©hZÎ@kĞ¥èzt7z=şşŞE¢ÏĞ×èGdw0Æ…RP6ê…rĞ±h,šŒf£
´-Cg¢µè2t=ºİƒEÏ WĞhz<Ç PGc6¡mèôÚ‹~E)Œ9• ?úıŒ:t¦LÑIh	Ú#»æÆüY	Üêé2f :]‚FÏ£ wÑğDî-só/TœdÌ´İ‡ş‚¾AñÊB§ ehúıŠz's4¢ãĞ$4­AïyIM¡Ğ±hzíBĞïèŠTÎ“fÌ‰ètÊMç9Ğµè/è´)ƒgDï /Ñ!42Ó˜¹ÈîE_ ßQ÷,cV¡?£«³):‚rBMèL´]†nB[Ñ#hywcBÛĞ+è=ôêÑÃ˜şh4
¢hz	ÙG3mGŸ£CGÊ?{eL”‚º¡(‹f kÑ½èè]ô3šÒË˜Ztz	U÷6f#ÚŠB/ ïĞohR}‰‚Gqz½„>Ey}9]¾GñıŒñ h=ú;Ú‡~EİûËh6Z†îDÛĞè3Ôy Ï&¢ztÚ ù?ÉÛèôú
=;Ğ˜QÚÑ”5Z€êPïAÄ;ú:mEO¡ĞìÁÆ\‡6æs;jJ;A/¡=hT.u„GŸ Ô<c@óÑg(ÁgLz
}€¾A?"“O¿n@¢—P—êõCCPò£SÑÙè*t3zõÆs¢«ÑCèIôrÒ bTV¢§ĞNôô#ZÄ~t&ºı­.¦ßAo¡÷QÇáÜ7ê…ŠÑd4Õ¢&t)Úˆ2FPg¨/š‰V¢+Ñ7(n$Ï2ÑıèmôñHùkPß£è³Ñôú¥6æH”C mèYT|m-@§¢z´İ†EJ/ĞKèc”6†ûBP­F{Ğ×¨¶”öŒnBw£¢ßPüXâMD7£ã¨Gô3JOY Bg£kĞfô Ú‰ŞGŸ ßú_4­@kĞ¥è´	İ@O ïDâ%—Ñ‡£ŞhZ„êĞèôä><h0‹Ö£Q'Ğ~P§IôU(n2íe¡õèjtzı†r¦SŠšÑƒè;”PNûG£Ğ´.A÷ gQÊTê]Œ¾A•Óè·ĞßÑë¨ãt®‹z (@ÑÉèôâcşö¢îü>TFé³x.@At+:ˆ.™M¹¡İè úÅÏ¡,Ğ¨ÊAÃĞı’>×˜®hš…ŞD»Ñ7È=òC÷¢ÇPá‰ŒQ(ˆ&Ìç^P:İ†EÅ'qïhú¥2Y©G¡íè]ôJı÷jĞEè!ôúı€Lu„¼¨7…¦£ jBg¡PÂ)œ=‹Nö«èôúYwĞdÔ€îBé•”*D¨­Fw£ŸPzñÀë"ôJ^H[B— ¢EÆ4¢]ètébî{±üËåÎ¿ÿ=êTM£	è.ô0z=‹&Êı¡·Ğ^t ı„â–“ˆÒÑˆ) ™‚¡Ñ£èèsTRÃX€D–ÒÇ£¨_-Ï‰®@Ÿ¢AÆYô7Ô¯²FFÏ£ıhö2ÆSt>ºİŞF¡/Pßzúxôz}ˆB”z¥7—h4z\N?ÒÄµP!Z„êP3Ú€®EwÈßôè	ô%²š©G4]€6 ı(é4æèÏ({%c$º½„v£o{ñJĞ)¨]‹ŞA¡ïQñjâíB®Óy.”‹êĞèAôô2Ú… _Q
ìh.º=|&õˆ¦Eÿ…^CÿF¯œM¿~}1€rÑpTŠ®FÿB©çÒ†Ğsèô.úıŠœÇ1h8š‚æ SÑVô;J[Ãô=ˆ.;Ÿ>½†>B©/¨5¡çĞ+è#´D¿¢¤µ´s4Ñjô:„Ì…Œ¥èX4®BC_¡ChğEÆì@^Ì8Œn@»Ñgè úyÖ1v¡hZ‰.B·®“ÿ»õˆşŠ^Bo¡oQçKhãè´É‚æD´}ˆ¾FŞõŒÁ¨.F÷ k÷":ÍC§¢-¨uÅ´Ø0=—ÿ{ ù•´G/±ôë´MËïşÄõ-Û‘cä¿ÙwÚ-ûœsYÑãš¶Ú=nû>N·Zg™¸°ÿ–}×mjÙ÷ºÕÉü½ş‰ŞDo¡]èm«3ë¯$ó/ô®Ulşm•›÷ĞĞûè´}hÍ4Y³ÍÇÖ<ó‰uŠùÔª2{¬Ef¯µØ|†>·jY¿Õš/Ğ~«Î|i-3_Yõæk+d o¬sĞj4ßZ§™ï¬•æ{tı€~´N7?¡Ÿ­sÌ/Ö¹æWëBóúûBc!Å¡(uDPgÔ% JDn”„<öÅ&Ù^g¼(¥ÚëYW®7é(ÃŞh2íMÊ¶7™®öM¬77›#ì›MwÔÃ¾Å‰zÚ·™^¨7êcßn²·˜¾ö¦êoo5Ğ@t´}—„±ï6ƒí{L}Ÿb?h†¢\ûaÖ¯Ÿı¸ÉGö63Ì~ÒÚO›"{‡)FÃÑ±öN3Âş»i¿`FÙ/šÑè8Tbÿƒuï;¦µß7ãĞxû3ÁşØLDeö'æx{ëâ=fšlï5SP9šŠ¦¡éhšiefÙÌlû3ÍEóĞ‰h>:É>Èºú ù“ı©°¿7§ ?Z€*íC¦
ĞBûG³ÈşÅ,FÕöïæT´ÕØÆZŠjm—´­:´Õ£í¶lÕh'[Ëít«ÉÎ°VØ™V³mfw³VÚGX«Ğj»»u::‰Î²{YgÛ½­sĞ¹è<ûhk:ßÎ±.°}ÖZ;ßºĞ.°.²­‹í"k]l]‚.µ‡[ëÑ{”u™=ÚºÜ>Îº]i—XW¡«Ñ5öëZ{¬u=ÁºŞhİ€6¢Ñ&t“}¼µİŒnA·Ú“­ÛĞíh‹}¢u‡}’µÕ®²îDwÙ‹¬»Ñ=è^{±uŸ]mİo‡¬ìó­í¬‡ìK­‡íÖ#öeÖ£è1ûJëÏèqô„}µµÍ¾Æú‹}­õ¤}“õÚF;Ğ_Ñ3ömÖ³è9ûëoh'ú»}—õ¼}¯õ‚}¿õ¢ı õ’½İzÙ~Úz½jÿÛzÍ>Ú~İöÙÿ°í7ìbûŸèM»Á~Ë^gï²¯’·#¦Ø¤Ovz‹c£n†¹Ìçô³¢îº¨»!ê~ˆºã¬ˆ{É:"Ã9Ë1öÌ7´avdïğ¨eGòg?íôzÇEÓÆFóM‰îİ[İ[uQwZÔ­ŠºûÂ.ÙÜyÊ;ã"{ïº'¢.¿CÄ-èPéq¨ŠºvxçqÇ½uDø<ê¾ì)ƒo£i?Eİ/Q÷[Ô™xqzÆøÈ™;ÄGövŒîíİÛ9šÖ9š–ÿ—íÎYÑc»FİQ×#êzF]ï¨;)>RâŠº3£W;3Ş[á¤İ=â«.w K¤Ä¯w]¿?aI‘½ó£îê¨»6ê¶{#å¼#êº£îå”6iù˜ÌlçØæÇìÈYBİ"¥ÑÿˆHÚ„¨ëÓ=²·o÷HZI4­4êöw”ä¯½#eğ{ÔY}"..ê6ˆ”Ğ†N	u0³E®Qæ‹–A¾¸CÆvƒÃÍ1ñòUØÇú«òåÏp %y)Z½:ŠÑüC¬r|¹u-œfİ§ş8C÷–[Ïâg…ıø9aÿaGy?{@ó‚ó­Ä'Â“­nê{É;E« “\åXMVZÇ«/‡ÕÊ u&lÒ»Z­\«W¹H¹ÁÑÙ˜ëõ*×ë97YkHÙbınUŞgı¦ìĞEÎĞ¯‹<£œs rÕ#A¼pÕG}õ9êsÔç©ÏS_¤¾Hı(õ£Ô—ª°NS¥¼Ly“r‹ò~åãÊ	RŸÂ{mË%µ¶ºlá,ûµDIKùïDI9˜(ÏRâ–k	WÛEzì-ø¶ÜíF{J’ğOÊÓàcöø¸};Üf?
·Ûû”¿(İaš²›ò(”í©êW*ÏU®WŞ ¼Cù°òIøªùMå[Êö3å~å!û©dá³Ê×”oAw\º—™¸²U¦*¯ôÊ^¹srPÜë^y"9ÛF["vNœ·òŒƒ”­©â…­Dõ‰êÿ¤yş¤yºkzwMŸ¢éS4½Ÿ¦÷Óô!ê‡¨/R_¤¾\½p»íWª)WÁuq—¤Ê»şK4ÿFÍ¿Qı-êoQ¿UıVõ÷©Ş'5x_ÜV=[rš0>7R}©òø4©ÍiiRGÇkJÜ¦yÜqw¤I‰	Z÷¦É™ïUÿ°ú‡Õ?¡^ÇùÓš"ÜhKúî¸òtê1Nò7i=qOëµö¦¿J—šËĞrÎĞr–·áöHÍ/¾5G¹:Cò_¥¼Cù¨r»ò5åî‰Ì½0³ƒ0[ÙMùª¦o´;f
S2å*Óaq‡õÊ›2åŞœ;üV½!âï³&dÉ½ÉQË:HÕá¶/)-É3HIä¨ï¨~J¶FE¶ø™êgª?Qı‰êª_¨¾Q½°õrWáAev7¹É³İ>òá ååå	Ê™ÊGH’§{¾Ãt}Ò§ĞV÷u˜Ş]Jã$ø”W¸İ¾vŠß»(ZûºËiïÑ¤=’7¾sÉŸ¤Lï!WñõüÅ=$¿°[üB¥ìí_¬97(¯é!‘¶UııÊÇzH=-ù•]â…¯ÚÂ &Ã“ş&ç—Şip¼´÷=Ú;íWÄ§)½´ì=dÄ{ãÿ¦gş»|a¿ª|[¹Î‹? ç+OVV(ıÊJefa@ı"å~{bOc–ª÷*Zó{Êó
Z~õ~õ‹Ô/R¿TıRõ!õÂ>Ö…=¥]<¡-¨_/í+z‰—3Rºãr{Iëºã
ÕªoR/Ü¿·—Ô‹p»ıƒ²coí‡•½¥u© ÌUï­‘ß[JXÊm_‡•½…êQWô–:z¤·<õ¿zKı&ôaÆĞÑé!é#w(ì?vÑt·Ò£Ühÿ½äü»æn´iÊ!Mö±º%÷0@™£ÌW?JHÚ'9‰ö¾Â~ÊåñÊ•}¥¥KşÌÂù…ÊÁñ9J‰ùÁñ[ú
¥?9dßÓWîd|?¹a«¦Ÿ¤K{Ènê'×•ô¶p»ı½²s¡§¿öäÜÚQrnÓüŒqıåºâÇËSl·4ÿ¨şÒ{Oè/e(h]Ğ_®+\­Ü×áåoğÕE„óHH~á+q Pjö€•ªşßiºÖÚ¨Z&ğiï´rÔœr†9ê¯S/tÇİ4P"G˜ÚéAØ½“´ í¶}´Ğ¥<òh‰~Ê!°W§MŸp´ŒGâZS–s
÷Ø'-q"ØéFõ7jW4Ï+zì~å·°¸“´ß¦ğ¨—<HG%xl§Aêé)'’r“z|Sg&O{ÅßgUæÄ´,W´Q/Ün/Ì•+”g(×äHé]‘#÷ù¦<¥Ü©|-Gñ©5¡7^8Ğz?GÎü¾úOÔ¢~Ÿú}êW/†çojŠ°u¿ò-å/C¤§’':1IÚË‰I2ß81IÊjµöx«u²ZKox’ölvéP‰½éÚBÿ3TZè¡Úê•s5>•Y¹rşgsåŞÊ•{xKÓÿ+#û\é]hÊ¯Êy’âÎ“r´äÉQÂ¶p¿½8OîÇñ)>¹úQ>é«ûäyetäóIKÚ}„¿ô¾j·Û÷*Ñc_Vÿr\Ö95_®;PéË—«;””ÔN£óåN¤T—ÆŸ/õ"Ü`ı%_¢ô™|y®·óeø2N>ùì,| N¸VSè=”•Ó$=·@îVöşÒ[¸ßnR®+;—”7•]â…Ûôl{l™Ïììü	şùÎÒŠ_Tw2LÆ©-òÙjG¡Gù{g_¡ÔûC…RVoÊ3î/”§sxPS„¬ø"‰ü$e–ò¨"¹Ÿñê§é¸S¤ãz¿z!3"åÊ'”;”/(_/’2‘«¯Õ{†¯ø)é…]Š´Q¬ëb]ƒ¨/S_¦¾\}¹úYêg©Ÿ¯~¾ú…ê…™šàÈ.BÚòråÊmÊg•/+(–™€äï¦œ Ç>n{†ëX¯«¬T«¼o¸´å3f[î¡õè±Ò×ıãXéë„îE.[h©ßÒEÆ…uqBOGyö-V¹ÎEŸ!é!ÏòÒyaPgşÛíwG?T~6BJïùJwñ”ü=GJ~a“rp¼Œ)Aëì‘Â4Ï%šGè»b¤Ü¡ğ`—³•’g-£ù~åãö«#å*_+½£äº]GÉÙú(*‡Œ’\ú=¶Üç~Û¹Û/FÉ¾%Ç&ŒRN-euÑh¹Oáë®ÑRJBêb´ôÿT¾;Z¢îCå£¥E|?ZfŒÂ§•ş„ÌãŒy)¥ä8)I§wj>Nx¦òüãäZÎœğ†ã„’rÈ<pœ´¡;îM9V´Ş•tk÷qRJ»ÕïQ¿Gı~õûÕTPÏ/9÷è±_9Ë–óì"é‡ì’ê4¡¡Dâ)gJ´6Õ¿«é_+QvcÌµ	“ÇHéÍ#cıIc$gÍ‰ñ›NÒ½ç‘hŸÚéª1rEY<—ĞTªñ_*WY­<WyÜ©{é-|Õ¾¬)ovzã…­GJåéQÿ”z!³÷RY§¼W*OíÔòà±r'ÃÆÊ³Ï+åyÊX)O!íq¬¶GÍs¹°óc¥îN¸AÓï««oÍ¿MóoS¿C½0hí«k±Tá6õ;ô¨Şã„•yÊbåå	Êéã¤ô“kÕ)›5ılåZåeš~í8yo'ï[¤=Z®ã%f†—yféxy3³t¼¼ç–+{¹V×óŒ—Şã2É¯ìën°îR>5^V7’ÒEyiœğM[èÕ” ¹Ã“Ş/±$­i¿í´)Iß¯Üh/Ï.¾IGÕÖä	R×r”İGøKï7ôÌoè™ßĞ3/š oW.Ó3Ë¬l¿rK™ı–º„ã””eÊ”“•åÊ}™ |y‚<ï.õÿQ~®üEÓ;O”»8Q¢KZ7@gJEõÍÃD}Ë¤~”ú±êÇª?^ıñê§ªŸª~¶úÙêOR/Z&JM=¡kùÊ„·(ïT>P&3dy3³Á%Ìî ì¦¼\S&(·Û/iş]erçrÇí½ÊÊŸà&Í¹Ç–ûY—0üxs÷hïQs¼D»pp|ıñÒF&k{|äxáåËÇË[¾Á“ä*>åe©r’r®²B¹x’”Û²Iò¼M“äy›ÔïÕ•š³Úz[s¾¯Ü;IjüWÍÓk²¾ùœ,ó%i/û:L,<QY¥¬S¦<w²ÄÃÍÊ“å»ôÂÖğ)Â™StE?EzÎ“t.½DÓÏÓô+¦ÈÓÉûÉ}6N‘Û
ç%~1EV%’~iœ0#[Ş¾fdRÊÔŒìgÕË×=¶ÄóÎÎ‹ËeV#ï6÷ÛÂß;¿\.şır©ñOäû?Ö×år‡_kÊI:Ïï7UW²S¥mæM•£Š”£”c5]Şå®K¬˜*mGbÉx±-QŞ0ÿŞùØi:^L“>êÆiÒG	÷u¸UÓïƒï$Ş¨~Ç4iqâ÷Ûÿ™&Wÿlš\İáWš"œ'yšÂo}e¶“Ù!kº1Ÿ%
)Uø•úmqÂAúô`çÃ{ÓednUº´7`Æ2CÎóáÍÒêÅÿÒ[øª-ì/´ÜÎ²ôÂ²…m™ÕÒq*Õ}|ŸIsÒvf
ï)o™)g^'Üç¬ÓÇÌ’D"Ü­ó–­º~.aŞlŞÙRûÕ•+”g(ÏŸ-÷¼By«¦Ü£|T¹]ù7å«z·gKTïŸ-±!ãégÊıÊnñçHŸ,{YoÎÑõæñ'«Ãï'hÊİ»Xıbõµê…}¬+`}7)ánY_Ü§gÛ'Gm°öÍş6W×s¥d:Í“{ö±F(Ì“+JÊõÖóte§Ü9OÊğ•yÛ‹N4æ}÷u'J¿Â!ºşÊU?BJrüÒfûX×œ$u'å¼U9D?­Ø®k±ƒÊï’œ5ìmÔ…çnøEw‡oUèjKÓ?Ñ!«Å
]-êŞŸ5½Ã)òÂívÎ)’2âÉ9æÉ9FÓO<EÎ³X÷.Ö”ZõÎ{†µºw½¦¬×½o+w+?W~¯üUÙÑ/¥áñKÿ&håûåZùê‡«®ó8oÅeéé(ìcM®®S>X%é)é‘d]vU’ä¹Ş:v±ÔÔWJS-Qä­Ö7WÊ©Õú.K)~K—Ûªeöê$ä–kÊ8åe™òådåååÊÁzÔåëµjé=Ä÷Õ½Ù„İ”¬:«åÙÅû4ÿ¥êK½²¾Ş×áüS%Ï3p‚÷Cx‚r²²\9Méë»D8J9GY'úîQîTî–ôòNrNœ°‹ú&Ù6é\wÎ]?SîW^éMÔ÷K2–Ñr—êêI¹nrts
            .map(p => {
            // extglob ASTs should only contain parent ASTs
            /* c8 ignore start */
            if (typeof p === 'string') {
                throw new Error('string type in extglob ast??');
            }
            /* c8 ignore stop */
            // can ignore hasMagic, because extglobs are already always magic
            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
            this.#uflag = this.#uflag || uflag;
            return re;
        })
            .filter(p => !(this.isStart() && this.isEnd()) || !!p)
            .join('|');
    }
    static #parseGlob(glob, hasMagic, noEmpty = false) {
        let escaping = false;
        let re = '';
        let uflag = false;
        for (let i = 0; i < glob.length; i++) {
            const c = glob.charAt(i);
            if (escaping) {
                escaping = false;
                re += (reSpecials.has(c) ? '\\' : '') + c;
                continue;
            }
            if (c === '\\') {
                if (i === glob.length - 1) {
                    re += '\\\\';
                }
                else {
                    escaping = true;
                }
                continue;
            }
            if (c === '[') {
                const [src, needUflag, consumed, magic] = parseClass(glob, i);
                if (consumed) {
                    re += src;
                    uflag = uflag || needUflag;
                    i += consumed - 1;
                    hasMagic = hasMagic || magic;
                    continue;
                }
            }
            if (c === '*') {
                if (noEmpty && glob === '*')
                    re += starNoEmpty;
                else
                    re += star;
                hasMagic = true;
                continue;
            }
            if (c === '?') {
                re += qmark;
                hasMagic = true;
                continue;
            }
            re += regExpEscape(c);
        }
        return [re, unescape(glob), !!hasMagic, uflag];
    }
}
//# sourceMappingURL=ast.js.map