/*********************************************************************
 * These are commonly used parsers for CSS Values they take a string *
 * to parse and return a string after it's been converted, if needed *
 ********************************************************************/
'use strict';

const namedColors = require('./named_colors.json');
const { hslToRgb } = require('./utils/colorSpace');

exports.TYPES = {
  INTEGER: 1,
  NUMBER: 2,
  LENGTH: 3,
  PERCENT: 4,
  URL: 5,
  COLOR: 6,
  STRING: 7,
  ANGLE: 8,
  KEYWORD: 9,
  NULL_OR_EMPTY_STR: 10,
  CALC: 11,
};

// rough regular expressions
var integerRegEx = /^[-+]?[0-9]+$/;
var numberRegEx = /^[-+]?[0-9]*\.?[0-9]+$/;
var lengthRegEx = /^(0|[-+]?[0-9]*\.?[0-9]+(in|cm|em|mm|pt|pc|px|ex|rem|vh|vw|ch))$/;
var percentRegEx = /^[-+]?[0-9]*\.?[0-9]+%$/;
var urlRegEx = /^url\(\s*([^)]*)\s*\)$/;
var stringRegEx = /^("[^"]*"|'[^']*')$/;
var colorRegEx1 = /^#([0-9a-fA-F]{3,4}){1,2}$/;
var colorRegEx2 = /^rgb\(([^)]*)\)$/;
var colorRegEx3 = /^rgba\(([^)]*)\)$/;
var calcRegEx = /^calc\(([^)]*)\)$/;
var colorRegEx4 =
  /^hsla?\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*(,\s*(-?\d+|-?\d*.\d+)\s*)?\)/;
var angleRegEx = /^([-+]?[0-9]*\.?[0-9]+)(deg|grad|rad)$/;

// This will return one of the above types based on the passed in string
exports.valueType = function valueType(val) {
  if (val === '' || val === null) {
    return exports.TYPES.NULL_OR_EMPTY_STR;
  }
  if (typeof val === 'number') {
    val = val.toString();
  }

  if (typeof val !== 'string') {
    return undefined;
  }

  if (integerRegEx.test(val)) {
    return exports.TYPES.INTEGER;
  }
  if (numberRegEx.test(val)) {
    return exports.TYPES.NUMBER;
  }
  if (lengthRegEx.test(val)) {
    return exports.TYPES.LENGTH;
  }
  if (percentRegEx.test(val)) {
    return exports.TYPES.PERCENT;
  }
  if (urlRegEx.test(val)) {
    return exports.TYPES.URL;
  }
  if (calcRegEx.test(val)) {
    return exports.TYPES.CALC;
  }
  if (stringRegEx.test(val)) {
    return exports.TYPES.STRING;
  }
  if (angleRegEx.test(val)) {
    return exports.TYPES.ANGLE;
  }
  if (colorRegEx1.test(val)) {
    return exports.TYPES.COLOR;
  }

  var res = colorRegEx2.exec(val);
  var parts;
  if (res !== null) {
    parts = res[1].split(/\s*,\s*/);
    if (parts.length !== 3) {
      return undefined;
    }
    if (
      parts.every(percentRegEx.test.bind(percentRegEx)) ||
      parts.every(integerRegEx.test.bind(integerRegEx))
    ) {
      return exports.TYPES.COLOR;
    }
    return undefined;
  }
  res = colorRegEx3.exec(val);
  if (res !== null) {
    parts = res[1].split(/\s*,\s*/);
    if (parts.length !== 4) {
      return undefined;
    }
    if (
      parts.slice(0, 3).every(percentRegEx.test.bind(percentRegEx)) ||
      parts.slice(0, 3).every(integerRegEx.test.bind(integerRegEx))
    ) {
      if (numberRegEx.test(parts[3])) {
        return exports.TYPES.COLOR;
      }
    }
    return undefined;
  }

  if (colorRegEx4.test(val)) {
    return exports.TYPES.COLOR;
  }

  // could still be a color, one of the standard keyword colors
  val = val.toLowerCase();

  if (namedColors.includes(val)) {
    return exports.TYPES.COLOR;
  }

  switch (val) {
    // the following are deprecated in CSS3
    case 'activeborder':
    case 'activecaption':
    case 'appworkspace':
    case 'background':
    case 'buttonface':
    case 'buttonhighlight':
    case 'buttonshadow':
    case 'buttontext':
    case 'captiontext':
    case 'graytext':
    case 'highlight':
    case 'highlighttext':
    case 'inactiveborder':
    case 'inactivecaption':
    case 'inactivecaptiontext':
    case 'infobackground':
    case 'infotext':
    case 'menu':
    case 'menutext':
    case 'scrollbar':
    case 'threeddarkshadow':
    case 'threedface':
    case 'threedhighlight':
    case 'threedlightshadow':
    case 'threedshadow':
    case 'window':
    case 'windowframe':
    case 'windowtext':
      return exports.TYPES.COLOR;
    default:
      return exports.TYPES.KEYWORD;
  }
};

exports.parseInteger = function parseInteger(val) {
  var type = exports.valueType(val);
  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
    return val;
  }
  if (type !== exports.TYPES.INTEGER) {
    return undefined;
  }
  return String(parseInt(val, 10));
};

exports.parseNumber = function parseNumber(val) {
  var type = exports.valueType(val);
  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
    return val;
  }
  if (type !== exports.TYPES.NUMBER && type !== exports.TYPES.INTEGER) {
    return undefined;
  }
  return String(parseFloat(val));
};

exports.parseLength = function parseLength(val) {
  if (val === 0 || val === '0') {
    return '0px';
  }
  var type = exports.valueType(val);
  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
    return val;
  }
  if (type !== exports.TYPES.LENGTH) {
    return undefined;
  }
  return val;
};

exports.parsePercent = function parsePercent(val) {
  if (val === 0 || val === '0') {
    return '0%';
  }
  var type = exports.valueType(val);
  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
    return val;
  }
  if (type !== exports.TYPES.PERCENT) {
    return undefined;
  }
  return val;
};

// either a length or a percent
exports.parseMeasurement = function parseMeasurement(val) {
  var type = exports.valueType(val);
  if (type === exports.TYPES.CALC) {
    return val;
  }

  var length = exports.parseLength(val);
  if (length !== undefined) {
    return length;
  }
  return exports.parsePercent(val);
};

exports.parseUrl = function parseUrl(val) {
  var type = exports.valueType(val);
  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
    return val;
  }
  var res = urlRegEx.exec(val);
  // does it match the regex?
  if (!res) {
    return undefined;
  }
  var str = res[1];
  // if it starts with single or double quotes, does it end with the same?
  if ((str[0] === '"' || str[0] === "'") && str[0] !== str[str.length - 1]) {
    return undefined;
  }
  if (str[0] === '"' || str[0] === "'") {
    str = str.substr(1, str.length - 2);
  }

  var i;
  for (i = 0; i < str.length; i++) {
    switch (str[i]) {
      case '(':
      case ')':
      case ' ':
      case '\t':
      case '\n':
      case "'":
      case '"':
        return undefined;
      case '\\':
        i++;
        break;
    }
  }

  return 'url(' + str + ')';
};

exports.parseString = function parseString(val) {
  var type = exports.valueType(val);
  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
    return val;
  }
  if (type !== exports.TYPES.STRING) {
    return undefined;
  }
  var i;
  for (i = 1; i < val.length - 1; i++) {
    switch (val[i]) {
      case val[0]:
        return undefined;
      case '\\':
        i++;
        while (i < val.length - 1 && /[0-9A-Fa-f]/.test(val[i])) {
          i++;
        }
        break;
    }
  }
  if (i >= val.length) {
    return undefined;
  }
  return val;
};

exports.parseColor = function parseColor(val) {
  var type = exports.valueType(val);
  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
    return val;
  }
  var red,
    green,
    blue,
    hue,
    saturation,
    lightness,
    alpha = 1;
  var parts;
  var res = colorRegEx1.exec(val);
  // is it #aaa, #ababab, #aaaa, #abababaa
  if (res) {
    var defaultHex = val.substr(1);
    var hex = val.substr(1);
    if (hex.length === 3 || hex.length === 4) {
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];

      if (defaultHex.length === 4) {
        hex = hex + defaultHex[3] + defaultHex[3];
      }
    }
    red = parseInt(hex.substr(0, 2), 16);
    green = parseInt(hex.substr(2, 2), 16);
    blue = parseInt(hex.substr(4, 2), 16);
    if (hex.length === 8) {
      var hexAlpha = hex.substr(6, 2);
      var hexAlphaToRgbaAlpha = Number((parseInt(hexAlpha, 16) / 255).toFixed(3));

      return 'rgba(' + red + ', ' + green + ', ' + blue + ', ' + hexAlphaToRgbaAlpha + ')';
    }
    return 'rgb(' + red + ', ' + green + ', ' + blue + ')';
  }

  res = colorRegEx2.exec(val);
  if (res) {
    parts = res[1].split(/\s*,\s*/);
    if (parts.length !== 3) {
      return undefined;
    }
    if (parts.every(percentRegEx.test.bind(percentRegEx))) {
      red = Math.floor((parseFloat(parts[0].slice(0, -1)) * 255) / 100);
      green = Math.floor((parseFloat(parts[1].slice(0, -1)) * 255) / 100);
      blue = Math.floor((parseFloat(parts[2].slice(0, -1)) * 255) / 100);
    } else if (parts.every(integerRegEx.test.bind(integerRegEx))) {
      red = parseInt(parts[0], 10);
      green = parseInt(parts[1], 10);
      blue = parseInt(parts[2], 10);
    } else {
      return undefined;
    }
    red = Math.min(255, Math.max(0, red));
    green = Math.min(255, Math.max(0, green));
    blue = Math.min(255, Math.max(0, blue));
    return 'rgb(' + red + ', ' + green + ', ' + blue + ')';
  }

  res = colorRegEx3.exec(val);
  if (res) {
    parts = res[1].split(/\s*,\s*/);
    if (parts.length !== 4) {
      return undefined;
    }
    if (parts.slice(0, 3).every(percentRegEx.test.bind(percentRegEx))) {
      red = Math.floor((parseFloat(parts[0].slice(0, -1)) * 255) / 100);
      green = Math.floor((parseFloat(parts[1].slice(0, -1)) * 255) / 100);
      blue = Math.floor((parseFloat(parts[2].slice(0, -1)) * 255) / 100);
      alpha = parseFloat(parts[3]);
    } else if (parts.slice(0, 3).every(integerRegEx.test.bind(integerRegEx))) {
      red = parseInt(parts[0], 10);
      green = parseInt(parts[1], 10);
      blue = parseInt(parts[2], 10);
      alpha = parseFloat(parts[3]);
    } else {
      return undefined;
    }
    if (isNaN(alpha)) {
      alpha = 1;
    }
    red = Math.min(255, Math.max(0, red));
    green = Math.min(255, Math.max(0, green));
    blue = Math.min(255, Math.max(0, blue));
    alpha = Math.min(1, Math.max(0, alpha));
    if (alpha === 1) {
      return 'rgb(' + red + ', ' + green + ', ' + blue + ')';
    }
    return 'rgba(' + red + ', ' + green + ', ' + blue + ', ' + alpha + ')';
  }

  res = colorRegEx4.exec(val);
  if (res) {
    const [, _hue, _saturation, _lightness, _alphaString = ''] = res;
    const _alpha = parseFloat(_alphaString.replace(',', '').trim());
    if (!_hue || !_saturation || !_lightness) {
      return undefined;
    }
    hue = parseFloat(_hue);
    saturation = parseInt(_saturation, 10);
    lightness = parseInt(_lightness, 10);
    if (_alpha && numberRegEx.test(_alpha)) {
      alpha = parseFloat(_alpha);
    }

    const [r, g, b] = hslToRgb(hue, saturation / 100, lightness / 100);
    if (!_alphaString || alpha === 1) {
      return 'rgb(' + r + ', ' + g + ', ' + b + ')';
    }
    return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + alpha + ')';
  }

  if (type === exports.TYPES.COLOR) {
    return val;
  }
  return undefined;
};

exports.parseAngle = function parseAngle(val) {
  var type = exports.valueType(val);
  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
    return val;
  }
  if (type !== exports.TYPES.ANGLE) {
    return undefined;
  }
  var res = angleRegEx.exec(val);
  var flt = parseFloat(res[1]);
  if (res[2] === 'rad') {
    flt *= 180 / Math.PI;
  } else if (res[2] === 'grad') {
    flt *= 360 / 400;
  }

  while (flt < 0) {
    flt += 360;
  }
  while (flt > 360) {
    flt -= 360;
  }
  return flt + 'deg';
};

exports.parseKeyword = function parseKeyword(val, valid_keywords) {
  var type = exports.valueType(val);
  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
    return val;
  }
  if (type !== exports.TYPES.KEYWORD) {
    return undefined;
  }
  val = val.toString().toLowerCase();
  var i;
  for (i = 0; i < valid_keywords.length; i++) {
    if (valid_keywords[i].toLowerCase() === val) {
      return valid_keywords[i];
    }
  }
  return undefined;
};

// utility to translate from border-width to borderWidth
var dashedToCamelCase = function (dashed) {
  var i;
  var camel = '';
  var nextCap = false;
  for (i = 0; i < dashed.length; i++) {
    if (dashed[i] !== '-') {
      camel += nextCap ? dashed[i].toUpperCase() : dashed[i];
      nextCap = false;
    } else {
      nextCap = true;
    }
  }
  return camel;
};
exports.dashedToCamelCase = dashedToCamelCase;

var is_space = /\s/;
var opening_deliminators = ['"', "'", '('];
var closing_deliminators = ['"', "'", ')'];
// this splits on whitespace, but keeps quoted and parened parts together
var getParts = function (str) {
  var deliminator_stack = [];
  var length = str.length;
  var i;
  var parts = [];
  var current_part = '';
  var opening_index;
  var closing_index;
  for (i = 0; i < length; i++) {
    opening_index = opening_deliminators.indexOf(str[i]);
    closing_index = closing_deliminators.indexOf(str[i]);
    if (is_space.test(str[i])) {
      if (deliminator_stack.length === 0) {
        if (current_part !== '') {
          parts.push(current_part);
        }
        current_part = '';
      } else {
        current_part += str[i];
      }
    } else {
      if (str[i] === '\\') {
        i++;
        current_part += str[i];
      } else {
        current_part += str[i];
        if (
          closing_index !== -1 &&
          closing_index === deliminator_stack[deliminator_stack.length - 1]
        ) {
          deliminator_stack.pop();
        } else if (opening_index !== -1) {
          deliminator_stack.push(opening_index);
        }
      }
    }
  }
  if (current_part !== '') {
    parts.push(current_part);
  }
  return parts;
};

/*
 * this either returns undefined meaning that it isn't valid
 * or returns an object where the keys are dashed short
 * hand properties and the values are the values to set
 * on them
 */
exports.shorthandParser = function parse(v, shorthand_for) {
  var obj = {};
  var type = exports.valueType(v);
  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {
    Object.keys(shorthand_for).forEach(function (property) {
      obj[property] = '';
    });
    return obj;
  }

  if (typeof v === 'number') {
    v = v.toString();
  }

  if (typeof v !== 'string') {
    return undefined;
  }

  if (v.toLowerCase() === 'inherit') {
    return {};
  }
  var parts = getParts(v);
  var valid = true;
  parts.forEach(function (part, i) {
    var part_valid = false;
    Object.keys(shorthand_for).forEach(function (property) {
      if (shorthand_for[property].isValid(part, i)) {
        part_valid = true;
        obj[property] = part;
      }
    });
    valid = valid && part_valid;
  });
  if (!valid) {
    return undefined;
  }
  return obj;
};

exports.shorthandSetter = function (property, shorthand_for) {
  return function (v) {
    var obj = exports.shorthandParser(v, shorthand_for);
    if (obj === undefined) {
      return;
    }
    //console.log('shorthandSetter for:', property, 'obj:', obj);
    Object.keys(obj).forEach(function (subprop) {
      // in case subprop is an implicit property, this will clear
      // *its* subpropertiesX
      var camel = dashedToCamelCase(subprop);
      this[camel] = obj[subprop];
      // in case it gets translated into something else (0 -> 0px)
      obj[subprop] = this[camel];
      this.removeProperty(subprop);
      // don't add in empty properties
      if (obj[subprop] !== '') {
        this._values[subprop] = obj[subprop];
      }
    }, this);
    Object.keys(shorthand_for).forEach(function (subprop) {
      if (!obj.hasOwnProperty(subprop)) {
        this.removeProperty(subprop);
        delete this._values[subprop];
      }
    }, this);
    // in case the value is something like 'none' that removes all values,
    // check that the generated one is not empty, first remove the property
    // if it already exists, then call the shorthandGetter, if it's an empty
    // string, don't set the property
    this.removeProperty(property);
    var calculated = exports.shorthandGetter(property, shorthand_for).call(this);
    if (calculated !== '') {
      this._setProperty(property, calculated);
    }
  };
};

exports.shorthandGetter = function (property, shorthand_for) {
  return function () {
    if (this._values[property] !== undefined) {
      return this.getPropertyValue(property);
    }
    return Object.keys(shorthand_for)
      .map(function (subprop) {
        return this.getPropertyValue(subprop);
      }, this)
      .filter(function (value) {
        return value !== '';
      })
      .join(' ');
  };
};

// isValid(){1,4} | inherit
// if one, it applies to all
// if two, the first applies to the toMQj ÿuÿuPèqûÿÿÿpÿ0èJ ƒÉÿƒÄ…ÀHÁ]ÃU‹ìEP3ÀPÿuPPèFûÿÿ‹ÿpƒÉQèÓ ƒÉÿƒÄ…ÀHÁ]Ãj,¸0ãD è$w ‹ñ‹M3ÀƒeÜ ÇEà   f‰EÌ!Eü}ä«QÿuMÌ««EäPèWÁ  EÌÆEüP‹Îè)I  ƒìEä‹ÌPèO  ‹Îè   Mäèæ	  MÌè•÷ÿÿèfv Â jl¸¸ãD è­v ‹ñ3Û‰]ü‹Eˆ]·éb  ‹Eèƒ8…  xºh	F ‹Ïè]  „Àt	ÆFé?  ºp	F ‹ÏèD  „Àt‹EUì‰EìFPQMèèæ	  YYé  º„	F ‹Ïè  „Àt"‹EUì‰EìF4PF(PQMèè\
  ƒÄéà   º˜	F ‹Ïèå  „Àt	ÆF@éÇ   º°	F ‹ÏèÌ  „Àt.‹EUè‰EìEìQPMĞè7  YYPNDè^G  MĞè–öÿÿé‰   ºÀ	F ‹Ïè  „ÀtÆF\ësºĞ	F ‹Ïèx  „Àt	ÆFxéO  ºÜ	F ‹Ïè_  „ÀtÆF]ëDºì	F ‹ÏèI  „Àt ‹EUè‰EìEìQPMĞè´
  YYN`ép  ºø	F ‹Ïè  „ÀtÆFyÆE·éì  º
F ‹Ïèü  „ÀtO‹EUè‰EìEìQPMĞèg
  YYEĞÆEüPEì‰]ìPèë  ‹Eì;äÁF „%  EĞPN|èG  ˆ]üéú   º 
F ‹Ïè  „Àt0ƒ¾À    …§  ‹EUè‰EìEìQPMĞèû	  YY”   é´   º@
F ‹Ïè]  „Àti3À}Ä«««‰]Ä‰]È‰]ÌÆEüUì‹E‰EìEÄPQMèèê  ‹}Ä‹]ÈYYëºP
F ‹Ïè  „À„P  Æ†¬   ƒÇ;ûuŞ3ÛMÄˆ]üèªòÿÿéÔ   º4
F ‹Ïèä  „Àt>ƒ¾¤    …1  ‹EUè‰EìEìQPMĞèB	  YY°   PèfE  MĞèôÿÿé†   ºd
F ‹Ïè–  „Àt	Æ†È   ëmºt
F ‹Ïè}  „Àt	Æ†É   ëTº„
F ‹Ïèd  „Àt	Æ†Ê   ë;º
F ‹ÏèK  „Àu$º”
F ‹Ïè;  „Àuº˜
F ‹Ïè+  „À„œ   Æ†Ë   ‹EèƒÀ‰Eè;E…’üÿÿ3À‰]Èh¤
F M¸ÇEÌ   f‰E¸èwøÿÿ‹^éŸ   h4
F h 
F EĞjmPè¨ßÿÿÆEüQQ‹ÌEĞéH  h@
F ‹ÏèãÿÿPEĞjpPè€ßÿÿÆEüëÖh 
F h4
F EĞjmPèeßÿÿÆEüë»‹ÏèÑâÿÿPEĞjgPèLßÿÿÆEüƒìë¡jfZMĞè]»  ÆEüƒìëU¸‹Ëèî4  „ÀuƒÃ;^ uêM¸è0óÿÿ‹~ ;ßt!‹ßÆF‹~;ût‹ÏèóÿÿƒÇ;ûuò‹~‰~ €~] t9~u‹F(;F,tjlZMĞèğº  ÆEü	ë‘ƒ¾¤    u	ƒ¾À    tN|ƒy u
h¨
F èR÷ÿÿ€}· tƒ~p tjoZMĞè®º  ÆEü
éLÿÿÿMèà  èhq Â MĞèááÿÿPE¸jhPè\ŞÿÿƒìÆEü‹ÌE¸Pè:îÿÿjWMˆèVC  h€}F EˆPèÛ ÌjT¸*äD èpq ƒeì q`ƒ~‹Î‹}r‹ÿuì‹V3ÛCSQQè{  ƒÄ@ƒøÿtjÿPE ‹ÎPèvB  ƒeü ëƒeÈ M¸ƒeÌ VèYíÿÿj‰]üE¸[ƒeä MÔƒeè P‰]ìè<íÿÿÇEü   öÃtM¸ƒãıè½ñÿÿÆEüöÃtM è¬ñÿÿƒ}èEÔCEÔPE¸hÍ   PèsİÿÿƒÄ‹ĞÆEü‹ÏèôÿÿM¸ÆEüèvñÿÿ‹5äÁF ‹‰EìëC‹HPƒÀ‰MĞƒxr‹ PQE¸Pè.İÿÿƒÄ‹ĞÆEü‹ÏèĞóÿÿM¸ÆEüè1ñÿÿMìè3  ‹Eì;Æu¹MÔèñÿÿèëo Â U‹ìjÿhOäD d¡    Pƒì0¡pF 3Å‰EğSVWPEôd£    ‹ú‹Ùƒeè 3Àf‰EØ‹GÇEì   fnÀóæÀÁèòXÅğF òYèF è’• PMØèœ@  ƒ‹÷r‹7ƒ‹Ïr‹‹GA;ğt?·‹Èƒù*t#ƒù.tMØƒø?tPè†?  ëhÄ
F ëh´
F ëh¼
F MØèë  ƒÆë­h  EØPMÄèg  P‹Ëè›  ƒeü MÄèáîÿÿMĞè2îÿÿMØèğÿÿ‹Ã‹Môd‰    Y_^[‹Mğ3Íè!e ÉÃƒyr‹	jÿRjÿQjjÿ8 E ƒø”ÀÃU‹ìQQ‹ES‹]V‰Eü¡äÁF W‹ø‰]ø‹w€~ uB‹]üSFPè…=  „Àt‹vë‹ş‹6€~ tã¡äÁF ‹]ø;øtGP‹EüPèY=  „Àt¡äÁF ‹ø‰;‹Ã_^[ÉÂ é©  ÌÌÌj ¸ˆäD èën ‹Ù‹M3ÿ‰;‰{‰{‹A+j‰MÜ™Y÷ù‰]Ô…Àtx=I’$	w{kğVè@êÿÿ‰‰C‹‰}üÆ‰C}à‹33À«Y‹MÜ«‹Q‹	«‰UØ‰MÜ‰uà‰uä‰]èÆEü;Êt,‹‰ANƒa ƒa Pè4êÿÿ‹MÜƒÆ‹UØƒÁ‰uä‰MÜëĞ‰s‹Ãè•m Â èãØÿÿ‹MÔèç   j j è~ ÌU‹ìjÿhôáD d¡    PVW¡pF 3ÅPEôd£    ‹ñƒ& Nè(   ‹};÷t‹Îèíÿÿ‹‰ƒ' ‹Æ‹Môd‰    Y_^ÉÂ j¸»äD è'm ‹ù‰}ğwƒeü jèóü  ‰FVÇEü   è*4  V‰è<;  ‰GƒÄ‹Çè¸l Ã‹‹P€z t‹Pë;Bu%‰‹Â‹R€z tîëV‹2€~ u‹‹Ö‹ğ€x tô^‰‹ÁÃU‹ìQVW‹ù‰}ü‹7…öt@S‹_;ótj_Nè“íÿÿ÷;óuò‹}ü‹7‹G+ÆjY™÷ùkÀPVè)íÿÿ3ÀY‰Y‰G‰G[_^ÉÃU‹ì‹UVrf‹ƒÂf…Àuõ+ÖÑúRÿuè‡0  ^]Â jd¸ğäD è[l ‹Ú‹ù‹EMØ‰E¼3ö‹ƒÀ‰uèP‰uìèwèÿÿ‰uü‹7ƒÆ;3t0ƒ>u+ƒ>tƒƒÆ‹‹M¼ƒÀPè5  ;3uãMØèÙìÿÿèªk ÃMØè%ÜÿÿPEÀjePè ØÿÿƒìÆEüEÀ‹ÌPè~èÿÿjWMèš=  h€}F EPè| Ìjl¸0åD è´k ‰U´‹Á‰EÀ‹0‹M‹}‰M¼N‰}¸ƒÆ;2„¶   ƒ>…­   ƒ>„   ƒ ƒÆ‹QƒÃj*‹Ëèb.  ƒøÿuQj?‹ËèS.  ƒøÿu
S‹Ïèq  ë]3À}Ü«MÜ‹Ó««««èùúÿÿ‹]¼MÜÇEü   Q‹C9Ct‹ÈèZıÿÿƒCëP‹Ëèº  MÜÇEü   èêÿÿMèèàéÿÿƒMüÿ‹}¸‹E´;0‹EÀ…Yÿÿÿè…j ÃèÛÿÿPEÄjePè~×ÿÿƒeü EÄƒì‹ÌPè\çÿÿjWMˆèx<  h€}F EˆPèız Ìjd¸ğäD è’j ‹ò‹ù‰}¼‹MØƒÀ‰}¼3ÛP‰]è‰]ìè®æÿÿ‹E‰]ü‹ƒÁ‰;t&ƒ9u!ƒÁ‰_Q‹Ï‰_è‡æÿÿMØèëÿÿ‹Çèæi ÃMØèaÚÿÿPEÀjePèÜÖÿÿƒìÆEüEÀ‹ÌPèºæÿÿjWMèÖ;  h€}F EPè[z Ìj`¸såD èği ‹ñ‰u˜‰u”Nƒ& èvüÿÿ‹}‹ßƒeü ƒr‹‹G‰E˜r‹?jTEœj PèŒ… ‹E˜MœƒÄCÿuPWFPè  MœÆEüèF  ‹ø…ÿtğÿG ‹ÎèéÿÿM°‰>èÏ  ‹Æèi Â Ìj ¸¨åD èËi ‹M»ÌÁF ‹E‰EØ+Áj‰MÜY™÷ù‹Ë‰]ÔPèë+  „ÀtK3Û}à‰]ü3À‹5ÌÁF «««‰uà‰uäÇEèÌÁF ‹}ÜÆEü;}Ø