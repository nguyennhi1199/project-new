interface ResolveOptions {
    /**
     * A URL, path or array of URLs/paths to resolve against.
     */
    url?: string | URL | (string | URL)[];
    /**
     * File extensions to consider when resolving modules.
     */
    extensions?: string[];
    /**
     * Conditions to consider when resolving package exports.
     */
    conditions?: string[];
}
/**
 * Synchronously resolves a module path based on the options provided.
 *
 * @param {string} id - The identifier or path of the module to resolve.
 * @param {ResolveOptions} [options] - Options to resolve the module. See {@link ResolveOptions}.
 * @returns {string} The resolved URL as a string.
 */
declare function resolveSync(id: string, options?: ResolveOptions): string;
/**
 * Asynchronously resolves a module path based on the given options.
 *
 * @param {string} id - The identifier or path of the module to resolve.
 * @param {ResolveOptions} [options] - Options for resolving the module. See {@link ResolveOptions}.
 * @returns {Promise<string>} A promise to resolve the URL as a string.
 */
declare function resolve(id: string, options?: ResolveOptions): Promise<string>;
/**
 * Synchronously resolves a module path to a local file path based on the given options.
 *
 * @param {string} id - The identifier or path of the module to resolve.
 * @param {ResolveOptions} [options] - Options to resolve the module. See {@link ResolveOptions}.
 * @returns {string} The resolved file path.
 */
declare function resolvePathSync(id: string, options?: ResolveOptions): string;
/**
 * Asynchronously resolves a module path to a local file path based on the options provided.
 *
 * @param {string} id - The identifier or path of the module to resolve.
 * @param {ResolveOptions} [options] - Options for resolving the module. See {@link ResolveOptions}.
 * @returns {Promise<string>} A promise to resolve to the file path.
 */
declare function resolvePath(id: string, options?: ResolveOptions): Promise<string>;
/**
 * Creates a resolver function with default options that can be used to resolve module identifiers.
 *
 * @param {ResolveOptions} [defaults] - Default options to use for all resolutions. See {@link ResolveOptions}.
 * @returns {Function} A resolver function that takes an identifier and an optional URL, and resolves the identifier using the default options and the given URL.
 */
declare function createResolve(defaults?: ResolveOptions): (id: string, url?: ResolveOptions["url"]) => Promise<string>;
/**
 * Parses a node module path to extract the directory, name, and subpath.
 *
 * @param {string} path - The path to parse.
 * @returns {Object} An object containing the directory, module name, and subpath of the node module.
 */
declare function parseNodeModulePath(path: string): {
    dir?: undefined;
    name?: undefined;
    subpath?: undefined;
} | {
    dir: string;
    name: string;
    subpath: string | undefined;
};
/**
 * Attempts to reverse engineer a subpath export within a node module.
 *
 * @param {string} path - The path within the node module.
 * @returns {Promise<string | undefined>} A promise that resolves to the detected subpath or undefined if not found.
 */
declare function lookupNodeModuleSubpath(path: string): Promise<string | undefined>;

/**
 * Represents a general structure for ECMAScript module imports.
 */
interface ESMImport {
    /**
     * Specifies the type of import: "static" for static imports and "dynamic" for dynamic imports.
     */
    type: "static" | "dynamic";
    /**
     * The full import declaration code snippet as a string.
     */
    code: string;
    /**
     * The starting position (index) of the import declaration in the source code.
     */
    start: number;
    /**
     * The end position (index) of the import declaration in the source code.
     */
    end: number;
}
/**
 * Represents a static import declaration in an ECMAScript module.
 * Extends {@link ESMImport}.
 */
interface StaticImport extends ESMImport {
    /**
     * Indicates the type of import, specifically a static import.
     */
    type: "static";
    /**
     * Contains the entire import statement as a string, excluding the module specifier.
     */
    imports: string;
    /**
     * The module specifier from which imports are being brought in.
     */
    specifier: string;
}
/**
 * Represents a parsed static import declaration with detailed components of the import.
 * Extends {@link StaticImport}.
 */
interface ParsedStaticImport extends StaticImport {
    /**
     * The default import name, if any.
     * @optional
     */
    defaultImport?: string;
    /**
     * The namespace import name, if any, using the `* as` syntax.
     * @optional
     */
    namespacedImport?: string;
    /**
     * An object representing named imports, with their local aliases if specified.
     * Each property key is the original name and its value is the alias.
     * @optional
     */
    namedImports?: {
        [name: string]: string;
    };
}
/**
 * Represents a dynamic import declaration that is loaded at runtime.
 * Extends {@link ESMImport}.
 */
interface DynamicImport extends ESMImport {
    /**
     * Indicates that this is a dynamic import.
     */
    type: "dynamic";
    /**
     * The expression or path to be dynamically imported, typically a module path or URL.
     */
    expression: string;
}
/**
 * Represents a type-specific import, primarily used for importing types in TypeScript.
 * Extends {@link ESMImport} but omits the 'type' to redefine it specifically for type imports.
 */
interface TypeImport extends Omit<ESMImport, "type"> {
    /**
     * Specifies that this is a type import.
     */
    type: "type";
    /**
     * Contains the entire type import statement as a string, excluding the module specifier.
     */
    imports: string;
    /**
     * The module specifier from which to import types.
     */
    specifier: string;
}
/**
 * Represents a general structure for ECMAScript module exports.
 */
interface ESMExport {
    /**
     * Optional explicit type for complex scenarios, often used internally.
     * @optional
     */
    _type?: "declaration" | "named" | "default" | "star";
    /**
     * The type of export (declaration, named, default or star).
     */
    type: "declaration" | "named" | "default" | "star";
    /**
     * The specific type of declaration being exported, if applicable.
     * @optional
     */
    declarationType?: "let" | "var" | "const" | "enum" | "const enum" | "class" | "function" | "async function";
    /**
     * The full code snippet of the export statement.
     */
    code: string;
    /**
     * The starting position (index) of the export declaration in the source code.
     */
    start: number;
    /**
     * The end position (index) of the export declaration in the source code.
     */
    end: number;
    /**
     * The name of the variable, function or class being exported, if given explicitly.
     * @optional
     */
    name?: string;
    /**
     * The name used for default exports when a specific identifier isn't given.
     * @optional
     */
    defaultName?: string;
    /**
     * An array of names to export, applicable to named and destructured exports.
     */
    names: string[];
    /**
     * The module specifier, if any, from which exports are being re-exported.
     * @optional
     */
    specifier?: string;
}
/**
 * Represents a declaration export within an ECMAScript module.
 * Extends {@link ESMExport}.
 */
interface DeclarationExport extends ESMExport {
    /**
     * Indicates that this export is a declaration export.
     */
    type: "declaration";
    /**
     * The declaration string, such as 'let', 'const', 'class', etc., describing what is being exported.
     */
    declaration: string;
    /**
     * The name of the declaration to be exported.
     */
    name: string;
}
/**
 * Represents a named export within an ECMAScript module.
 * Extends {@link ESMExport}.
 */
interface NamedExport extends ESMExport {
    /**
     * Specifies that this export is a named export.
     */
    type: "named";
    /**
     * The export string, containing all exported identifiers.
     */
    exports: string;
    /**
     * An array of names to export.
     */
    names: string[];
    /**
     * The module specifier, if any, from which exports are being re-exported.
     * @optional
     */
    specifier?: string;
}
/**
 * Represents a standard export within an ECMAScript module.
 * Extends {@link ESMExport}.
 */
interface DefaultExport extends ESMExport {
    /**
     * Specifies that this export is a standard export.
     */
    type: "default";
}
/**
 * Regular expression to match static import statements in JavaScript/TypeScript code.
 * @example `import { foo, bar as baz } from 'module'`
 */
declare const ESM_STATIC_IMPORT_RE: RegExp;
/**
 * Regular expression to match dynamic import statements in JavaScript/TypeScript code.
 * @example `import('module')`
 */
declare const DYNAMIC_IMPORT_RE: RegExp;
/**
 * Regular expression to match various types of export declarations including variables, functions, and classes.
 * @example `export const num = 1, str = 'hello'; export class Example {}`
 */
declare const EXPORT_DECAL_RE: RegExp;
/**
 * Regular expression to match export declarations specifically for types, interfaces, and type aliases in TypeScript.
 * @example `export type Result = { success: boolean; }; export interface User { name: string; age: number; };`
 */
declare const EXPORT_DECAL_TYPE_RE: RegExp;
/**
 * Finds all static import statements within the given code string.
 * @param {string} code - The source code to search for static imports.
 * @returns {StaticImport[]} An array of {@link StaticImport} objects representing each static import found.
 */
declare function findStaticImports(code: string): StaticImport[];
/**
 * Searches for dynamic import statements in the given source code.
 * @param {string} code - The source to search for dynamic imports in.
 * @returns {DynamicImport[]} An array of {@link DynamicImport} objects representing each dynamic import found.
 */
declare function findDynamicImports(code: string): DynamicImport[];
/**
 * Identifies and returns all type import statements in the given source code.
 * This function is specifically targeted at type imports used in TypeScript.
 * @param {string} code - The source code to search for type imports.
 * @returns {TypeImport[]} An array of {@link TypeImport} objects representing each type import found.
 */
declare function findTypeImports(code: string): TypeImport[];
/**
 * Parses a static import or type import to extract detailed import elements such as default, namespace and named imports.
 * @param {StaticImport | TypeImport} matched - The matched import statement to parse. See {@link StaticImport} and {@link TypeImport}.
 * @returns {ParsedStaticImport} A structured object representing the parsed static import. See {@link ParsedStaticImport}.
 */
declare function parseStaticImport(matched: StaticImport | TypeImport): ParsedStaticImport;
/**
 * Parses a static import or type import to extract detailed import elements such as default, namespace and named imports.
 * @param {StaticImport | TypeImport} matched - The matched import statement to parse. See {@link StaticImport} and {@link TypeImport}.
 * @returns {ParsedStaticImport} A structured object representing the parsed static import. See {@link ParsedStaticImport}.
 */
declare function parseTypeImport(matched: TypeImport | StaticImport): ParsedStaticImport;
/**
 * Identifies all export statements in the supplied source code and categorises them into different types such as declarations, named, default and star exports.
 * This function processes the code to capture different forms of export statements and normalise their representation for further processing.
 *
 * @param {string} code - The source code containing the export statements to be analysed.
 * @returns {ESMExport[]} An array of {@link ESMExport} objects representing each export found, properly categorised and structured.
 */
declare function findExports(code: string): ESMExport[];
/**
 * Searches specifically for type-related exports in TypeScript code, such as exported interfaces, types, and declarations prefixed with 'declare'.
 * This function uses specialised regular expressions to identify type exports and normalises them for consistency.
 *
 * @param {string} code - The TypeScript source code to search for type exports.
 * @returns {ESMExport[]} An array of {@link ESMExport} objects representing each type export found.
 */
declare function findTypeExports(code: string): ESMExport[];
/**
 * Extracts and returns a list of all export names from the given source.
 * This function uses {@link findExports} to retrieve all types of exports and consolidates their names into a single array.
 *
 * @param {string} code - The source code to search for export names.
 * @returns {string[]} An array containing the names of all exports found in the code.
 */
declare function findExportNames(code: string): string[];
/**
 * Asynchronously resolves and returns all export names from a module specified by its module identifier.
 * This function recursively resolves all explicitly named and asterisked (* as) exports to fully enumerate the exported identifiers.
 *
 * @param {string} id - The module identifier to resolve.
 * @param {ResolveOptions} [options] - Optional settings for resolving the module path, such as the base URL.
 * @returns {Promise<string[]>} A promise that resolves to an array of export names from the module.
 */
declare function resolveModuleExportNames(id: string, options?: ResolveOptions): Promise<string[]>;

/**
 * Represents the context of a CommonJS environment, providing node-like module resolution capabilities within a module.
 */
interface CommonjsContext {
    /**
     * The absolute path to the current module file.
     */
    __filename: string;
    /**
     * The directory name of the current module.
     */
    __dirname: string;
    /**
     * A function to require modules as in CommonJS.
     */
    require: NodeRequire;
}
/**
 * Creates a CommonJS context for a given module URL, enabling `require`, `__filename` and `__dirname` support similar to Node.js.
 * This function dynamically generates a `require` function that is context-aware and bound to the location of the given module URL.
 *
 * @param {string} url - The URL of the module file to create a context for.
 * @returns {CommonjsContext} A context object containing `__filename`, `__dirname` and a custom `require` function. See {@link CommonjsContext}.
 */
declare function createCommonJS(url: string): CommonjsContext;
declare function interopDefault(sourceModule: any, opts?: {
    preferNamespace?: boolean;
}): any;

/**
 * Options for evaluating or transforming modules, extending resolution options with optional URL specifications.
 */
interface EvaluateOptions extends ResolveOptions {
    /**
     * The URL of the module, which can be specified to override the URL resolved from the module identifier.
     * @optional
     */
    url?: string;
}
/**
 * Loads a module by resolving its identifier to a URL, fetching the module's code and evaluating it.
 *
 * @param {string} id - The identifier of the module to load.
 * @param {EvaluateOptions} options - Optional parameters to resolve and load the module. See {@link EvaluateOptions}.
 * @returns {Promise<any>} A promise to resolve to the evaluated module.
 * });
 */
declare function loadModule(id: string, options?: EvaluateOptions): Promise<any>;
/**
 * Evaluates JavaScript code as a module using a dynamic import from a data URL.
 *
 * @param {string} code - The code of the module to evaluate.
 * @param {EvaluateOptions} options - Includes the original URL of the module for better error mapping. See {@link EvaluateOptions}.
 * @returns {Promise<any>} A promise that resolves to the evaluated module or throws an error if the evaluation fails.
 */
declare function evalModule(code: string, options?: EvaluateOptions): Promise<any>;
/**
 * Transform module code to handle specific scenarios, such as converting JSON to a module or rewriting import.meta.url.
 *
 * @param {string} code - The code of the module to transform.
 * @param {EvaluateOptions} options - Options to control how the code is transformed. See {@link EvaluateOptions}.
 * @returns {Promise<string>} A promise that resolves to the transformed code.
 */
declare function transformModule(code: string, options?: EvaluateOptions): Promise<string>;
/**
 * Resolves all import URLs found within the provided code to their absolute URLs, based on the given options.
 *
 * @param {string} code - The code containing the import directives to resolve.
 * @param {EvaluateOptions} [options] - Options to use for resolving imports. See {@link EvaluateOptions}.
 * @returns {Promise<string>} A promise that resolves to the code, replacing import URLs with resolved URLs.
 */
declare function resolveImports(code: string, options?: EvaluateOptions): Promise<string>;

/**
 * Options for detecting syntax within a code string.
 */
type DetectSyntaxOptions = {
    /**
     * Indicates whether comments should be stripped from the code before syntax checking.
     * @default false
     */
    stripComments?: boolean;
};
/**
 * Determines if a given code string contains ECMAScript module syntax.
 *
 * @param {string} code - The source code to analyse.
 * @param {DetectSyntaxOptions} opts - See {@link DetectSyntaxOptions}.
 * @returns {boolean} `true` if the code contains ESM syntax, otherwise `false`.
 */
declare function hasESMSyntax(code: string, opts?: DetectSyntaxOptions): boolean;
/**
 * Determines if a given string of code contains CommonJS syntax.
 *
 * @param {string} code - The source code to analyse.
 * @param {DetectSyntaxOptions} opts - See {@link DetectSyntaxOptions}.
 * @returns {boolean} `true` if the code contains CommonJS syntax, `false` otherwise.
 */
declare function hasCJSSyntax(code: string, opts?: DetectSyntaxOptions): boolean;
/**
 * Analyses the supplied code to determine if it contains ECMAScript module syntax, CommonJS syntax, or both.
 *
 * @param {string} code - The source code to analyse.
 * @param {DetectSyntaxOptions} opts - See {@link DetectSyntaxOptions}.
 * @returns {object} An object indicating the presence of ESM syntax (`hasESM`), CJS syntax (`hasCJS`) and whether both syntaxes are present (`isMixed`).
 */
declare function detectSyntax(code: string, opts?: DetectSyntaxOptions): {
    hasESM: boolean;
    hasCJS: boolean;
    isMixed: boolean;
};
interface ValidNodeImportOptions extends ResolveOptions {
    /**
     * The contents of the import, which may be analyzed to see if it contains
     * CJS or ESM syntax as a last step in checking whether it is a valid import.
     */
    code?: string;
    /**
     * Protocols that are allowed as valid node imports.
     *
     * @default ['node', 'file', 'data']
     *
     */
    allowedProtocols?: Array<string>;
    /**
     * Whether to strip comments from the code before checking for ESM syntax.
     *
     * @default false
     */
    stripComments?: boolean;
}
/**
 * Validates whether a given identifier represents a valid node import, based on its protocol, file extension, and optionally its contents.
 *
 * @param {string} id - The identifier or URL of the import to validate.
 * @param {ValidNodeImportOptions} _options - Options for resolving and validating the import. See {@link ValidNodeImportOptions}.
 * @returns {Promise<boolean>} A promise that resolves to `true` if the import is valid, otherwise `false`.
 */
declare function isValidNodeImport(id: string, _options?: ValidNodeImportOptions): Promise<boolean>;

/**
 * Converts a file URL to a local file system path with normalized slashes.
 *
 * @param {string | URL} id - The file URL or local path to convert.
 * @returns {string} A normalized file system path.
 */
declare function fileURLToPath(id: string | URL): string;
/**
 * Converts a local file system path to a file URL.
 *
 * @param {string | URL} id - The file system path to convert.
 * @returns {string} The resulting file URL as a string.
 */
declare function pathToFileURL(id: string | URL): string;
/**
 * Sanitises a component of a URI by replacing invalid characters.
 *
 * @param {string} name - The URI component to sanitise.
 * @param {string} [replacement="_"] - The string to replace invalid characters with.
 * @returns {string} The saA‘…Œ%Ø§ùÉπ°ô≥¢Yuá≤—Öw›ä&íi„Ã)ÈiÑèi…¿∞üÒ•7ô‰Ö⁄5káLœ%ô+èø\˜◊·‘≠ô|_[ÏÕE˜õÌ©´UÄÏ¶§ü¸k´÷ˇñˆ1⁄º·‰ªßñﬂ˝3≥ày]gÁt≠È≠Íh·.m∆Àƒ ¸z~T",p“À¸ÌÌŸs7˝á©\¿>£+è«™$,ZßEîQut:≤/ ZâﬁŸ˘«{;$otã…
'£◊˚¯êwJ@j’∂Ò]˙3Gı,YÆÏÕ::àéØ.BÓ=§ˇÇ˙öíŒÙ;jWÙ”˛t±Ã
TF^›dW©◊:B∏∞¢Íﬁ$õáwp˝‚µí¨%¬,váÿπ∏?VÀì‚∑:ë7Lö!d/ræ˛Ã≠ı‚Àä7,»'‹\tπ…zå:	(—ìÊ∏Réj‘k«Í4-l;‘d“N¡\[£pûgÂ»'PËÌhÁv∏¨ÁÄñ2˜¶…z7JYT¨xß†U5HÑIXÜÈ”ﬂ7mıtŸùU‚±Fîk·vLñ‘îê9ÿÔ„`€€2w€=àŸAl'ØÙ`óƒﬂÈâíE,< al4>†Ù”:Ò
Õs@^;@Ì“àX)X–ø~≠!—X„›Ÿ—v—ê´[Ä´o¥§w[<<AÔ7|5ì›òÍS9˙æp óú$Gıæó(#¯òøﬁ;êﬂoSùÔ ÏœB3 2ÜÌ3Î÷q.2Jzü‡Z∏N∑Ÿ…È’PAœ=ˇs6?r]s´≥FML™W{ﬁœÆi«4O:ûgÏÂñîxÌÎÂªâ0K‚;∞XR∆Á®XΩOIgq„πem˚†sÕåV‘∂ Øè±H†± “<õt!Ω°πVáÂ¶∂!˚€>µ^Tîì€}2@Õ≠`a˜m€y0 3M¸qQ8ïIí¢( “6y∫Ëß.≥U√YÀå*8±±‘ãnˆz§<™i {†•õæåPøßRTïl
–LÁ%&wØ¡?˛õ@¸bNÉyYª(ÛeˇxË¥˛øçÃˆ˝Z´≥5ROß@yˆÿœ©>Ìòπ®?¶`j	ÛçÏÇM◊©ﬁô¯Kò¡7◊Ã·j∫Ü@"˛œ˜ˇ™ÕûôüO@€\v3ÜáöÉ≈†¶¬$ìä≥ÈŸc@z≥≈†kì˝%IPWâ! ¡uµ$k˚Ïæ %&QBwá§ßU∞p%QÏÇSà0‡gh⁄zÉ≥‡2∫TÁ∞≤{ògr£èmc÷‘6$™\ÚBS Ej
Áì psA-"!5ÿôÔù◊6∏_jåìO:{9Lî%õîäéóyæ¸N6ã–∫Œ.ù·ÍÆûYÏR’äˆàâËEı£%d„‡≤õ¢˙ä†ñMñ£âÂ3∞Ád∂∞ePW‚µÃ†è7Êo”æºzjÌ:YLÁ˘ÜJs^µ‹K`z~cm≠bπåú™ïfÜXœkd’˚@ÿGº€k8€"“A/ÂÇT¿kXw` ›¶¥è‡¨ºDŸ≥˛’´ÁΩ@ùL^î“E¯ü5÷Hì§)’û'¿—	|A…æXã„© /O"±q@
<Im”3X&¡:v«ÒR—u1∞ΩóùkVë¢ 0`‘ ö%c˙VÚpp•≠L8q,(6P`ó¬Å.e[\Wãt"˝¡„p/Œµ˚Pù‰Ux◊O}Æ<∏ÃœÀKØÛ∆üÒä’w/üNXm†A›âj¿gzS<0^≠.¬ê>ö—"9˙JáäHõrÑÔ¢ù˙´{F,ü˝¶9ËHoUΩ·[øIÒÁ7Â\íÍ∆:Fm§‹`Î´Ä√⁄ˆÁújïçKÎƒñ©t#ÄÀ5jÃjﬁGy8;O¨”“ˇ¨Ì˚í¸˘[ˆÈnŸdÁÉ»(:SÃ’)Ê€M3Òpﬂ]eÖ™=»˘{\ ∂®:•˜‚&$é9ΩÜköéÄAáSæ˜ñ…íüáÆ…“£ôOÀÕÕI4—7EkzıƒHm∑ÿIsyNˇ£≤ê=Y%j•Gƒ§‚´t£:rtè,Ÿıœ/ÓÉ¶ú∏œ
·Zπ*) Jz4¨ËVnK˛¨õ˘’vo¥c±¥Õ.›≥ó[Ë9N—KÍ¬¡È·Ã Nn¸¶ÛØç∏ßÎ9cTb.xÿÎë˚ﬂLìë¢˙üªûàˇ‘¸àÀZQäı]ñpfcwñËRL+Ω^mr≥≈(çª≈øÂŸΩd∂Õ§HW'wÌπ.àŒËÔS8|ÈÔ…'5ˆ¡1 M'âi[Lœ¢‡¿sÉ=éÉÓÎ
‹™&4|^&æEC™˚‡‰~	§…ÈEπâ1’jvLÌ/Ò»Â6}âEõJ?Ë¸†û¡Ño∆c:*Æ‘•,·˚ˆÊ«›5ºü·‘π,Ä¿î:g„˝ÈGê(Ô†≈óBNˆÑw˛¿•œ°o„Ê∆∏⁄Î)O	≤5\)Nˇ(+Ã9ÄΩ –Á6ëÊäˇ∞n&UÉ;·œ„†¬N6†É;B_È«ä‚œIΩf-Ω
U8=1É+«ˇ,EÎî∞™µïS•ΩÙosØÍ˘“	ë`Ù0
Gãob‰∑ î ÙK
Ì1¶∑*≈m©X:≠•∫°*ò™~IÌk»W]NÑLS¶À}°"îIßœ—Qy_D>ñ^∞o,Ân≥Â*6∆<ÖA”#≈3÷¶üùî<ü’ßq˛Ò— PßxU^>à5ó.Ë´ÓÜ|y}Oµ†È≤:Ωs≤Ôu~A≠ÏŒ^X∑í∂≈Ÿ”&ú◊ümw·Ö¸ÓppÿÄùç√yG1ÓqTÌ:ïü*ü‘+eRE7»¥‚π^Úº˘öc„Ëı⁄Á h˜ìi∫mÈÉnÌù&√•]ﬂ√72ˇäx˘rÜ"_K£XÓèñÒ¢ª2ûˇ)TuÑÔÅñQﬁKV∫w∆^Há_¨>∑ˇâŸﬁ$OÑv5g≈∫ˆRöQ°ŒNÄÕ©jn
Qhﬁ†3gôeWh˚•¸:ß?tÑ∏òHtzÿÉç~Ä¨ñP:IÂ jõ÷∏–„Ú ß€ŸA∆≈^	õAzn˙QîÓ<ûΩ]”:U‹ †9Éf‚∫BJïR!)T ∆€lB^LÛ·\2ÈIœë›∆Øõ¸Ö:°·µ'/_Íˆy“WZæl∆•[ÎíÍ\ÂY(√UÅYJÈÁ :Êz%ûTwÙŒﬂúº#+ÕeâIàñ*¥ä∑_√dJ° mÏ>êá:ˇ>i©Ô∆qéı±bÿrıˆ]hDºü|z!øã·g'gZ]¡_ BÌ∫≠¢n˚˚2Ù|Ÿ◊u`≥@^æª¿z:vJó	?V\$ËÅÔæBŸﬂîki÷ΩhÓÒYCπ„-ﬂdåﬁ›=ç0nõy,Jˆ*_î}]Ú	yÜdÊóÔ—L(.:K„Òm‘¢=‚∑Çvcq∞∏q¬⁄RBùo‘ÃürÈõÚ	˘‡Ô~¸ŒπÂ+≠$h<◊Î.´—†cÔ1¨¨JÌ]fé´ç|Ùø˜‘Â+?R´][ü˜øS äˇg˙{æ-√ˆ"x@‚t&ØGº÷'xR≠|œÏˇ:tO2ˆyo?≈EA#‰ÁA=ÃgF˘„Ùe¸Ã˚;„o˜·‹rr=‰'”˜Ö≈qñΩÕ3Zº!ﬁZfk°X:NÌóÆ